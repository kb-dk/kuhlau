default namespace = "http://www.music-encoding.org/ns/mei"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2011-11-15T22:19:22Z. 
# Edition: 2011
# Edition Location: http://www.tei-c.org/Vault/P5//
#

#
data.BEND.AMOUNT =
  xsd:decimal { pattern = "1|\.25|\.5|\.75" }
  | xsd:token { pattern = "full" }
data.BEAT = xsd:decimal { minInclusive = "0" }
data.BEATRPT.REND =
  xsd:positiveInteger { pattern = "4|8|16|32|64|128" }
  | xsd:token { pattern = "mixed" }
data.COLOR =
  xsd:token {
    pattern =
      "(x[0-9A-Fa-f]{6,6}|aqua|black|fuchsia|gray|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow)"
  }
data.COLORS = list { data.COLOR+ }
data.DEGREES = xsd:decimal
data.FINGER.FRET =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "4" }
  | xsd:token { pattern = "x|o" }
data.FRET =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "5" }
data.INTERVAL.AMOUNT =
  xsd:decimal
  | xsd:token { pattern = "u|d|s" }
data.ISODATE =
  xsd:date
  | xsd:gYear
  | xsd:gMonth
  | xsd:gDay
  | xsd:gYearMonth
  | xsd:gMonthDay
  | xsd:time
  | xsd:dateTime
  | xsd:token { pattern = "[0-9.,DHMPRSTWYZ/:+\-]+" }
data.ISOTIME = xsd:time
data.MEASUREBEAT =
  xsd:token { pattern = "([0-9]+m\s*\+\s*)?[0-9]+(\.?[0-9]*)?" }
data.MIDINAMES =
  "Acoustic_Grand_Piano"
  | "Bright_Acoustic_Piano"
  | "Electric_Grand_Piano"
  | "Honky-tonk_Piano"
  | "Electric_Piano_1"
  | "Electric_Piano_2"
  | "Harpsichord"
  | "Clavi"
  | "Celesta"
  | "Glockenspiel"
  | "Music_Box"
  | "Vibraphone"
  | "Marimba"
  | "Xylophone"
  | "Tubular_Bells"
  | "Dulcimer"
  | "Drawbar_Organ"
  | "Percussive_Organ"
  | "Rock_Organ"
  | "Church_Organ"
  | "Reed_Organ"
  | "Accordion"
  | "Harmonica"
  | "Tango_Accordion"
  | "Acoustic_Guitar_nylon"
  | "Acoustic_Guitar_steel"
  | "Electric_Guitar_jazz"
  | "Electric_Guitar_clean"
  | "Electric_Guitar_muted"
  | "Overdriven_Guitar"
  | "Distortion_Guitar"
  | "Guitar_harmonics"
  | "Acoustic_Bass"
  | "Electric_Bass_finger"
  | "Electric_Bass_pick"
  | "Fretless_Bass"
  | "Slap_Bass_1"
  | "Slap_Bass_2"
  | "Synth_Bass_1"
  | "Synth_Bass_2"
  | "Violin"
  | "Viola"
  | "Cello"
  | "Contrabass"
  | "Tremolo_Strings"
  | "Pizzicato_Strings"
  | "Orchestral_Harp"
  | "Timpani"
  | "String_Ensemble_1"
  | "String_Ensemble_2"
  | "SynthStrings_1"
  | "SynthStrings_2"
  | "Choir_Aahs"
  | "Voice_Oohs"
  | "Synth_Voice"
  | "Orchestra_Hit"
  | "Trumpet"
  | "Trombone"
  | "Tuba"
  | "Muted_Trumpet"
  | "French_Horn"
  | "Brass_Section"
  | "SynthBrass_1"
  | "SynthBrass_2"
  | "Soprano_Sax"
  | "Alto_Sax"
  | "Tenor_Sax"
  | "Baritone_Sax"
  | "Oboe"
  | "English_Horn"
  | "Bassoon"
  | "Clarinet"
  | "Piccolo"
  | "Flute"
  | "Recorder"
  | "Pan_Flute"
  | "Blown_Bottle"
  | "Shakuhachi"
  | "Whistle"
  | "Ocarina"
  | "Lead_1_square"
  | "Lead_2_sawtooth"
  | "Lead_3_calliope"
  | "Lead_4_chiff"
  | "Lead_5_charang"
  | "Lead_6_voice"
  | "Lead_7_fifths"
  | "Lead_8_bass_and_lead"
  | "Pad_1_new_age"
  | "Pad_2_warm"
  | "Pad_3_polysynth"
  | "Pad_4_choir"
  | "Pad_5_bowed"
  | "Pad_6_metallic"
  | "Pad_7_halo"
  | "Pad_8_sweep"
  | "FX_1_rain"
  | "FX_2_soundtrack"
  | "FX_3_crystal"
  | "FX_4_atmosphere"
  | "FX_5_brightness"
  | "FX_6_goblins"
  | "FX_7_echoes"
  | "FX_8_sci-fi"
  | "Sitar"
  | "Banjo"
  | "Shamisen"
  | "Koto"
  | "Kalimba"
  | "Bagpipe"
  | "Fiddle"
  | "Shanai"
  | "Tinkle_Bell"
  | "Agogo"
  | "Steel_Drums"
  | "Woodblock"
  | "Taiko_Drum"
  | "Melodic_Tom"
  | "Synth_Drum"
  | "Reverse_Cymbal"
  | "Guitar_Fret_Noise"
  | "Breath_Noise"
  | "Seashore"
  | "Bird_Tweet"
  | "Telephone_Ring"
  | "Helicopter"
  | "Applause"
  | "Gunshot"
data.MIDITEMPO =
  xsd:positiveInteger { minInclusive = "10" maxInclusive = "1000" }
data.MODUSMAIOR =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.MODUSMINOR =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.OCTAVE.DIS = xsd:positiveInteger { pattern = "8|15|22" }
data.ORIENTATION = xsd:token { pattern = "reversed|90CW|90CCW" }
data.PAGE.PANELS =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "2" }
data.PERCENT = xsd:token { pattern = "[0-9]+(\.?[0-9]*)?%" }
data.PROLATIO =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.RATIO =
  xsd:token { pattern = "[0-9]+(\.?[0-9]*)?:[0-9]+(\.?[0-9]*)?" }
data.SLASH =
  xsd:positiveInteger { minInclusive = "1" maxInclusive = "6" }
data.STRINGNUMBER = xsd:positiveInteger
data.TEMPOVALUE = xsd:positiveInteger
data.TEMPUS =
  xsd:positiveInteger { minInclusive = "2" maxInclusive = "3" }
data.TSTAMPOFFSET = xsd:decimal
data.URI = xsd:anyURI
data.URIS = list { data.URI+ }
data.ACCIDENTAL.EXPLICIT =
  
  ## sharp
  "s"
  | 
    ## flat
    "f"
  | 
    ## double sharp
    ##         (written as 2 sharps)
    "ss"
  | 
    ## double sharp
    ##         (written using croix)
    "x"
  | 
    ## double
    ##         flat
    "ff"
  | 
    ## triple sharp
    ##         (written as croix and 2 sharps)
    "xs"
  | 
    ## triple sharp
    ##         (written as 3 sharps)
    "ts"
  | 
    ## triple
    ##         flat
    "tf"
  | 
    ## natural
    "n"
  | 
    ## natural +
    ##         flat
    "nf"
  | 
    ## natural +
    ##         sharp
    "ns"
  | 
    ## sharp note
    ##         raised by quarter tone
    "su"
  | 
    ## sharp note
    ##         lowered by quarter tone
    "sd"
  | 
    ## flat note
    ##         raised by quarter tone
    "fu"
  | 
    ## flat note
    ##         lowered by quarter tone
    "fd"
  | 
    ## natural note
    ##         raised by quarter tone
    "nu"
  | 
    ## natural note
    ##         lowered by quarter tone
    "nd"
data.ACCIDENTAL.IMPLICIT =
  
  ## sharp
  "s"
  | 
    ## flat
    "f"
  | 
    ## double
    ##         sharp
    "ss"
  | 
    ## double
    ##         flat
    "ff"
  | 
    ## natural
    "n"
data.ARTICULATION =
  
  ## accent (Unicode
  ##         1D17B)
  "acc"
  | 
    ## staccato
    ##         (Unicode 1D17C)
    "stacc"
  | 
    ## tenuto (Unicode
    ##         1D17D)
    "ten"
  | 
    ## staccatissimo
    ##         (Unicode 1D17E)
    "stacciss"
  | 
    ## marcato
    ##         (Unicode 1D17F)
    "marc"
  | 
    ## marcato +
    ##         staccato (Unicode 1D180)
    "marc-stacc"
  | 
    ## spiccato
    "spicc"
  | 
    ## main note
    ##         followed by short slide to higher, indeterminate pitch (Unicode 1D185)
    "doit"
  | 
    ## main note
    ##         preceded by short slide from lower, indeterminate pitch (Unicode 1D186)
    "rip"
  | 
    ## main note
    ##         preceded by "slide" from higher, indeterminate pitch
    "plop"
  | 
    ## main note
    ##         followed by long "slide" to lower, indeterminate pitch
    "fall"
  | 
    ## "lip slur" to
    ##         lower pitch, then return to written pitch
    "bend"
  | 
    ## main note
    ##         followed by quick upward rise, then descent in pitch (Unicode 1D187)
    "flip"
  | 
    ## (Unicode
    ##         1D188)
    "smear"
  | 
    ## down bow
    ##         (Unicode 1D1AA)
    "dnbow"
  | 
    ## up bow (Unicode
    ##         1D1AB)
    "upbow"
  | 
    ## harmonic
    ##         (Unicode 1D1AC)
    "harm"
  | 
    ## snap pizzicato
    ##         (Unicode 1D1AD)
    "snap"
  | 
    ## fingernail
    ##         (Unicode 1D1B3)
    "fingernail"
  | 
    ## tenuto +
    ##         staccato (Unicode 1D182)
    "ten-stacc"
  | 
    ## dampen harp
    ##         string (Unicode 1D1B4)
    "damp"
  | 
    ## dampen all harp
    ##         strings (Unicode 1D1B5)
    "dampall"
  | 
    ## full (as
    ##         opposed to stopped) tone
    "open"
  | 
    ## "muffled"
    ##         tone
    "stop"
  | 
    ## double tongue
    ##         (Unicode 1D18A)
    "dbltongue"
  | 
    ## triple tongue
    ##         (Unicode 1D18B)
    "trpltongue"
  | 
    ## use heel (organ
    ##         pedal)
    "heel"
  | 
    ## use toe (organ
    ##         pedal)
    "toe"
  | 
    ## percussive
    ##         effect on guitar string(s)
    "tap"
  | 
    ## left-hand
    ##         pizzicato
    "lhpizz"
  | 
    ## uninterpreted
    ##         dot
    "dot"
  | 
    ## uninterpreted
    ##         stroke
    "stroke"
data.ARTICULATIONS = list { data.ARTICULATION+ }
data.AUGMENTDOT = xsd:nonNegativeInteger { maxInclusive = "4" }
data.BARPLACE =
  
  ## between staves
  ##         only
  "mensur"
  | 
    ## between and
    ##         across staves as necessary
    "staff"
  | 
    ## short line
    ##         above staff or through top line
    "takt"
data.BARRENDITION =
  
  ## dashed line
  ##         (Unicode 1D104)
  "dashed"
  | 
    ## dotted
    ##         line
    "dotted"
  | 
    ## (Unicode
    ##         1D101)
    "dbl"
  | 
    ## double dashed
    ##         line
    "dbldashed"
  | 
    ## double dotted
    ##         line
    "dbldotted"
  | 
    ## (Unicode
    ##         1D102)
    "end"
  | 
    ## bar line not
    ##         rendered
    "invis"
  | 
    ## repeat start
    ##         (Unicode 1D106)
    "rptstart"
  | 
    ## repeat start
    ##         and end
    "rptboth"
  | 
    ## repeat end
    ##         (Unicode 1D107)
    "rptend"
  | 
    ## (Unicode
    ##         1D100)
    "single"
data.BEAM = xsd:token { pattern = "[i|m|t][1-6]" }
data.BEAMS = list { data.BEAM+ }
data.BOOLEAN = "true" | "false"
data.CERTAINTY = "high" | "medium" | "low" | "unknown"
data.CLEFLINE = xsd:positiveInteger
data.CLEFSHAPE =
  
  ## G clef (Unicode
  ##         1D11E)
  "G"
  | 
    ## Double G
    ##         clef
    "GG"
  | 
    ## F clef (Unicode
    ##         1D122)
    "F"
  | 
    ## C clef (Unicode
    ##         1D121)
    "C"
  | 
    ## Drum clef
    ##         (Unicode 1D125 or Unicode 1D126)
    "perc"
  | 
    ## tablature
    ##         "clef"; i.e. usually "TAB" rendered vertically
    "TAB"
data.CLUSTER =
  
  ## unfilled
  ##         box
  "whbox"
  | 
    ## filled
    ##         box
    "blbox"
data.CURVERENDITION =
  
  ## default line
  ##         width
  "narrow"
  | 
    ## twice as wide
    ##         as normal
    "medium"
  | 
    ## twice as wide
    ##         as medium
    "wide"
  | 
    ## dashed
    "dashed"
  | 
    ## dotted
    "dotted"
data.DURATION = data.DURATION.cmn | data.DURATION.mensural
data.ENCLOSURE =
  
  ## parentheses
  "paren"
  | 
    ## square
    ##         brackets
    "brack"
data.FONTFAMILY = xsd:token
data.FONTNAME = xsd:token
data.FONTSTYLE =
  
  ## text slants to
  ##         right
  "ital"
  | 
    ## unadorned
    "normal"
  | 
    ## text slants to
    ##         the left
    "oblique"
data.FONTWEIGHT = "bold"
data.FRETNUMBER =
  xsd:nonNegativeInteger { minInclusive = "1" maxInclusive = "9" }
  | xsd:token { pattern = "o" }
data.GLISSANDO =
  
  ## first
  ##         note/chord in glissando
  "i"
  | 
    ## note/chord
    ##         that's neither first nor last in glissando
    "m"
  | 
    ## last note in
    ##         glissando
    "t"
data.GRACE =
  
  ## time "stolen"
  ##         from following note
  "acc"
  | 
    ## time "stolen"
    ##         from previous note
    "unacc"
  | 
    ## no
    ##         interpretation regarding performed value of grace note
    "unknown"
data.HEADSHAPE =
  
  ## filled oval
  ##         (Unicode 1D158)
  "quarter"
  | 
    ## open oval
    ##         (Unicode 1D157)
    "half"
  | 
    ## open oval
    ##         (Unicode 1D15D)
    "whole"
  | 
    ## modern breve
    ##         (Unicode 1D15C)
    "dblwhole"
  | 
    ## filled diamond
    ##         (Unicode 1D1BA)
    "filldiamond"
  | 
    ## open diamond
    ##         (Unicode 1D1B9)
    "diamond"
  | 
    ## double whole
    ##         diamond (Mup)
    "dwdiamond"
  | 
    ## filled
    ##         isosceles triangle (Unicode 1D149)
    "fillisotriangle"
  | 
    ## open isosceles
    ##         triangle (Unicode 1D148)
    "isotriangle"
  | 
    ## double whole
    ##         open isosceles triangle (Unicode 1D14E)
    "dwhisotriangle"
  | 
    ## filled
    ##         downward-pointing wedge (Unicode 1D155)
    "fillpiewedge"
  | 
    ## downward-pointing wedge (Unicode 1D154)
    "piewedge"
  | 
    ## double whole
    ##         downward-pointing wedge (Mup)
    "dwhpiewedge"
  | 
    ## filled
    ##         rectangle (Unicode 1D147)
    "fillrectangle"
  | 
    ## open rectangle
    ##         (Unicode 1D146)
    "rectangle"
  | 
    ## double whole
    ##         open rectangle (Mup)
    "dwhrectangle"
  | 
    ## filled right
    ##         triangle (Unicode 1D14B)
    "fillrtriangle"
  | 
    ## open right
    ##         triangle (Unicode 1D14A)
    "rtriangle"
  | 
    ## double whole
    ##         right triangle (Mup)
    "dwrtriangle"
  | 
    ## filled upper
    ##         right triangle (Unicode 1D151) 
    "fillurtriangle"
  | 
    ## open upper
    ##         right triangle (Unicode 1D150)
    "urtriangle"
  | 
    ## double whole
    ##         upper right triangle
    "dwurtriangle"
  | 
    ## filled
    ##         semi-circle (Unicode 1D153)
    "fillsemicircle"
  | 
    ## open
    ##         semi-circle (Unicode 1D152)
    "semicircle"
  | 
    ## double whole
    ##         open semi-circle (Mup)
    "dwsemicircle"
  | 
    ## filled slash
    ##         (Mup)
    "fillslash"
  | 
    ## open slash
    ##         (Mup)
    "slash"
  | 
    ## double whole
    ##         open slash (Mup)
    "dwslash"
  | 
    ## X (Unicode
    ##         1D143)
    "x"
  | 
    ## note head not
    ##         rendered (Unicode 1D159)
    "blank"
  | 
    ## X within circle
    ##         (Unicode 1D145)
    "circlex"
  | 
    ## plus sign
    ##         (Unicode 1D144)
    "cross"
data.INEUMENAME =
  
  ##
  "pessubpunctis"
  | 
    ##
    "climacus"
  | 
    ##
    "scandicus"
  | 
    ##
    "bistropha"
  | 
    ##
    "tristropha"
  | 
    ##
    "pressusminor"
  | 
    ##
    "pressusmaior"
data.INEUMEFORM =
  
  ##
  "liquescent1"
  | 
    ##
    "liquescent2"
  | 
    ##
    "tied"
  | 
    ##
    "tiedliquescent1"
  | 
    ##
    "tiedliquescent2"
data.KEYSIGNATURE = xsd:token { pattern = "mixed|0|[1-7][f|s]" }
data.LAYERSCHEME =
  
  ## single
  ##         layer
  "1"
  | 
    ## two layers with
    ##         opposing stems
    "2o"
  | 
    ## two layers with
    ##         'floating' stems
    "2f"
  | 
    ##
    "3o"
  | 
    ##
    "3f"
data.LIGATUREFORM =
  
  ## notes are
  ##         "squeezed" together
  "recta"
  | 
    ## individual
    ##         notes are replaced by an oblique figure
    "obliqua"
data.LINERENDITION =
  
  ## default line
  ##         width
  "narrow"
  | 
    ## twice as wide
    ##         as narrow
    "medium"
  | 
    ## twice as wide
    ##         as medium
    "wide"
  | 
    ## dashed
    ##         line
    "dashed"
  | 
    ## dotted
    ##         line
    "dotted"
  | 
    ## undulating
    ##         line
    "wavy"
data.MENSURATIONSIGN =
  
  ## tempus
  ##         imperfectum
  "C"
  | 
    ## tempus
    ##         perfectum
    "O"
data.METERSIGN =
  
  ## common time;
  ##         i.e. 4/4
  "common"
  | 
    ## cut time; i.e.
    ##         2/2
    "cut"
data.MIDICHANNEL = xsd:positiveInteger { maxInclusive = "16" }
data.MIDIVALUE = xsd:nonNegativeInteger { maxInclusive = "127" }
data.MODE =
  "major"
  | "minor"
  | "dorian"
  | "phrygian"
  | "lydian"
  | "mixolydian"
  | "aeolian"
  | "locrian"
data.MUSICFONT = xsd:token
data.OCTAVE = xsd:nonNegativeInteger { maxInclusive = "9" }
data.PGSCALE = data.PERCENT | data.RATIO
data.PGUNITS =
  
  ## inches
  "in"
  | 
    ## centimeters
    "cm"
  | 
    ## millimeters
    "mm"
data.PITCHCLASS = xsd:nonNegativeInteger { maxInclusive = "11" }
data.PITCHNAME = xsd:token { pattern = "[a-g]" }
data.PITCHNAME.GES = xsd:token { pattern = "[a-g]|none" }
data.PITCHNUMBER = xsd:nonNegativeInteger
data.PLACE = "above" | "below"
data.OTHERSTAFF = "above" | "below"
data.STAFFREL =
  
  ## written above
  ##         staff
  "above"
  | 
    ## written below
    ##         staff
    "below"
  | 
    ## written on
    ##         staff
    "within"
data.SIZE =
  
  ## default
  ##         size
  "normal"
  | 
    ## reduced
    ##         size
    "cue"
data.SLUR = xsd:token { pattern = "[i|m|t][1-6]" }
data.SLURS = list { data.SLUR+ }
data.STAFFLOC = xsd:integer
data.STEMDIRECTION =
  
  ## stem points
  ##         upward
  "up"
  | 
    ## stem points
    ##         downward
    "down"
data.STEMMODIFIER =
  
  ## 1 slash through
  ##         stem
  "1slash"
  | 
    ## 2 slashes
    ##         through stem
    "2slash"
  | 
    ## 3 slashes
    ##         through stem
    "3slash"
  | 
    ## 4 slashes
    ##         through stem
    "4slash"
  | 
    ## 5 slashes
    ##         through stem
    "5slash"
  | 
    ## 6 slashes
    ##         through stem
    "6slash"
  | 
    ## X placed on
    ##         stem
    "sprech"
  | 
    ## Z placed on
    ##         stem
    "z"
data.STEMPOSITION =
  
  ## stem attached
  ##         to left side of note head
  "left"
  | 
    ## stem attached
    ##         to right side of note head
    "right"
  | 
    ## stem is
    ##         originates from center of note head
    "center"
data.TEMPERAMENT =
  
  ## equal or
  ##         12-tone temperament
  "equal"
  | 
    ## just
    ##         intonation
    "just"
  | 
    ## meantone
    ##         intonation
    "mean"
  | 
    ## pythagorean
    ##         tuning
    "pythagorean"
data.TEXTRENDITION =
  
  ## enclosed in
  ##         box
  "box"
  | 
    ## enclosed in
    ##         circle/ellipse
    "circle"
  | 
    ## underlined
    ##         twice
    "dblunderline"
  | 
    ## not
    ##         rendered
    "none"
  | 
    ## quoted; context
    ##         determines which quotation signs are used
    "quote"
  | 
    ## struck through
    ##         by '\'
    "bslash"
  | 
    ## struck through
    ##         by '/'
    "fslash"
  | 
    ## small
    ##         capitals
    "smcaps"
  | 
    ## stuck through
    ##         by '-'
    "strike"
  | 
    ## subscript
    "sub"
  | 
    ## superscript
    "sup"
  | 
    ## underlined
    "underline"
data.TIE = xsd:token { pattern = "[i|m|t]" }
data.TIES = list { data.TIE+ }
data.TUPLET = xsd:token { pattern = "[i|m|t][1-6]" }
data.TUPLETS = list { data.TUPLET+ }
data.UNEUMENAME =
  
  ##
  "punctum"
  | 
    ##
    "virga"
  | 
    ##
    "pes"
  | 
    ##
    "clivis"
  | 
    ##
    "torculus"
  | 
    ##
    "torculusresupinus"
  | 
    ##
    "porrectus"
  | 
    ##
    "porrectusflexus"
  | 
    ##
    "apostropha"
  | 
    ##
    "oriscus"
  | 
    ##
    "pressusmaior"
  | 
    ##
    "pressusminor"
  | 
    ##
    "virgastrata"
data.UNEUMEFORM =
  
  ##
  "liquescent1"
  | 
    ##
    "liquescent2"
  | 
    ##
    "liquescent3"
  | 
    ##
    "quilismatic"
  | 
    ##
    "rectangular"
  | 
    ##
    "rhombic"
  | 
    ##
    "tied"
data.INTERLINE = xsd:decimal
macro.metaLike.page = fw*, pgDesc?
macro.musicPart = model.frontLike?, (body | group)?, model.backLike?
macro.availabilityPart =
  (acqSource, (accessRestrict, price?)*)*,
  useRestrict?,
  sysReq?
macro.workPart = history?, langUsage?, key?, tempo?, meter?, perfMedium?
macro.bibldescPart = editionStmt?, pubStmt?, physDesc?, seriesStmt?
data.DURATION.cmn =
  
  ## quadruple whole
  ##         note
  "long"
  | 
    ## double whole
    ##         note
    "breve"
  | 
    ## whole
    ##         note
    "1"
  | 
    ## half
    ##         note
    "2"
  | 
    ## quarter
    ##         note
    "4"
  | 
    ## 8th
    ##         note
    "8"
  | 
    ## 16th
    ##         note
    "16"
  | 
    ## 32nd
    ##         note
    "32"
  | 
    ## 64th
    ##         note
    "64"
  | 
    ## 128th
    ##         note
    "128"
  | 
    ## 256th
    ##         note
    "256"
  | 
    ## 512th
    ##         note
    "512"
  | 
    ## 1024th
    ##         note
    "1024"
  | 
    ## 2048th
    ##         note
    "2048"
data.DURATION.mensural =
  "maxima"
  | "longa"
  | "brevis"
  | "semibrevis"
  | "minima"
  | "semiminima"
  | "fusa"
  | "semifusa"
macro.neumeModifierLike = empty
att.accidental.attributes = att.accidental.attribute.accid
att.accidental.attribute.accid =
  
  ## captures a
  ##           written accidental.
  attribute accid { data.ACCIDENTAL.EXPLICIT }?
att.accidental.performed.attributes =
  att.accidental.performed.attribute.accid.ges
att.accidental.performed.attribute.accid.ges =
  
  ## records the
  ##           performed pitch inflection when it differs from the written accidental.
  attribute accid.ges { data.ACCIDENTAL.IMPLICIT }?
att.altsym.attributes = att.altsym.attribute.altsym
att.altsym.attribute.altsym =
  
  ## provides a
  ##           way of pointing to a user-defined symbol. It must contain an ID of a <symbolDef>
  ##           element elsewhere in the document.
  attribute altsym { data.URI }?
att.articulation.attributes = att.articulation.attribute.artic
att.articulation.attribute.artic =
  
  ## encodes the
  ##           written articulation(s). Articulations are normally encoded in order from the note head
  ##           outward; that is, away from the stem. See additional notes at att.vis.note. Only
  ##           articulations should be encoded in the artic attribute; fingerings should be encoded using
  ##           the <dir> element.
  attribute artic { data.ARTICULATIONS }?
att.articulation.performed.attributes =
  att.articulation.performed.attribute.artic.ges
att.articulation.performed.attribute.artic.ges =
  
  ## records
  ##           performed articulation that differs from the written value.
  attribute artic.ges { data.ARTICULATIONS }?
att.augmentdots.attributes = att.augmentdots.attribute.dots
att.augmentdots.attribute.dots =
  
  ## records the
  ##           number of augmentation dots required by a dotted duration.
  attribute dots { data.AUGMENTDOT }?
att.authorized.attributes =
  att.authorized.attribute.authority, att.authorized.attribute.authURI
att.authorized.attribute.authority =
  
  ## a name or
  ##           label associated with the controlled vocabulary from which the value is
  ##           taken.
  attribute authority { text }?
att.authorized.attribute.authURI =
  
  ## the
  ##           web-accessible location of the controlled vocabulary from which the value is
  ##           taken.
  attribute authURI { data.URI }?
att.regularized.attributes = att.regularized.attribute.reg
att.regularized.attribute.reg =
  
  ## provides a
  ##           regularized, authorized value.
  attribute reg { text }?
att.barplacement.attributes =
  att.barplacement.attribute.barplace,
  att.barplacement.attribute.taktplace
att.barplacement.attribute.barplace =
  
  ## records the
  ##           location of a bar line.
  attribute barplace { data.BARPLACE }?
att.barplacement.attribute.taktplace =
  
  ## If takt bar
  ##           lines are to be used, then the taktplace attribute may be used to denote the staff
  ##           location of the shortened bar line. The location may include staff lines, spaces, and the
  ##           spaces directly above and below the staff. The value ranges between 0 (just below the
  ##           staff) to 2 * number of staff lines (directly above the staff). For example, on a 5-line
  ##           staff the lines would be numbered 1,3,5,7, and 9 while the spaces would be numbered
  ##           0,2,4,6,8,10. For example, a value of '9' puts the bar line through the top line of a
  ##           5-line staff.
  attribute taktplace { data.STAFFLOC }?
att.beaming.vis.attributes =
  att.beaming.vis.attribute.beam.rend,
  att.beaming.vis.attribute.beam.slope
att.beaming.vis.attribute.beam.rend =
  
  ## encodes
  ##           whether a beam is "feathered" and in which direction.
  attribute beam.rend {
    
    ## beams lines
    ##             grow farther apart from left to right
    "acc"
    | 
      ## beam lines
      ##             grow closer together from left to right
      "rit"
    | 
      ## beam lines
      ##             are equally-spaced over the entire length of the beam
      "norm"
  }?
att.beaming.vis.attribute.beam.slope =
  
  ## captures beam
  ##           slope.
  attribute beam.slope { xsd:decimal }?
att.bibl.attributes = att.bibl.attribute.analog
att.bibl.attribute.analog =
  
  ## contains a
  ##           reference to a field or element in another descriptive encoding system to which this MEI
  ##           element is comparable. Mapping elements from one system to another may help a repository
  ##           harvest selected data from the MEI file to build a basic catalog record. The encoding
  ##           system from which fields are taken must be specified. When possible, subfields as well as
  ##           fields should be specified, e.g., subfields within MARC fields.
  attribute analog { text }?
att.calendared.attributes = att.calendared.attribute.calendar
att.calendared.attribute.calendar =
  
  ## indicates the
  ##           calendar system to which a date belongs, for example, Gregorian, Julian, Roman, Mosaic,
  ##           Revolutionary, Islamic, etc.
  attribute calendar { xsd:NMTOKEN }?
att.canonical.attributes = att.canonical.attribute.dbkey
att.canonical.attribute.dbkey =
  
  ## used to
  ##           record a value which serves as a primary key in an external database.
  attribute dbkey { xsd:NMTOKEN }?
att.cleffing.log.attributes =
  att.cleffing.log.attribute.clef.shape,
  att.cleffing.log.attribute.clef.line,
  att.cleffing.log.attribute.clef.dis,
  att.cleffing.log.attribute.clef.dis.place
att.cleffing.log.attribute.clef.shape =
  
  ## encodes a
  ##           value for the clef symbol.
  attribute clef.shape { data.CLEFSHAPE }?
att.cleffing.log.attribute.clef.line =
  
  ## contains a
  ##           default value for the position of the clef. The value must be in the range between 1 and
  ##           the number of lines on the staff. The numbering of lines starts with the lowest line of
  ##           the staff.
  attribute clef.line { data.CLEFLINE }?
att.cleffing.log.attribute.clef.dis =
  
  ## records the
  ##           amount of octave displacement to be applied to the clef.
  attribute clef.dis { data.OCTAVE.DIS }?
att.cleffing.log.attribute.clef.dis.place =
  
  ## records the
  ##           direction of octave displacement to be applied to the clef.
  attribute clef.dis.place { data.PLACE }?
att.cleffing.vis.attributes =
  att.cleffing.vis.attribute.clef.color,
  att.cleffing.vis.attribute.clef.visible
att.cleffing.vis.attribute.clef.color =
  
  ## describes the
  ##           color of the clef.
  attribute clef.color { data.COLOR }?
att.cleffing.vis.attribute.clef.visible =
  
  ## determines
  ##           whether the clef is to be displayed.
  attribute clef.visible { data.BOOLEAN }?
att.clefshape.attributes = att.clefshape.attribute.shape
att.clefshape.attribute.shape =
  
  ## describes a
  ##           clef's shape.
  attribute shape { data.CLEFSHAPE }?
att.color.attributes = att.color.attribute.color
att.color.attribute.color =
  
  ## used to
  ##           indicate visual appearance. Do not confuse this with the musical term 'color' as used in
  ##           pre-CMN notation.
  attribute color { data.COLOR }?
att.coloration.attributes = att.coloration.attribute.colored
att.coloration.attribute.colored =
  
  ## indicates
  ##           this feature is 'colored'; that is, it is a participant in a change in rhythmic values. In
  ##           mensural notation, coloration is indicated by colored notes (red, black, etc.) where void
  ##           notes would otherwise occur. In CMN, coloration is indicated by an inverse color; that is,
  ##           the note head is void when it would otherwise be filled and vice versa.
  attribute colored { data.BOOLEAN }?
att.common.attributes =
  att.common.attribute.id,
  att.common.attribute.label,
  att.common.attribute.n,
  att.common.attribute.base
att.common.attribute.id =
  
  ## regularizes
  ##           the naming of an element and thus facilitates building links between it and other
  ##           resources. Each id attribute within a document must have a unique value.
  attribute xml:id { xsd:ID }?
att.common.attribute.label =
  
  ## provides a
  ##           label for an element. The value may be any string.
  attribute label { text }?
att.common.attribute.n =
  
  ## provides a
  ##           name or number designation for an element. While the value need not be unique, it is
  ##           required to be a single token.
  attribute n { xsd:NMTOKEN }?
att.common.attribute.base =
  
  ## provides a
  ##           base URI reference with which applications can resolve relative URI references into
  ##           absolute URI references.
  attribute xml:base { data.URI }?
att.controlevent.attributes =
  att.plist.attributes,
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes,
  att.staffident.attributes,
  att.layerident.attributes
att.coordinated.attributes =
  att.coordinated.attribute.ulx,
  att.coordinated.attribute.uly,
  att.coordinated.attribute.lrx,
  att.coordinated.attribute.lry
att.coordinated.attribute.ulx =
  
  ## indicates the
  ##           upper-left corner x coordinate.
  attribute ulx { xsd:nonNegativeInteger }?
att.coordinated.attribute.uly =
  
  ## indicates the
  ##           upper-left corner y coordinate.
  attribute uly { xsd:nonNegativeInteger }?
att.coordinated.attribute.lrx =
  
  ## indicates the
  ##           lower-right corner x coordinate.
  attribute lrx { xsd:nonNegativeInteger }?
att.coordinated.attribute.lry =
  
  ## indicates the
  ##           lower-left corner x coordinate.
  attribute lry { xsd:nonNegativeInteger }?
att.curvature.attributes =
  att.curvature.attribute.bezier,
  att.curvature.attribute.bulge,
  att.curvature.attribute.curvedir
att.curvature.attribute.bezier =
  
  ## records the
  ##           placement of Bezier control points as a series of space-separated xy coordinates, e.g., 19
  ##           45 -32 118.
  attribute bezier { text }?
att.curvature.attribute.bulge =
  
  ## describes a
  ##           curve as a set of distance values above or below an imaginary line connecting the
  ##           endpoints of the curve. The bulge attribute must contain one or more decimal values
  ##           expressed in inter-line units.
  attribute bulge { text }?
att.curvature.attribute.curvedir =
  
  ## describes a
  ##           curve with a generic term indicating the direction of curvature.
  attribute curvedir {
    
    ## upward
    ##             curve
    "above"
    | 
      ## downward
      ##             curve
      "below"
  }?
att.curverend.attributes = att.curverend.attribute.rend
att.curverend.attribute.rend =
  
  ## describes the
  ##           line style of the curve.
  attribute rend { data.CURVERENDITION }?
att.datable.attributes =
  att.datable.attribute.enddate,
  att.datable.attribute.notafter,
  att.datable.attribute.notbefore,
  att.datable.attribute.startdate
att.datable.attribute.enddate =
  
  ## contains the
  ##           end point of a date range.
  attribute enddate { data.ISODATE }?
att.datable.attribute.notafter =
  
  ## contains an
  ##           upper boundary for an uncertain date.
  attribute notafter { data.ISODATE }?
att.datable.attribute.notbefore =
  
  ## contains a
  ##           lower boundary for an uncertain date.
  attribute notbefore { data.ISODATE }?
att.datable.attribute.startdate =
  
  ## contains the
  ##           starting point of a date range.
  attribute startdate { data.ISODATE }?
att.datapointing.attributes = att.datapointing.attribute.data
att.datapointing.attribute.data =
  
  ## used to link
  ##           metadata elements to one or more data-containing elements.
  attribute data {
    list { data.URI+ }
  }?
att.declaring.attributes = att.declaring.attribute.decls
att.declaring.attribute.decls =
  
  ## identifies
  ##           one or more metadata elements within the header, which are understood to apply to the
  ##           element bearing this attribute and its content.
  attribute decls {
    list { data.URI+ }
  }?
att.distances.attributes =
  att.distances.attribute.dynam.dist,
  att.distances.attribute.harm.dist,
  att.distances.attribute.text.dist
att.distances.attribute.dynam.dist =
  
  ## records the
  ##           distance from the staff for dynamic marks in 1/2 inter-line units.
  attribute dynam.dist { xsd:decimal }?
att.distances.attribute.harm.dist =
  
  ## records the
  ##           default distance from the staff of harmonic indications, such as guitar chord grids or
  ##           functional labels.
  attribute harm.dist { xsd:decimal }?
att.distances.attribute.text.dist =
  
  ## determines
  ##           how far from the staff to render text elements.
  attribute text.dist { xsd:decimal }?
att.duration.default.attributes =
  att.duration.default.attribute.dur.default
att.duration.default.attribute.dur.default =
  
  ## contains a
  ##           default duration in those situations when the first note, rest, chord, etc. in a measure
  ##           does not have a duration specified.
  attribute dur.default { data.DURATION }?
att.duration.musical.attributes = att.duration.musical.attribute.dur
att.duration.musical.attribute.dur =
  
  ## records the
  ##           duration of a feature using the relative durational values provided by the data.DURATION
  ##           datatype.
  attribute dur { data.DURATION }?
att.duration.performed.attributes =
  att.duration.performed.attribute.dur.ges
att.duration.performed.attribute.dur.ges =
  
  ## records
  ##           performed duration information that differs from written duration. Its value may be
  ##           expressed in any convenient form, such as measures[s]+ beat[s].beatpart, ppq (MIDI
  ##           clicks), Humdrum **recip values, or MusicXML 'divisions', etc.
  attribute dur.ges { text }?
att.duration.ratio.attributes =
  att.duration.ratio.attribute.num, att.duration.ratio.attribute.numbase
att.duration.ratio.attribute.num =
  
  ## along with
  ##           numbase, describes duration as a ratio. num is the first value in the ratio, while numbase
  ##           is the second.
  attribute num { xsd:positiveInteger }?
att.duration.ratio.attribute.numbase =
  
  ## along with
  ##           num, describes duration as a ratio. num is the first value in the ratio, while numbase is
  ##           the second.
  attribute numbase { xsd:positiveInteger }?
att.duration.timestamp.attributes = att.duration.timestamp.attribute.dur
att.duration.timestamp.attribute.dur =
  
  ## records the
  ##           duration of a feature using the relative durational values provided by the
  ##           data.MEASUREBEAT datatype.
  attribute dur { data.MEASUREBEAT }?
att.enclosingchars.attributes = att.enclosingchars.attribute.enclose
att.enclosingchars.attribute.enclose =
  
  ## records the
  ##           characters often used to mark accidentals, articulations, and sometimes notes as having a
  ##           cautionary or editorial function. For an example of cautionary accidentals enclosed in
  ##           parentheses, see Read, p. 131, ex. 9-14.
  attribute enclose { data.ENCLOSURE }?
att.event.attributes =
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes,
  att.staffident.attributes,
  att.layerident.attributes
att.fermatapresent.attributes = att.fermatapresent.attribute.fermata
att.fermatapresent.attribute.fermata =
  
  ## indicates the
  ##           attachment of a fermata to this element. If visual information about the fermata needs to
  ##           be recorded, then a <fermata> element should be employed instead.
  attribute fermata { data.STAFFREL }?
att.staffgroupingsym.attributes = att.staffgroupingsym.attribute.symbol
att.staffgroupingsym.attribute.symbol =
  
  ## specifies the
  ##           symbol used to group a set of staves.
  attribute symbol {
    
    ## curved
    ##             symbol, i.e., {
    "brace"
    | 
      ## square
      ##             symbol, i.e., [
      "bracket"
    | 
      ## line
      ##             symbol, i.e., |
      "line"
    | 
      ## grouping
      ##             symbol missing
      "none"
  }?
att.handident.attributes = att.handident.attribute.hand
att.handident.attribute.hand =
  
  ## signifies the
  ##           hand responsible for an action. The value must be the ID of a <hand> element
  ##           declared in the header.
  attribute hand { data.URI }?
att.horizontalalign.attributes = att.horizontalalign.attribute.halign
att.horizontalalign.attribute.halign =
  
  ## records
  ##           horizontal alignment.
  attribute halign {
    
    ## left
    ##             aligned
    "left"
    | 
      ## right
      ##             aligned
      "right"
    | 
      ## centered
      "center"
    | 
      ## left and
      ##             right aligned
      "justify"
  }?
att.instrumentident.attributes = att.instrumentident.attribute.instr
att.instrumentident.attribute.instr =
  
  ## provides a
  ##           way of pointing to a MIDI instrument definition. It must contain the ID of an
  ##           <instrDef> element elsewhere in the document.
  attribute instr { data.URI }?
att.internetmedia.attributes = att.internetmedia.attribute.mimetype
att.internetmedia.attribute.mimetype =
  
  ## specifies the
  ##           applicable MIME (multimedia internet mail extension) type. The value should be a valid
  ##           MIME media type defined by the Internet Engineering Task Force in RFC
  ##           2046.
  attribute mimetype { text }?
att.joined.attributes = att.joined.attribute.join
att.joined.attribute.join =
  
  ## used for
  ##           linking visually separate entities that form a single logical entity, for example,
  ##           multiple slurs broken across a system break that form a single musical phrase. Also used
  ##           to indicate a measure which metrically completes the current one. Record the identifiers
  ##           of the separately encoded components, excluding the one carrying the
  ##           attribute.
  attribute join {
    list { data.URI+ }
  }?
att.keySigs.log.attributes =
  att.keySigs.log.attribute.key.accid,
  att.keySigs.log.attribute.key.mode,
  att.keySigs.log.attribute.key.pname,
  att.keySigs.log.attribute.key.sig,
  att.keySigs.log.attribute.key.sig.mixed
att.keySigs.log.attribute.key.accid =
  
  ## contains an
  ##           accidental for the tonic key, if one is required, e.g., if key.pname equals 'c' and
  ##           key.accid equals 's', then a tonic of C# is indicated.
  attribute key.accid { data.ACCIDENTAL.IMPLICIT }?
att.keySigs.log.attribute.key.mode =
  
  ## indicates
  ##           major, minor, or other tonality.
  attribute key.mode { data.MODE }?
att.keySigs.log.attribute.key.pname =
  
  ## holds the
  ##           pitch name of the tonic key, e.g. 'c' for the key of C.
  attribute key.pname { data.PITCHNAME }?
att.keySigs.log.attribute.key.sig =
  
  ## indicates
  ##           where the key lies in the circle of fifths.
  attribute key.sig { data.KEYSIGNATURE }?
att.keySigs.log.attribute.key.sig.mixed =
  
  ## Mixed key
  ##           signatures, e.g. those consisting of a mixture of flats and sharps (Read, p. 143, ex.
  ##           9-39), and key signatures with unorthodox placement of the accidentals (Read, p. 141) must
  ##           be indicated by setting the key.sig attribute to 'mixed' and providing explicit key
  ##           signature information in the key.sig.mixed attribute or in the <keySig> element. It
  ##           is intended that key.sig.mixed contain a series of tokens with each token containing pitch
  ##           name, accidental, and octave, such as 'A4 Cs5 Ef5' that indicate what key accidentals
  ##           should be rendered and where they should be placed.
  attribute key.sig.mixed {
    list {
      xsd:token {
        pattern = "[a-g][0-9](\-{1,3}|f{1,3}|#{1,3}|s{1,3}|x)"
      }+
    }
  }?
att.keySigs.vis.attributes =
  att.keySigs.vis.attribute.key.sig.show,
  att.keySigs.vis.attribute.key.sig.showchange
att.keySigs.vis.attribute.key.sig.show =
  
  ## indicates
  ##           whether the key signature should be displayed.
  attribute key.sig.show { data.BOOLEAN }?
att.keySigs.vis.attribute.key.sig.showchange =
  
  ## determines
  ##           whether cautionary accidentals should be displayed at a key change.
  attribute key.sig.showchange { data.BOOLEAN }?
att.labels.addl.attributes = att.labels.addl.attribute.label.abbr
att.labels.addl.attribute.label.abbr =
  
  ## provides a
  ##           label for a group of staves on pages after the first page. Usually, this label takes an
  ##           abbreviated form.
  attribute label.abbr { text }?
att.lang.attributes = att.lang.attribute.lang
att.lang.attribute.lang =
  
  ## identifies
  ##           the language of the element's content. The values for this attribute are language 'tags'
  ##           as defined in BCP 47. All language tags that make use of private use sub-tags must be
  ##           documented in a corresponding language element in the MEI header whose id attribute is the
  ##           same as the language tag's value.
  attribute xml:lang { xsd:language }?
att.layerident.attributes = att.layerident.attribute.layer
att.layerident.attribute.layer =
  
  ## identifies
  ##           the layer to which a feature applies.
  attribute layer { xsd:positiveInteger }?
att.lineloc.attributes = att.lineloc.attribute.line
att.lineloc.attribute.line =
  
  ## indicates the
  ##           line upon which a feature stands. The value must be in the range between 1 and the number
  ##           of lines on the staff. The numbering of lines starts with the lowest line of the
  ##           staff.
  attribute line { data.CLEFLINE }?
att.linerend.attributes = att.linerend.attribute.rend
att.linerend.attribute.rend =
  
  ## records the
  ##           appearance of a line.
  attribute rend { data.LINERENDITION }?
att.pointing.attributes =
  att.pointing.attribute.actuate,
  att.pointing.attribute.role,
  att.pointing.attribute.show,
  att.pointing.attribute.target,
  att.pointing.attribute.targettype,
  att.pointing.attribute.title
att.pointing.attribute.actuate =
  
  ## defines
  ##           whether a link occurs automatically or must be requested by the user. It is used in
  ##           conjunction with the show attribute to determine link behavior.
  attribute xlink:actuate {
    
    ## load the
    ##             target resource immediately
    "onLoad"
    | 
      ## load the
      ##             target resource upon user request
      "onRequest"
    | 
      ## do not
      ##             permit loading of the target resource
      "none"
    | 
      ## behavior
      ##             other than allowed by the other values of this attribute
      "other"
  }?
att.pointing.attribute.role =
  
  ## indicates a
  ##           property of the entire link. The value of the role attribute must be a URI reference as
  ##           defined in [IETF RFC 2396], except that if the URI scheme used is allowed to have absolute
  ##           and relative forms, the URI portion must be absolute. The URI reference identifies some
  ##           resource that describes the intended property. When no value is supplied, no particular
  ##           role value is to be inferred.
  attribute xlink:role { data.URI }?
att.pointing.attribute.show =
  
  ## defines how a
  ##           remote resource is rendered.
  attribute xlink:show {
    
    ## open in a
    ##             new window
    "new"
    | 
      ## load the
      ##             referenced resource in the same window
      "replace"
    | 
      ## embed the
      ##             referenced resource at the point of the link
      "embed"
    | 
      ## do not
      ##             permit traversal to the referenced resource
      "none"
    | 
      ## behavior
      ##             other than permitted by the other values of this attribute
      "other"
  }?
att.pointing.attribute.target =
  
  ## allows the
  ##           use of one or more previously-undeclared URIs to identify an external electronic
  ##           object.
  attribute target { data.URIS }?
att.pointing.attribute.targettype =
  
  ## in contrast
  ##           with the role attribute, allows the target resource to be characterized using any
  ##           convenient classification scheme or typology.
  attribute targettype { xsd:NMTOKEN }?
att.pointing.attribute.title =
  
  ## contains a
  ##           human-readable description of the entire link. A value is optional; if a value is
  ##           supplied, it should contain a string that describes the resource. The use of this
  ##           information is highly dependent on the type of processing being done. It may be used, for
  ##           example, to make titles available to applications used by visually impaired users, or to
  ##           create a table of links, or to present help text that appears when a user lets a mouse
  ##           pointer hover over a starting resource.
  attribute xlink:title { text }?
att.lyricstyle.attributes =
  att.lyricstyle.attribute.lyric.align,
  att.lyricstyle.attribute.lyric.fam,
  att.lyricstyle.attribute.lyric.name,
  att.lyricstyle.attribute.lyric.size,
  att.lyricstyle.attribute.lyric.style,
  att.lyricstyle.attribute.lyric.weight
att.lyricstyle.attribute.lyric.align =
  
  ## describes the
  ##           alignment of lyric syllables associated with a note or chord.
  attribute lyric.align { xsd:decimal }?
att.lyricstyle.attribute.lyric.fam =
  
  ## sets the font
  ##           family default value for lyrics.
  attribute lyric.fam { data.FONTFAMILY }?
att.lyricstyle.attribute.lyric.name =
  
  ## sets the font
  ##           name default value for lyrics.
  attribute lyric.name { data.FONTNAME }?
att.lyricstyle.attribute.lyric.size =
  
  ## sets the
  ##           default font size value for lyrics.
  attribute lyric.size { xsd:decimal }?
att.lyricstyle.attribute.lyric.style =
  
  ## sets the
  ##           default font style value for lyrics.
  attribute lyric.style { data.FONTSTYLE }?
att.lyricstyle.attribute.lyric.weight =
  
  ## sets the
  ##           default font weight value for lyrics.
  attribute lyric.weight { data.FONTWEIGHT }?
att.measurement.attributes = att.measurement.attribute.unit
att.measurement.attribute.unit =
  
  ## indicates the
  ##           units used for a measurement, usually using the standard symbol for the desired
  ##           unit.
  attribute unit { xsd:NMTOKEN }?
att.width.attributes = att.width.attribute.width
att.width.attribute.width =
  
  ## measurement
  ##           of the horizontal dimension of an entity. This value can only be interpreted meaningfully
  ##           in combination with the units attribute. The width attribute may be used to capture
  ##           measure width data for interchange with music printing systems that utilize this
  ##           information for printing. On <barLine> the width attribute captures the width of the
  ##           preceding measure.
  attribute width { xsd:decimal }?
att.medium.attributes = att.medium.attribute.medium
att.medium.attribute.medium =
  
  ## describes the
  ##           writing medium.
  attribute medium { text }?
att.meiversion.attributes = att.meiversion.attribute.meiversion
att.meiversion.attribute.meiversion =
  
  ## records the version of MEI used by the file.
  [ a:defaultValue = "2012" ]
  attribute meiversion {
    
    ## this version of the schema
    "2012"
  }?
att.meterconformance.attributes = att.meterconformance.attribute.metcon
att.meterconformance.attribute.metcon =
  
  ## indicates the
  ##           relationship between the content of a staff or layer and the prevailing
  ##           meter
  attribute metcon {
    
    ## conformant
    ##             with the prevailing meter
    "c"
    | 
      ## incomplete;
      ##             i.e., not enough beats
      "i"
    | 
      ## overfull;
      ##             i.e., too many beats
      "o"
  }?
att.meterconformance.bar.attributes =
  att.meterconformance.bar.attribute.metcon,
  att.meterconformance.bar.attribute.control
att.meterconformance.bar.attribute.metcon =
  
  ## indicates the
  ##           relationship between the content of a measure and the prevailing meter
  attribute metcon { data.BOOLEAN }?
att.meterconformance.bar.attribute.control =
  
  ## indicates
  ##           whether or not a bar line is "controlling"; that is, if it indicates a point of alignment
  ##           across all the parts. Bar lines within a score are usually controlling; that is, they
  ##           "line up". Bar lines within parts may or may not be controlling. When applied to
  ##           <measure>, this attribute indicates the nature of the right barline but not the
  ##           left.
  attribute control { data.BOOLEAN }?
att.meters.log.attributes =
  att.meters.log.attribute.meter.count,
  att.meters.log.attribute.meter.unit
att.meters.log.attribute.meter.count =
  
  ## captures the
  ##           number of beats in a measure, that is, the top number of the meter
  ##           signature.
  attribute meter.count { xsd:decimal }?
att.meters.log.attribute.meter.unit =
  
  ## contains the
  ##           number indicating the beat unit, that is, the bottom number of the meter
  ##           signature.
  attribute meter.unit { xsd:decimal }?
att.meters.vis.attributes =
  att.meters.vis.attribute.meter.rend,
  att.meters.vis.attribute.meter.showchange,
  att.meters.vis.attribute.meter.sym
att.meters.vis.attribute.meter.rend =
  
  ## contains an
  ##           indication of how the meter signature should be rendered.
  attribute meter.rend {
    
    ## the lower
    ##             number in the meter signature is replaced by a note symbol
    "denomsym"
    | 
      ## meter
      ##             signature rendered using traditional numeric values
      "norm"
    | 
      ## meter
      ##             signature not rendered
      "invis"
  }?
att.meters.vis.attribute.meter.showchange =
  
  ## determines
  ##           whether a new meter signature should be displayed when the meter signature
  ##           changes.
  attribute meter.showchange { data.BOOLEAN }?
att.meters.vis.attribute.meter.sym =
  
  ## indicates the
  ##           use of a meter symbol instead of a numeric meter signature, that is, 'C' for common time
  ##           or 'C' with a slash for cut time.
  attribute meter.sym { data.METERSIGN }?
att.mmtempo.attributes = att.mmtempo.attribute.mm
att.mmtempo.attribute.mm =
  
  ## used to
  ##           describe tempo in terms of beats (meter signature denominator) per minute, ala M.M.
  ##           (Maezel's Metronome).
  attribute mm { data.TEMPOVALUE }?
att.multinummeasures.attributes =
  att.multinummeasures.attribute.multi.number
att.multinummeasures.attribute.multi.number =
  
  ## indicates
  ##           whether programmatically calculated counts of multiple measures of rest (mRest) and whole
  ##           measure repeats (mRpt) in parts should be rendered.
  attribute multi.number { data.BOOLEAN }?
att.name.attributes =
  att.authorized.attributes,
  att.canonical.attributes,
  att.name.attribute.nymref,
  att.name.attribute.role
att.name.attribute.nymref =
  
  ## used to
  ##           record a pointer to the regularized form of the name elsewhere in the
  ##           document.
  attribute nymref { data.URI }?
att.name.attribute.role =
  
  ## used to
  ##           specify further information about the entity referenced by this name, for example, the
  ##           occupation of a person or the status of a place.
  attribute role { text }?
att.octave.attributes = att.octave.attribute.oct
att.octave.attribute.oct =
  
  ## captures
  ##           written octave information.
  attribute oct { data.OCTAVE }?
att.octavedefault.attributes =
  att.octavedefault.attribute.octave.default
att.octavedefault.attribute.octave.default =
  
  ## contains a
  ##           default octave specification for use when the first note, rest, chord, etc. in a measure
  ##           does not have an octave value specified.
  attribute octave.default { data.OCTAVE }?
att.onelinestaff.attributes = att.onelinestaff.attribute.ontheline
att.onelinestaff.attribute.ontheline =
  
  ## determines
  ##           the placement of notes on a 1-line staff. A value of 'true' places all notes on the line,
  ##           while a value of 'false' places stems-up notes above the line and stems-down notes below
  ##           the line.
  attribute ontheline { data.BOOLEAN }?
att.octavedisplacement.attributes =
  att.octavedisplacement.attribute.dis,
  att.octavedisplacement.attribute.dis.place
att.octavedisplacement.attribute.dis =
  
  ## records the
  ##           amount of octave displacement.
  attribute dis { data.OCTAVE.DIS }?
att.octavedisplacement.attribute.dis.place =
  
  ## records the
  ##           direction of octave displacement.
  attribute dis.place { data.PLACE }?
att.plist.attributes =
  att.plist.attribute.plist, att.plist.attribute.evaluate
att.plist.attribute.plist =
  
  ## contains a
  ##           space separated list of references that identify logical events that participate in a
  ##           collection, such as notes under a phrase mark.
  attribute plist { data.URIS }?
att.plist.attribute.evaluate =
  
  ## specifies the
  ##           intended meaning when the target of a pointer is itself a pointer.
  attribute evaluate {
    
    ## if the
    ##             element pointed to is itself a pointer, then the target of that pointer will be taken,
    ##             and so on, until an element is found which is not a pointer.
    "all"
    | 
      ## if the
      ##             element pointed to is itself a pointer, then its target (whether a pointer or not) is
      ##             taken as the target of this pointer.
      "one"
    | 
      ## no further
      ##             evaluation of targets is carried out beyond that needed to find the element specified in
      ##             the pointer's target.
      "none"
  }?
att.pitch.attributes = att.pitch.attribute.pname
att.pitch.attribute.pname =
  
  ## contains a
  ##           written pitch name.
  attribute pname { data.PITCHNAME }?
att.pitched.attributes = att.pitch.attributes, att.octave.attributes
att.placement.attributes = att.placement.attribute.place
att.placement.attribute.place =
  
  ## captures the
  ##           placement of the item with respect to the staff with which it is
  ##           associated.
  attribute place { data.STAFFREL }?
att.relativesize.attributes = att.relativesize.attribute.size
att.relativesize.attribute.size =
  
  ## describes the
  ##           relative size of a feature.
  attribute size { data.SIZE }?
att.responsibility.attributes = att.responsibility.attribute.resp
att.responsibility.attribute.resp =
  
  ## captures
  ##           information regarding responsibility for some aspect of the text's creation,
  ##           transcription, editing, or encoding. Its value must point to one or more identifiers
  ##           declared in the document header.
  attribute resp {
    list { data.URI+ }
  }?
att.scalable.attributes = att.scalable.attribute.scale
att.scalable.attribute.scale =
  
  ## scale factor
  ##           to be applied to the feature to make it the desired display size.
  attribute scale { data.PERCENT }?
att.sequence.attributes = att.sequence.attribute.seq
att.sequence.attribute.seq =
  
  ## used to
  ##           assign a sequence number related to the order in which the encoded features carrying this
  ##           attribute are believed to have occurred.
  attribute seq { xsd:positiveInteger }?
att.slashcount.attributes = att.slashcount.attribute.slash
att.slashcount.attribute.slash =
  
  ## indicates the
  ##           number of slashes to be rendered along with the feature.
  attribute slash { data.SLASH }?
att.slurpresent.attributes = att.slurpresent.attribute.slur
att.slurpresent.attribute.slur =
  
  ## indicates
  ##           that this element participates in a slur. If visual information about the slur needs to be
  ##           recorded, then a <slur> element should be employed.
  attribute slur { data.SLURS }?
att.staffident.attributes = att.staffident.attribute.staff
att.staffident.attribute.staff =
  
  ## signifies the
  ##           staff on which a notated event occurs or to which a control event applies. Mandatory when
  ##           applicable.
  attribute staff {
    list { xsd:positiveInteger+ }
  }?
att.staffloc.attributes = att.staffloc.attribute.loc
att.staffloc.attribute.loc =
  
  ## holds the
  ##           staff location of the feature.
  attribute loc { data.STAFFLOC }?
att.startid.attributes = att.startid.attribute.startid
att.startid.attribute.startid =
  
  ## holds a
  ##           reference to the first element in a sequence of events to which the feature
  ##           applies.
  attribute startid { data.URI }?
att.startendid.attributes =
  att.startid.attributes, att.startendid.attribute.endid
att.startendid.attribute.endid =
  
  ## indicates the
  ##           final element in a sequence of events to which the feature applies.
  attribute endid { data.URI }?
att.stemmed.attributes =
  att.stemmed.cmn.attributes,
  att.stemmed.attribute.stem.dir,
  att.stemmed.attribute.stem.len,
  att.stemmed.attribute.stem.pos,
  att.stemmed.attribute.stem.x,
  att.stemmed.attribute.stem.y
att.stemmed.attribute.stem.dir =
  
  ## describes the
  ##           direction of a stem.
  attribute stem.dir { data.STEMDIRECTION }?
att.stemmed.attribute.stem.len =
  
  ## encodes the
  ##           stem length.
  attribute stem.len { xsd:decimal }?
att.stemmed.attribute.stem.pos =
  
  ## records the
  ##           position of the stem in relation to the note head(s).
  attribute stem.pos { data.STEMPOSITION }?
att.stemmed.attribute.stem.x =
  
  ## records the
  ##           output x coordinate of the stem's attachment point.
  attribute stem.x { xsd:decimal }?
att.stemmed.attribute.stem.y =
  
  ## records the
  ##           output y coordinate of the stem's attachment point.
  attribute stem.y { xsd:decimal }?
att.syltext.attributes = att.syltext.attribute.syl
att.syltext.attribute.syl =
  
  ## holds an
  ##           associated sung text syllable.
  attribute syl { text }?
att.textstyle.attributes =
  att.textstyle.attribute.text.fam,
  att.textstyle.attribute.text.name,
  att.textstyle.attribute.text.size,
  att.textstyle.attribute.text.style,
  att.textstyle.attribute.text.weight
att.textstyle.attribute.text.fam =
  
  ## provides a
  ##           default value for the font family name of text (other than lyrics) when this information
  ##           is not provided on the individual elements.
  attribute text.fam { data.FONTFAMILY }?
att.textstyle.attribute.text.name =
  
  ## provides a
  ##           default value for the font name of text (other than lyrics) when this information is not
  ##           provided on the individual elements.
  attribute text.name { data.FONTNAME }?
att.textstyle.attribute.text.size =
  
  ## provides a
  ##           default value for the font size of text (other than lyrics) when this information is not
  ##           provided on the individual elements.
  attribute text.size { xsd:decimal }?
att.textstyle.attribute.text.style =
  
  ## provides a
  ##           default value for the font style of text (other than lyrics) when this information is not
  ##           provided on the individual elements.
  attribute text.style { data.FONTSTYLE }?
att.textstyle.attribute.text.weight =
  
  ## provides a
  ##           default value for the font weight for text (other than lyrics) when this information is
  ##           not provided on the individual elements.
  attribute text.weight { data.FONTWEIGHT }?
att.tiepresent.attributes = att.tiepresent.attribute.tie
att.tiepresent.attribute.tie =
  
  ## indicates
  ##           that this element participates in a tie. If visual information about the tie needs to be
  ##           recorded, then a <tie> element should be employed.
  attribute tie { data.TIES }?
att.timestamp.musical.attributes =
  att.timestamp.musical.attribute.tstamp
att.timestamp.musical.attribute.tstamp =
  
  ## encodes the
  ##           onset time in terms of musical time, i.e., beats[.fractional_beat_part]
  attribute tstamp { data.BEAT }?
att.timestamp.performed.attributes =
  att.timestamp.performed.attribute.tstamp.ges,
  att.timestamp.performed.attribute.tstamp.real
att.timestamp.performed.attribute.tstamp.ges =
  
  ## used to
  ##           record the onset time in pulses per quarter note (ppq, MusicXML divisions, or MIDI clicks)
  ##           since the start of the file.
  attribute tstamp.ges { xsd:nonNegativeInteger }?
att.timestamp.performed.attribute.tstamp.real =
  
  ## used to
  ##           record the onset time in terms of ISO time since the start of the file.
  attribute tstamp.real { data.ISOTIME }?
att.transposition.attributes =
  att.transposition.attribute.trans.diat,
  att.transposition.attribute.trans.semi
att.transposition.attribute.trans.diat =
  
  ## records the
  ##           amount of diatonic pitch shift, e.g. C to C♯ = 0, C to D♭ = 1. Transposition requires both
  ##           trans.diat and trans.semi attributes in order to distinguish the difference, for example,
  ##           between a transposition from C to C♯ and one from C to D♭.
  attribute trans.diat { xsd:decimal }?
att.transposition.attribute.trans.semi =
  
  ## contains the
  ##           amount of pitch shift in semitones, C to C♯ = 1, C to D♭ = 1. Transposition requires both
  ##           trans.diat and trans.semi attributes in order to distinguish the difference, for example,
  ##           between a transposition from C to C♯ and one from C to D♭. 
  attribute trans.semi { xsd:decimal }?
att.tupletpresent.attributes = att.tupletpresent.attribute.tuplet
att.tupletpresent.attribute.tuplet =
  
  ## indicates
  ##           that this feature participates in a tuplet. If visual information about the tuplet needs
  ##           to be recorded, then a <tuplet> element should be employed.
  attribute tuplet { data.TUPLETS }?
att.typed.attributes =
  att.typed.attribute.type, att.typed.attribute.subtype
att.typed.attribute.type =
  
  ## characterizes
  ##           the element in some sense, using any convenient classification scheme or
  ##           typology.
  attribute type { xsd:NMTOKEN }?
att.typed.attribute.subtype =
  
  ## provide any
  ##           sub-classification for the element, additional to that given by its type
  ##           attribute.
  attribute subtype { xsd:NMTOKEN }?
att.typography.attributes =
  att.typography.attribute.fontfam,
  att.typography.attribute.fontname,
  att.typography.attribute.fontsize,
  att.typography.attribute.fontstyle,
  att.typography.attribute.fontweight
att.typography.attribute.fontfam =
  
  ## contains the
  ##           name of a font-family.
  attribute fontfam { data.FONTFAMILY }?
att.typography.attribute.fontname =
  
  ## holds the
  ##           name of a font.
  attribute fontname { data.FONTNAME }?
att.typography.attribute.fontsize =
  
  ## indicates the
  ##           size of a font in printers' points, i.e., 1/72nd of an inch.
  attribute fontsize { xsd:decimal }?
att.typography.attribute.fontstyle =
  
  ## records the
  ##           style of a font, i.e, italic, oblique, or normal.
  attribute fontstyle { data.FONTSTYLE }?
att.typography.attribute.fontweight =
  
  ## used to
  ##           indicate bold type.
  attribute fontweight { data.FONTWEIGHT }?
att.visibility.attributes = att.visibility.attribute.visible
att.visibility.attribute.visible =
  
  ## indicates if
  ##           a feature should be rendered when the notation is presented graphically or sounded when it
  ##           is presented in an aural form.
  attribute visible { data.BOOLEAN }?
att.visualoffset.ho.attributes = att.visualoffset.ho.attribute.ho
att.visualoffset.ho.attribute.ho =
  
  ## records a
  ##           horizontal adjustment to a feature's programmatically-determined location in terms of
  ##           staff interline distance; that is, in units of 1/2 the distance between adjacent staff
  ##           lines.
  attribute ho { data.INTERLINE }?
att.visualoffset.to.attributes = att.visualoffset.to.attribute.to
att.visualoffset.to.attribute.to =
  
  ## records a
  ##           timestamp adjustment of a feature's programmatically-determined location in terms of
  ##           musical time; that is, beats.
  attribute to { data.TSTAMPOFFSET }?
att.visualoffset.vo.attributes = att.visualoffset.vo.attribute.vo
att.visualoffset.vo.attribute.vo =
  
  ## records the
  ##           vertical adjustment of a feature's programmatically-determined location in terms of staff
  ##           interline distance; that is, in units of 1/2 the distance between adjacent staff
  ##           lines.
  attribute vo { data.INTERLINE }?
att.visualoffset.attributes =
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.visualoffset.vo.attributes
att.visualoffset2.ho.attributes =
  att.visualoffset2.ho.attribute.startho,
  att.visualoffset2.ho.attribute.endho
att.visualoffset2.ho.attribute.startho =
  
  ## records the
  ##           horizontal adjustment of a feature's programmatically-determined start
  ##           point.
  attribute startho { data.INTERLINE }?
att.visualoffset2.ho.attribute.endho =
  
  ## records the
  ##           horizontal adjustment of a feature's programmatically-determined end
  ##           point.
  attribute endho { data.INTERLINE }?
att.visualoffset2.to.attributes =
  att.visualoffset2.to.attribute.startto,
  att.visualoffset2.to.attribute.endto
att.visualoffset2.to.attribute.startto =
  
  ## records a
  ##           timestamp adjustment of a feature's programmatically-determined start
  ##           point.
  attribute startto { data.TSTAMPOFFSET }?
att.visualoffset2.to.attribute.endto =
  
  ## records a
  ##           timestamp adjustment of a feature's programmatically-determined end
  ##           point.
  attribute endto { data.TSTAMPOFFSET }?
att.visualoffset2.vo.attributes =
  att.visualoffset2.vo.attribute.startvo,
  att.visualoffset2.vo.attribute.endvo
att.visualoffset2.vo.attribute.startvo =
  
  ## records a
  ##           vertical adjustment of a feature's programmatically-determined start
  ##           point.
  attribute startvo { data.INTERLINE }?
att.visualoffset2.vo.attribute.endvo =
  
  ## records a
  ##           vertical adjustment of a feature's programmatically-determined end
  ##           point.
  attribute endvo { data.INTERLINE }?
att.visualoffset2.attributes =
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.visualoffset2.vo.attributes
att.xy.attributes = att.xy.attribute.x, att.xy.attribute.y
att.xy.attribute.x =
  
  ## encodes an x
  ##           coordinate for a feature in an output coordinate system. When it is necessary to record
  ##           the placement of a feature in a facsimile image, use the facs attribute.
  attribute x { xsd:decimal }?
att.xy.attribute.y =
  
  ## encodes an y
  ##           coordinate for a feature in an output coordinate system. When it is necessary to record
  ##           the placement of a feature in a facsimile image, use the facs attribute.
  attribute y { xsd:decimal }?
att.xy2.attributes = att.xy2.attribute.x2, att.xy2.attribute.y2
att.xy2.attribute.x2 =
  
  ## encodes the
  ##           optional 2nd x coordinate.
  attribute x2 { xsd:decimal }?
att.xy2.attribute.y2 =
  
  ## encodes the
  ##           optional 2nd y coordinate.
  attribute y2 { xsd:decimal }?
att.accid.anl.attributes = att.common.anl.attributes
att.accid.ges.attributes = empty
att.accid.log.attributes =
  att.accidental.attributes,
  att.controlevent.attributes,
  att.staffloc.attributes,
  att.accid.log.attribute.func
att.accid.log.attribute.func =
  
  ## records the
  ##           function of an accidental.
  attribute func {
    
    ## cautionary
    ##             accidental
    "caution"
    | 
      ## editorial
      ##             accidental
      "edit"
  }?
att.accid.vis.attributes =
  att.color.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes,
  att.enclosingchars.attributes,
  att.accid.vis.attribute.place
att.accid.vis.attribute.place =
  
  ## captures the
  ##           placement of the accidental relative to the staff.
  attribute place {
    
    ## above the
    ##             staff, e.g., musica ficta
    "above"
    | 
      ## below the
      ##             staff, e.g., musica ficta
      "below"
    | 
      ## on the
      ##             staff, i.e., traditional placement
      "staff"
  }?
att.annot.anl.attributes = att.common.anl.attributes
att.annot.ges.attributes = att.duration.performed.attributes
att.annot.log.attributes =
  att.startendid.attributes,
  att.duration.timestamp.attributes,
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes,
  att.staffident.attributes,
  att.layerident.attributes
att.annot.vis.attributes = empty
att.artic.anl.attributes = att.common.anl.attributes
att.artic.ges.attributes = empty
att.artic.log.attributes =
  att.articulation.attributes,
  att.controlevent.attributes,
  att.staffloc.attributes
att.artic.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.enclosingchars.attributes
att.barLine.anl.attributes = att.common.anl.attributes
att.barLine.ges.attributes = att.timestamp.musical.attributes
att.barLine.log.attributes =
  att.meterconformance.bar.attributes, att.barLine.log.attribute.rend
att.barLine.log.attribute.rend =
  
  ## records the
  ##           appearance and usually the function of the bar line.
  attribute rend { data.BARRENDITION }?
att.barLine.vis.attributes =
  att.barplacement.attributes,
  att.color.attributes,
  att.measurement.attributes,
  att.width.attributes
att.chord.anl.attributes =
  att.common.anl.attributes, att.melodicfunction.attributes
att.chord.ges.attributes =
  att.articulation.performed.attributes,
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.chord.ges.cmn.attributes
att.chord.log.attributes =
  att.event.attributes,
  att.articulation.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.syltext.attributes,
  att.slurpresent.attributes,
  att.tiepresent.attributes,
  att.tupletpresent.attributes,
  att.chord.log.cmn.attributes
att.chord.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.relativesize.attributes,
  att.stemmed.attributes,
  att.visibility.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.xy.attributes,
  att.chord.vis.cmn.attributes,
  att.chord.vis.attribute.cluster
att.chord.vis.attribute.cluster =
  
  ## indicates a
  ##           single alternative note head should be displayed instead of individual note heads. See
  ##           Read, p. 320-321, re: tone clusters.
  attribute cluster { data.CLUSTER }?
att.clef.anl.attributes = att.common.anl.attributes
att.clef.ges.attributes = empty
att.clef.log.attributes =
  att.clefshape.attributes,
  att.lineloc.attributes,
  att.octave.attributes,
  att.octavedisplacement.attributes,
  att.clef.log.attribute.cautionary
att.clef.log.attribute.cautionary =
  
  ## records the
  ##           function of the clef. A "cautionary" clef does not change the following
  ##           pitches.
  attribute cautionary { data.BOOLEAN }?
att.clef.vis.attributes = att.altsym.attributes, att.color.attributes
att.clefGrp.anl.attributes = att.common.anl.attributes
att.clefGrp.ges.attributes = empty
att.clefGrp.log.attributes = empty
att.clefGrp.vis.attributes = empty
att.custos.anl.attributes = att.common.anl.attributes
att.custos.ges.attributes = empty
att.custos.log.attributes =
  att.pitched.attributes, att.custos.log.attribute.target
att.custos.log.attribute.target =
  
  ## encodes the
  ##           target note when its pitch differs from the pitch at which the custos
  ##           appears.
  attribute target { data.URI }?
att.custos.vis.attributes = att.altsym.attributes, att.color.attributes
att.dir.anl.attributes = att.common.anl.attributes
att.dir.ges.attributes = att.duration.performed.attributes
att.dir.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes
att.dir.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.dot.anl.attributes = att.common.anl.attributes
att.dot.ges.attributes = empty
att.dot.log.attributes =
  att.controlevent.attributes,
  att.staffloc.attributes,
  att.dot.log.attribute.form
att.dot.log.attribute.form =
  
  ## records the
  ##           function of the dot.
  attribute form {
    
    ## augmentation dot
    "aug"
    | 
      ## dot of
      ##             division
      "div"
  }?
att.dot.vis.attributes =
  att.color.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes
att.dynam.anl.attributes = att.common.anl.attributes
att.dynam.ges.attributes =
  att.duration.performed.attributes, att.midivalue.attributes
att.dynam.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes
att.dynam.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.ending.anl.attributes = att.common.anl.attributes
att.ending.ges.attributes = empty
att.ending.log.attributes = empty
att.ending.vis.attributes = empty
att.grpSym.anl.attributes = att.common.anl.attributes
att.grpSym.ges.attributes = empty
att.grpSym.log.attributes = att.staffgroupingsym.attributes
att.grpSym.vis.attributes =
  att.visualoffset.attributes, att.xy.attributes
att.layer.anl.attributes = att.common.anl.attributes
att.layer.ges.attributes = empty
att.layer.log.attributes =
  att.meterconformance.attributes, att.layer.log.attribute.def
att.layer.log.attribute.def =
  
  ## provides a
  ##           mechanism for linking the layer to a layerDef element.
  attribute def { data.URI }?
att.layer.vis.attributes = att.visibility.attributes
att.layerDef.anl.attributes = empty
att.layerDef.ges.attributes = att.instrumentident.attributes
att.layerDef.log.attributes =
  att.duration.default.attributes,
  att.octavedefault.attributes,
  att.layerDef.log.cmn.attributes
att.layerDef.vis.attributes =
  att.labels.addl.attributes,
  att.beaming.vis.attributes,
  att.textstyle.attributes,
  att.visibility.attributes
att.measure.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.measure.ges.attributes = att.timestamp.performed.attributes
att.measure.log.attributes =
  att.meterconformance.bar.attributes,
  att.measure.log.attribute.left,
  att.measure.log.attribute.right
att.measure.log.attribute.left =
  
  ## indicates the
  ##           visual rendition of the left bar line. It is present here only for facilitation of
  ##           translation from legacy encodings which use it. Usually, it can be safely
  ##           ignored.
  attribute left { data.BARRENDITION }?
att.measure.log.attribute.right =
  
  ## indicates the
  ##           function of the right bar line and is structurally important.
  attribute right { data.BARRENDITION }?
att.note.anl.attributes =
  att.common.anl.attributes,
  att.harmonicfunction.attributes,
  att.intervallicdesc.attributes,
  att.melodicfunction.attributes,
  att.pitchclass.attributes,
  att.solfa.attributes
att.note.ges.attributes =
  att.accidental.performed.attributes,
  att.articulation.performed.attributes,
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.note.ges.cmn.attributes,
  att.note.ges.mensural.attributes,
  att.note.ges.tablature.attributes,
  att.note.ges.attribute.oct.ges,
  att.note.ges.attribute.pname.ges,
  att.note.ges.attribute.pnum
att.note.ges.attribute.oct.ges =
  
  ## records
  ##           performed octave information that differs from the written value.
  attribute oct.ges { data.OCTAVE }?
att.note.ges.attribute.pname.ges =
  
  ## contains a
  ##           performed pitch name that differs from the written value.
  attribute pname.ges { data.PITCHNAME.GES }?
att.note.ges.attribute.pnum =
  
  ## holds a
  ##           pitch-to-number mapping, a base-40 or MIDI note number, for example.
  attribute pnum { data.PITCHNUMBER }?
att.note.log.attributes =
  att.event.attributes,
  att.accidental.attributes,
  att.articulation.attributes,
  att.augmentdots.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.pitched.attributes,
  att.syltext.attributes,
  att.slurpresent.attributes,
  att.tiepresent.attributes,
  att.tupletpresent.attributes,
  att.note.log.cmn.attributes,
  att.note.log.mensural.attributes
att.note.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.coloration.attributes,
  att.enclosingchars.attributes,
  att.relativesize.attributes,
  att.stemmed.attributes,
  att.visibility.attributes,
  att.visualoffset.ho.attributes,
  att.visualoffset.to.attributes,
  att.xy.attributes,
  att.note.vis.cmn.attributes,
  att.note.vis.attribute.headshape
att.note.vis.attribute.headshape =
  
  ## used to
  ##           override the head shape normally used for the given duration.
  attribute headshape { data.HEADSHAPE }?
att.pad.anl.attributes = empty
att.pad.ges.attributes = empty
att.pad.log.attributes = att.event.attributes, att.pad.log.attribute.num
att.pad.log.attribute.num =
  
  ## amount of
  ##         "padding" to be added, in interline units; that is, in units of 1/2 the distance between
  ##         adjacent staff lines.
  attribute num { xsd:decimal }
att.pad.vis.attributes = empty
att.part.anl.attributes = att.common.anl.attributes
att.part.ges.attributes = empty
att.part.log.attributes = empty
att.part.vis.attributes = empty
att.parts.anl.attributes = att.common.anl.attributes
att.parts.ges.attributes = empty
att.parts.log.attributes = empty
att.parts.vis.attributes = empty
att.pb.anl.attributes = att.common.anl.attributes
att.pb.ges.attributes = empty
att.pb.log.attributes = empty
att.pb.vis.attributes = att.pb.vis.attribute.func
att.pb.vis.attribute.func =
  
  ## states the
  ##           side of a leaf (as in a manuscript) on which the content following the <pb> element
  ##           occurs.
  attribute func {
    
    ##
    "verso"
    | 
      ##
      "recto"
  }?
att.phrase.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.phrase.ges.attributes = att.duration.performed.attributes
att.phrase.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes
att.phrase.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.phrase.vis.cmn.attributes
att.rest.anl.attributes = att.common.anl.attributes
att.rest.ges.attributes =
  att.duration.performed.attributes,
  att.instrumentident.attributes,
  att.rest.ges.mensural.attributes
att.rest.log.attributes =
  att.augmentdots.attributes,
  att.event.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.tupletpresent.attributes,
  att.rest.log.cmn.attributes
att.rest.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.relativesize.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.rest.vis.cmn.attributes,
  att.rest.vis.mensural.attributes
att.sb.anl.attributes = att.common.anl.attributes
att.sb.ges.attributes = empty
att.sb.log.attributes = empty
att.sb.vis.attributes = att.sb.vis.attribute.rend
att.sb.vis.attribute.rend =
  
  ## indicates
  ##           whether hash marks should be rendered between systems. See Read, p. 436, ex.
  ##           26-3.
  attribute rend {
    
    ## display
    ##             hash marks between systems
    "hash"
  }?
att.score.anl.attributes = att.common.anl.attributes
att.score.ges.attributes = empty
att.score.log.attributes = empty
att.score.vis.attributes = empty
att.scoreDef.anl.attributes = empty
att.scoreDef.ges.attributes =
  att.channelized.attributes,
  att.timebase.attributes,
  att.miditempo.attributes,
  att.mmtempo.attributes,
  att.scoreDef.ges.attribute.tune.pname,
  att.scoreDef.ges.attribute.tune.Hz,
  att.scoreDef.ges.attribute.tune.temper
att.scoreDef.ges.attribute.tune.pname =
  
  ## holds the
  ##           pitch name of a tuning reference pitch.
  attribute tune.pname { data.PITCHNAME }?
att.scoreDef.ges.attribute.tune.Hz =
  
  ## holds a value
  ##           for cycles per second, i.e., Hertz, for a tuning reference pitch.
  attribute tune.Hz { xsd:decimal }?
att.scoreDef.ges.attribute.tune.temper =
  
  ## provides an
  ##           indication of the tuning system, 'just', for example.
  attribute tune.temper { data.TEMPERAMENT }?
att.scoreDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigs.log.attributes,
  att.meters.log.attributes,
  att.octavedefault.attributes,
  att.transposition.attributes,
  att.scoreDef.log.cmn.attributes,
  att.scoreDef.log.mensural.attributes
att.scoreDef.vis.attributes =
  att.barplacement.attributes,
  att.cleffing.vis.attributes,
  att.distances.attributes,
  att.keySigs.vis.attributes,
  att.lyricstyle.attributes,
  att.meters.vis.attributes,
  att.multinummeasures.attributes,
  att.onelinestaff.attributes,
  att.textstyle.attributes,
  att.scoreDef.vis.cmn.attributes,
  att.scoreDef.vis.mensural.attributes,
  att.scoreDef.vis.attribute.ending.rend,
  att.scoreDef.vis.attribute.mnum.visible,
  att.scoreDef.vis.attribute.music.name,
  att.scoreDef.vis.attribute.music.size,
  att.scoreDef.vis.attribute.optimize,
  att.scoreDef.vis.attribute.page.height,
  att.scoreDef.vis.attribute.page.width,
  att.scoreDef.vis.attribute.page.units,
  att.scoreDef.vis.attribute.page.topmar,
  att.scoreDef.vis.attribute.page.botmar,
  att.scoreDef.vis.attribute.page.leftmar,
  att.scoreDef.vis.attribute.page.rightmar,
  att.scoreDef.vis.attribute.page.panels,
  att.scoreDef.vis.attribute.page.scale,
  att.scoreDef.vis.attribute.spacing.packexp,
  att.scoreDef.vis.attribute.spacing.packfact,
  att.scoreDef.vis.attribute.spacing.staff,
  att.scoreDef.vis.attribute.spacing.system,
  att.scoreDef.vis.attribute.system.leftmar,
  att.scoreDef.vis.attribute.system.rightmar,
  att.scoreDef.vis.attribute.system.topmar
att.scoreDef.vis.attribute.ending.rend =
  
  ## describes
  ##           where ending marks should be displayed.
  attribute ending.rend {
    
    ## ending
    ##             rendered only above top staff
    "top"
    | 
      ## ending
      ##             rendered above staves that have bar lines drawn across them
      "barred"
    | 
      ## endings
      ##             rendered above staff groups
      "grouped"
  }?
att.scoreDef.vis.attribute.mnum.visible =
  
  ## indicates
  ##           whether measure numbers should be displayed.
  attribute mnum.visible { data.BOOLEAN }?
att.scoreDef.vis.attribute.music.name =
  
  ## sets the
  ##           default music font name.
  attribute music.name { data.MUSICFONT }?
att.scoreDef.vis.attribute.music.size =
  
  ## sets the
  ##           default music font size.
  attribute music.size { xsd:decimal }?
att.scoreDef.vis.attribute.optimize =
  
  ## indicates
  ##           whether staves without notes, rests, etc. should be displayed. When the value is 'true',
  ##           empty staves are displayed.
  attribute optimize { data.BOOLEAN }?
att.scoreDef.vis.attribute.page.height =
  
  ## describes the
  ##           physical height of the rendered output page.
  attribute page.height { xsd:decimal }?
att.scoreDef.vis.attribute.page.width =
  
  ## describes the
  ##           physical width of the rendered output page.
  attribute page.width { xsd:decimal }?
att.scoreDef.vis.attribute.page.units =
  
  ## contains the
  ##           real-world measurement units (inches, centimeters, millimeters) used to describe the
  ##           rendered page height, width, and margins.
  attribute page.units { data.PGUNITS }?
att.scoreDef.vis.attribute.page.topmar =
  
  ## indicates the
  ##           amount of whitespace at the top of a rendered score page.
  attribute page.topmar { xsd:decimal }?
att.scoreDef.vis.attribute.page.botmar =
  
  ## indicates the
  ##           amount of whitespace at the bottom of a rendered score page.
  attribute page.botmar { xsd:decimal }?
att.scoreDef.vis.attribute.page.leftmar =
  
  ## indicates the
  ##           amount of whitespace at the left side of a rendered score page.
  attribute page.leftmar { xsd:decimal }?
att.scoreDef.vis.attribute.page.rightmar =
  
  ## indicates the
  ##           amount of whitespace at the right side of a rendered score page.
  attribute page.rightmar { xsd:decimal }?
att.scoreDef.vis.attribute.page.panels =
  
  ## indicates the
  ##           number of logical pages to be rendered on a single physical page.
  attribute page.panels { data.PAGE.PANELS }?
att.scoreDef.vis.attribute.page.scale =
  
  ## indicates how
  ##           the page should be scaled when rendered.
  attribute page.scale { data.PGSCALE }?
att.scoreDef.vis.attribute.spacing.packexp =
  
  ## describes a
  ##           note's spacing relative to its time value.
  attribute spacing.packexp { xsd:decimal }?
att.scoreDef.vis.attribute.spacing.packfact =
  
  ## describes the
  ##           note spacing of output.
  attribute spacing.packfact { xsd:decimal }?
att.scoreDef.vis.attribute.spacing.staff =
  
  ## sets the
  ##           minimum amount of space between staves in the same system.
  attribute spacing.staff { xsd:decimal }?
att.scoreDef.vis.attribute.spacing.system =
  
  ## contains a
  ##           space-separated pair of numbers describing the minimum and maximum amount of space between
  ##           systems.
  attribute spacing.system { text }?
att.scoreDef.vis.attribute.system.leftmar =
  
  ## describes the
  ##           amount of whitespace at the left system margin relative to page.leftmar.
  attribute system.leftmar { xsd:decimal }?
att.scoreDef.vis.attribute.system.rightmar =
  
  ## describes the
  ##           amount of whitespace at the right system margin relative to
  ##           page.rightmar.
  attribute system.rightmar { xsd:decimal }?
att.scoreDef.vis.attribute.system.topmar =
  
  ## describes the
  ##           distance from page's top edge to the first system; used for first page
  ##           only.
  attribute system.topmar { xsd:decimal }?
att.section.anl.attributes = att.common.anl.attributes
att.section.ges.attributes = empty
att.section.log.attributes = empty
att.section.vis.attributes = att.section.vis.attribute.restart
att.section.vis.attribute.restart =
  
  ## indicates
  ##           that staves begin again with this section.
  attribute restart { data.BOOLEAN }?
att.space.anl.attributes = att.common.anl.attributes
att.space.ges.attributes = att.duration.performed.attributes
att.space.log.attributes =
  att.augmentdots.attributes,
  att.event.attributes,
  att.duration.musical.attributes,
  att.fermatapresent.attributes,
  att.tupletpresent.attributes,
  att.space.log.cmn.attributes
att.space.vis.attributes = att.space.vis.attribute.compressable
att.space.vis.attribute.compressable =
  
  ## indicates
  ##           whether a space is 'compressible', i.e., if it may be removed at the discretion of
  ##           processing software.
  attribute compressable { data.BOOLEAN }?
att.staff.anl.attributes = att.common.anl.attributes
att.staff.ges.attributes = empty
att.staff.log.attributes =
  att.meterconformance.attributes, att.staff.log.attribute.def
att.staff.log.attribute.def =
  
  ## provides a
  ##           mechanism for linking the staff to a staffDef element.
  attribute def { data.URI }?
att.staff.vis.attributes = att.visibility.attributes
att.staffDef.anl.attributes = empty
att.staffDef.ges.attributes =
  att.instrumentident.attributes,
  att.timebase.attributes,
  att.staffDef.ges.tablature.attributes
att.staffDef.log.attributes =
  att.cleffing.log.attributes,
  att.duration.default.attributes,
  att.keySigs.log.attributes,
  att.meters.log.attributes,
  att.octavedefault.attributes,
  att.transposition.attributes,
  att.staffDef.log.cmn.attributes,
  att.staffDef.log.mensural.attributes
att.staffDef.vis.attributes =
  att.cleffing.vis.attributes,
  att.distances.attributes,
  att.keySigs.vis.attributes,
  att.labels.addl.attributes,
  att.lyricstyle.attributes,
  att.meters.vis.attributes,
  att.multinummeasures.attributes,
  att.onelinestaff.attributes,
  att.scalable.attributes,
  att.textstyle.attributes,
  att.visibility.attributes,
  att.staffDef.vis.cmn.attributes,
  att.staffDef.vis.mensural.attributes,
  att.staffDef.vis.attribute.grid.show,
  att.staffDef.vis.attribute.layerscheme,
  att.staffDef.vis.attribute.lines,
  att.staffDef.vis.attribute.lines.color,
  att.staffDef.vis.attribute.lines.visible,
  att.staffDef.vis.attribute.spacing
att.staffDef.vis.attribute.grid.show =
  
  ## determines
  ##           whether to display guitar chord grids.
  attribute grid.show { data.BOOLEAN }?
att.staffDef.vis.attribute.layerscheme =
  
  ## indicates the
  ##           number of layers and their stem directions.
  attribute layerscheme { data.LAYERSCHEME }?
att.staffDef.vis.attribute.lines =
  
  ## indicates the
  ##           number of staff lines.
  attribute lines { xsd:positiveInteger }?
att.staffDef.vis.attribute.lines.color =
  
  ## captures the
  ##           colors of the staff lines. The value is structured; that is, it should have the same
  ##           number of space-separated RGB values as the number of lines indicated by the lines
  ##           attribute. A line can be made invisible by assigning it the same RGB value as the
  ##           background, usually white.
  attribute lines.color { data.COLORS }?
att.staffDef.vis.attribute.lines.visible =
  
  ## records
  ##           whether all staff lines are visible.
  attribute lines.visible { data.BOOLEAN }?
att.staffDef.vis.attribute.spacing =
  
  ## records the
  ##           absolute distance (as opposed to the relative distances recorded in <scoreDef>
  ##           elements) between this staff and the preceding one in the same system. This value is
  ##           meaningless for the first staff in a system since the spacing.system attribute indicates
  ##           the spacing between systems.
  attribute spacing { xsd:decimal }?
att.staffGrp.anl.attributes = empty
att.staffGrp.ges.attributes = att.instrumentident.attributes
att.staffGrp.log.attributes = empty
att.staffGrp.vis.attributes =
  att.labels.addl.attributes,
  att.staffgroupingsym.attributes,
  att.visibility.attributes,
  att.staffGrp.vis.attribute.barthru
att.staffGrp.vis.attribute.barthru =
  
  ## indicates
  ##           whether bar lines go across the space between staves (true) or are only drawn across the
  ##           lines of each staff (false).
  attribute barthru { data.BOOLEAN }?
att.syl.anl.attributes = att.common.anl.attributes
att.syl.ges.attributes = empty
att.syl.log.attributes =
  att.syl.log.attribute.con, att.syl.log.attribute.wordpos
att.syl.log.attribute.con =
  
  ## describes the
  ##           symbols typically used to indicate breaks between syllables and their
  ##           functions.
  attribute con {
    
    ## space (word
    ##             separator)
    "s"
    | 
      ## dash
      ##             (syllable separator)
      "d"
    | 
      ## underscore
      ##             (syllable extension)
      "u"
    | 
      ## tilde
      ##             (syllable elision)
      "t"
  }?
att.syl.log.attribute.wordpos =
  
  ## records the
  ##           position of a syllable within a word.
  attribute wordpos {
    
    ## (initial)
    ##             first syllable
    "i"
    | 
      ## (medial)
      ##             neither first nor last syllable
      "m"
    | 
      ## (terminal)
      ##             last syllable
      "t"
  }?
att.syl.vis.attributes =
  att.typography.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.horizontalalign.attributes
att.tempo.anl.attributes = att.common.anl.attributes
att.tempo.ges.attributes =
  att.miditempo.attributes, att.mmtempo.attributes
att.tempo.log.attributes =
  att.controlevent.attributes, att.startid.attributes
att.tempo.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
model.addressLike = address
model.addressLike_alternation = address
model.addressLike_sequence = address
model.addressLike_sequenceOptional = address?
model.addressLike_sequenceOptionalRepeatable = address*
model.addressLike_sequenceRepeatable = address+
model.annotLike = annot
model.annotLike_alternation = annot
model.annotLike_sequence = annot
model.annotLike_sequenceOptional = annot?
model.annotLike_sequenceOptionalRepeatable = annot*
model.annotLike_sequenceRepeatable = annot+
model.biblLike = bibl
model.biblLike_alternation = bibl
model.biblLike_sequence = bibl
model.biblLike_sequenceOptional = bibl?
model.biblLike_sequenceOptionalRepeatable = bibl*
model.biblLike_sequenceRepeatable = bibl+
model.biblPart = model.editionLike
model.captionLike = caption
model.controleventLike =
  dir
  | dynam
  | phrase
  | tempo
  | model.controleventLike.cmn
  | model.controleventLike.harmony
model.controleventLike_alternation =
  dir
  | dynam
  | phrase
  | tempo
  | model.controleventLike.cmn_alternation
  | model.controleventLike.harmony_alternation
model.controleventLike_sequence =
  dir,
  dynam,
  phrase,
  tempo,
  model.controleventLike.cmn_sequence,
  model.controleventLike.harmony_sequence
model.controleventLike_sequenceOptional =
  dir?,
  dynam?,
  phrase?,
  tempo?,
  model.controleventLike.cmn_sequenceOptional?,
  model.controleventLike.harmony_sequenceOptional?
model.controleventLike_sequenceOptionalRepeatable =
  dir*,
  dynam*,
  phrase*,
  tempo*,
  model.controleventLike.cmn_sequenceOptionalRepeatable*,
  model.controleventLike.harmony_sequenceOptionalRepeatable*
model.controleventLike_sequenceRepeatable =
  dir+,
  dynam+,
  phrase+,
  tempo+,
  model.controleventLike.cmn_sequenceRepeatable+,
  model.controleventLike.harmony_sequenceRepeatable+
model.dateLike = date
model.dateLike_alternation = date
model.dateLike_sequence = date
model.dateLike_sequenceOptional = date?
model.dateLike_sequenceOptionalRepeatable = date*
model.dateLike_sequenceRepeatable = date+
model.editionLike = edition
model.editionLike_alternation = edition
model.editionLike_sequence = edition
model.editionLike_sequenceOptional = edition?
model.editionLike_sequenceOptionalRepeatable = edition*
model.editionLike_sequenceRepeatable = edition+
model.editorialLike = abbr | expan
model.editorialLike_alternation = abbr | expan
model.editorialLike_sequence = abbr, expan
model.editorialLike_sequenceOptional = abbr?, expan?
model.editorialLike_sequenceOptionalRepeatable = abbr*, expan*
model.editorialLike_sequenceRepeatable = abbr+, expan+
model.endingLike = ending
model.endingLike_alternation = ending
model.endingLike_sequence = ending
model.endingLike_sequenceOptional = ending?
model.endingLike_sequenceOptionalRepeatable = ending*
model.endingLike_sequenceRepeatable = ending+
model.eventLike =
  model.keySigLike
  | barLine
  | chord
  | clef
  | clefGrp
  | custos
  | note
  | pad
  | rest
  | space
  | model.eventLike.cmn
  | model.eventLike.mensural
model.eventLike_alternation =
  model.keySigLike_alternation
  | barLine
  | chord
  | clef
  | clefGrp
  | custos
  | note
  | pad
  | rest
  | space
  | model.eventLike.cmn_alternation
  | model.eventLike.mensural_alternation
model.eventLike_sequence =
  model.keySigLike_sequence,
  barLine,
  chord,
  clef,
  clefGrp,
  custos,
  note,
  pad,
  rest,
  space,
  model.eventLike.cmn_sequence,
  model.eventLike.mensural_sequence
model.eventLike_sequenceOptional =
  model.keySigLike_sequenceOptional?,
  barLine?,
  chord?,
  clef?,
  clefGrp?,
  custos?,
  note?,
  pad?,
  rest?,
  space?,
  model.eventLike.cmn_sequenceOptional?,
  model.eventLike.mensural_sequenceOptional?
model.eventLike_sequenceOptionalRepeatable =
  model.keySigLike_sequenceOptionalRepeatable*,
  barLine*,
  chord*,
  clef*,
  clefGrp*,
  custos*,
  note*,
  pad*,
  rest*,
  space*,
  model.eventLike.cmn_sequenceOptionalRepeatable*,
  model.eventLike.mensural_sequenceOptionalRepeatable*
model.eventLike_sequenceRepeatable =
  model.keySigLike_sequenceRepeatable+,
  barLine+,
  chord+,
  clef+,
  clefGrp+,
  custos+,
  note+,
  pad+,
  rest+,
  space+,
  model.eventLike.cmn_sequenceRepeatable+,
  model.eventLike.mensural_sequenceRepeatable+
model.identifierLike = identifier
model.identifierLike_alternation = identifier
model.identifierLike_sequence = identifier
model.identifierLike_sequenceOptional = identifier?
model.identifierLike_sequenceOptionalRepeatable = identifier*
model.identifierLike_sequenceRepeatable = identifier+
model.incipLike = incip
model.instrDefLike = instrDef
model.keyAccidLike = keyAccid
model.keySigLike = keySig
model.keySigLike_alternation = keySig
model.keySigLike_sequence = keySig
model.keySigLike_sequenceOptional = keySig?
model.keySigLike_sequenceOptionalRepeatable = keySig*
model.keySigLike_sequenceRepeatable = keySig+
model.labelLike = label
model.layerDefLike = layerDef
model.layerLike = layer
model.layerLike_alternation = layer
model.layerLike_sequence = layer
model.layerLike_sequenceOptional = layer?
model.layerLike_sequenceOptionalRepeatable = layer*
model.layerLike_sequenceRepeatable = layer+
model.lbLike = lb
model.lbLike_alternation = lb
model.lbLike_sequence = lb
model.lbLike_sequenceOptional = lb?
model.lbLike_sequenceOptionalRepeatable = lb*
model.lbLike_sequenceRepeatable = lb+
model.layerPart =
  model.eventLike
  | model.layerPart.cmn
  | model.layerPart.mensural
  | model.eventLike.neumes
  | model.layerPart.neumes
  | model.midiLike
model.mdivLike = mdiv
model.metaLike.score_sequenceOptional =
  pgHead?, pgHead2?, pgFoot?, pgFoot2?
model.measurementLike = model.numLike
model.measurementLike_alternation = model.numLike_alternation
model.measurementLike_sequence = model.numLike_sequence
model.measurementLike_sequenceOptional = model.numLike_sequenceOptional?
model.measurementLike_sequenceOptionalRepeatable =
  model.numLike_sequenceOptionalRepeatable*
model.measurementLike_sequenceRepeatable =
  model.numLike_sequenceRepeatable+
model.milestoneLike.music = model.pbLike | sb
model.milestoneLike.text = model.lbLike | model.pbLike
model.milestoneLike.text_alternation =
  model.lbLike_alternation | model.pbLike_alternation
model.milestoneLike.text_sequence =
  model.lbLike_sequence, model.pbLike_sequence
model.milestoneLike.text_sequenceOptional =
  model.lbLike_sequenceOptional?, model.pbLike_sequenceOptional?
model.milestoneLike.text_sequenceOptionalRepeatable =
  model.lbLike_sequenceOptionalRepeatable*,
  model.pbLike_sequenceOptionalRepeatable*
model.milestoneLike.text_sequenceRepeatable =
  model.lbLike_sequenceRepeatable+, model.pbLike_sequenceRepeatable+
model.nameLike = name
model.nameLike_alternation = name
model.nameLike_sequence = name
model.nameLike_sequenceOptional = name?
model.nameLike_sequenceOptionalRepeatable = name*
model.nameLike_sequenceRepeatable = name+
model.noteModifierLike = accid | artic | dot
model.noteModifierLike_alternation = accid | artic | dot
model.noteModifierLike_sequence = accid, artic, dot
model.noteModifierLike_sequenceOptional = accid?, artic?, dot?
model.noteModifierLike_sequenceOptionalRepeatable = accid*, artic*, dot*
model.noteModifierLike_sequenceRepeatable = accid+, artic+, dot+
model.numLike = num
model.numLike_alternation = num
model.numLike_sequence = num
model.numLike_sequenceOptional = num?
model.numLike_sequenceOptionalRepeatable = num*
model.numLike_sequenceRepeatable = num+
model.paracontentPart =
  model.textphraseLike
  | model.editLike
  | model.transcriptionLike
  | model.tableLike
  | model.listLike
  | model.quoteLike
model.pLike = p
model.pLike_alternation = p
model.pLike_sequence = p
model.pLike_sequenceOptional = p?
model.pLike_sequenceOptionalRepeatable = p*
model.pLike_sequenceRepeatable = p+
model.partLike = part
model.partsLike = parts
model.pbLike = pb
model.pbLike_alternation = pb
model.pbLike_sequence = pb
model.pbLike_sequenceOptional = pb?
model.pbLike_sequenceOptionalRepeatable = pb*
model.pbLike_sequenceRepeatable = pb+
model.rendLike = rend | stack
model.rendLike_alternation = rend | stack
model.rendLike_sequence = rend, stack
model.rendLike_sequenceOptional = rend?, stack?
model.rendLike_sequenceOptionalRepeatable = rend*, stack*
model.rendLike_sequenceRepeatable = rend+, stack+
model.repositoryLike = repository
model.repositoryLike_alternation = repository
model.repositoryLike_sequence = repository
model.repositoryLike_sequenceOptional = repository?
model.repositoryLike_sequenceOptionalRepeatable = repository*
model.repositoryLike_sequenceRepeatable = repository+
model.scoreDefLike = scoreDef
model.scoreLike = score
model.scorePart = model.endingLike | model.sectionLike
model.sectionLike = section
model.sectionLike_alternation = section
model.sectionLike_sequence = section
model.sectionLike_sequenceOptional = section?
model.sectionLike_sequenceOptionalRepeatable = section*
model.sectionLike_sequenceRepeatable = section+
model.sectionPart =
  model.endingLike
  | model.sectionLike
  | model.staffLike
  | model.sectionPart.cmn
model.sectionPart_alternation =
  model.endingLike_alternation
  | model.sectionLike_alternation
  | model.staffLike_alternation
  | model.sectionPart.cmn_alternation
model.sectionPart_sequence =
  model.endingLike_sequence,
  model.sectionLike_sequence,
  model.staffLike_sequence,
  model.sectionPart.cmn_sequence
model.sectionPart_sequenceOptional =
  model.endingLike_sequenceOptional?,
  model.sectionLike_sequenceOptional?,
  model.staffLike_sequenceOptional?,
  model.sectionPart.cmn_sequenceOptional?
model.sectionPart_sequenceOptionalRepeatable =
  model.endingLike_sequenceOptionalRepeatable*,
  model.sectionLike_sequenceOptionalRepeatable*,
  model.staffLike_sequenceOptionalRepeatable*,
  model.sectionPart.cmn_sequenceOptionalRepeatable*
model.sectionPart_sequenceRepeatable =
  model.endingLike_sequenceRepeatable+,
  model.sectionLike_sequenceRepeatable+,
  model.staffLike_sequenceRepeatable+,
  model.sectionPart.cmn_sequenceRepeatable+
model.staffDefLike = staffDef
model.staffDefPart =
  model.keySigLike | clef | clefGrp | model.staffDefPart.mensural
model.staffGrpLike = staffGrp
model.staffLike = staff
model.staffLike_alternation = staff
model.staffLike_sequence = staff
model.staffLike_sequenceOptional = staff?
model.staffLike_sequenceOptionalRepeatable = staff*
model.staffLike_sequenceRepeatable = staff+
model.staffPart = model.layerLike | model.ossiaLike
model.textcomponentLike =
  model.pLike
  | model.tableLike
  | model.listLike
  | model.quoteLike
  | model.lgLike
model.textcomponentLike_alternation =
  model.pLike_alternation
  | model.tableLike_alternation
  | model.listLike_alternation
  | model.quoteLike_alternation
  | model.lgLike_alternation
model.textcomponentLike_sequence =
  model.pLike_sequence,
  model.tableLike_sequence,
  model.listLike_sequence,
  model.quoteLike_sequence,
  model.lgLike_sequence
model.textcomponentLike_sequenceOptional =
  model.pLike_sequenceOptional?,
  model.tableLike_sequenceOptional?,
  model.listLike_sequenceOptional?,
  model.quoteLike_sequenceOptional?,
  model.lgLike_sequenceOptional?
model.textcomponentLike_sequenceOptionalRepeatable =
  model.pLike_sequenceOptionalRepeatable*,
  model.tableLike_sequenceOptionalRepeatable*,
  model.listLike_sequenceOptionalRepeatable*,
  model.quoteLike_sequenceOptionalRepeatable*,
  model.lgLike_sequenceOptionalRepeatable*
model.textcomponentLike_sequenceRepeatable =
  model.pLike_sequenceRepeatable+,
  model.tableLike_sequenceRepeatable+,
  model.listLike_sequenceRepeatable+,
  model.quoteLike_sequenceRepeatable+,
  model.lgLike_sequenceRepeatable+
model.textphraseLike =
  model.addressLike
  | model.annotLike
  | model.biblLike
  | model.dateLike
  | model.editorialLike
  | model.identifierLike
  | model.measurementLike
  | model.milestoneLike.text
  | model.nameLike
  | model.rendLike
  | model.titleLike
  | model.figureLike
  | model.nameLike.agent
  | model.nameLike.place
  | model.nameLike.label
  | model.locrefLike
model.textphraseLike_alternation =
  model.addressLike_alternation
  | model.annotLike_alternation
  | model.biblLike_alternation
  | model.dateLike_alternation
  | model.editorialLike_alternation
  | model.identifierLike_alternation
  | model.measurementLike_alternation
  | model.milestoneLike.text_alternation
  | model.nameLike_alternation
  | model.rendLike_alternation
  | model.titleLike_alternation
  | model.figureLike_alternation
  | model.nameLike.agent_alternation
  | model.nameLike.place_alternation
  | model.nameLike.label_alternation
  | model.locrefLike_alternation
model.textphraseLike_sequence =
  model.addressLike_sequence,
  model.annotLike_sequence,
  model.biblLike_sequence,
  model.dateLike_sequence,
  model.editorialLike_sequence,
  model.identifierLike_sequence,
  model.measurementLike_sequence,
  model.milestoneLike.text_sequence,
  model.nameLike_sequence,
  model.rendLike_sequence,
  model.titleLike_sequence,
  model.figureLike_sequence,
  model.nameLike.agent_sequence,
  model.nameLike.place_sequence,
  model.nameLike.label_sequence,
  model.locrefLike_sequence
model.textphraseLike_sequenceOptional =
  model.addressLike_sequenceOptional?,
  model.annotLike_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.dateLike_sequenceOptional?,
  model.editorialLike_sequenceOptional?,
  model.identifierLike_sequenceOptional?,
  model.measurementLike_sequenceOptional?,
  model.milestoneLike.text_sequenceOptional?,
  model.nameLike_sequenceOptional?,
  model.rendLike_sequenceOptional?,
  model.titleLike_sequenceOptional?,
  model.figureLike_sequenceOptional?,
  model.nameLike.agent_sequenceOptional?,
  model.nameLike.place_sequenceOptional?,
  model.nameLike.label_sequenceOptional?,
  model.locrefLike_sequenceOptional?
model.textphraseLike_sequenceOptionalRepeatable =
  model.addressLike_sequenceOptionalRepeatable*,
  model.annotLike_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.dateLike_sequenceOptionalRepeatable*,
  model.editorialLike_sequenceOptionalRepeatable*,
  model.identifierLike_sequenceOptionalRepeatable*,
  model.measurementLike_sequenceOptionalRepeatable*,
  model.milestoneLike.text_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*,
  model.rendLike_sequenceOptionalRepeatable*,
  model.titleLike_sequenceOptionalRepeatable*,
  model.figureLike_sequenceOptionalRepeatable*,
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.nameLike.place_sequenceOptionalRepeatable*,
  model.nameLike.label_sequenceOptionalRepeatable*,
  model.locrefLike_sequenceOptionalRepeatable*
model.textphraseLike_sequenceRepeatable =
  model.addressLike_sequenceRepeatable+,
  model.annotLike_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.dateLike_sequenceRepeatable+,
  model.editorialLike_sequenceRepeatable+,
  model.identifierLike_sequenceRepeatable+,
  model.measurementLike_sequenceRepeatable+,
  model.milestoneLike.text_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+,
  model.rendLike_sequenceRepeatable+,
  model.titleLike_sequenceRepeatable+,
  model.figureLike_sequenceRepeatable+,
  model.nameLike.agent_sequenceRepeatable+,
  model.nameLike.place_sequenceRepeatable+,
  model.nameLike.label_sequenceRepeatable+,
  model.locrefLike_sequenceRepeatable+
model.textphraseLike.limited =
  model.addressLike
  | model.biblLike
  | model.dateLike
  | model.editorialLike
  | model.identifierLike
  | model.lbLike
  | model.measurementLike
  | model.nameLike
  | model.rendLike
  | model.titleLike
  | model.figureLike
  | model.nameLike.agent
  | model.nameLike.place
  | model.nameLike.label
  | model.locrefLike
model.textphraseLike.limited_alternation =
  model.addressLike_alternation
  | model.biblLike_alternation
  | model.dateLike_alternation
  | model.editorialLike_alternation
  | model.identifierLike_alternation
  | model.lbLike_alternation
  | model.measurementLike_alternation
  | model.nameLike_alternation
  | model.rendLike_alternation
  | model.titleLike_alternation
  | model.figureLike_alternation
  | model.nameLike.agent_alternation
  | model.nameLike.place_alternation
  | model.nameLike.label_alternation
  | model.locrefLike_alternation
model.textphraseLike.limited_sequence =
  model.addressLike_sequence,
  model.biblLike_sequence,
  model.dateLike_sequence,
  model.editorialLike_sequence,
  model.identifierLike_sequence,
  model.lbLike_sequence,
  model.measurementLike_sequence,
  model.nameLike_sequence,
  model.rendLike_sequence,
  model.titleLike_sequence,
  model.figureLike_sequence,
  model.nameLike.agent_sequence,
  model.nameLike.place_sequence,
  model.nameLike.label_sequence,
  model.locrefLike_sequence
model.textphraseLike.limited_sequenceOptional =
  model.addressLike_sequenceOptional?,
  model.biblLike_sequenceOptional?,
  model.dateLike_sequenceOptional?,
  model.editorialLike_sequenceOptional?,
  model.identifierLike_sequenceOptional?,
  model.lbLike_sequenceOptional?,
  model.measurementLike_sequenceOptional?,
  model.nameLike_sequenceOptional?,
  model.rendLike_sequenceOptional?,
  model.titleLike_sequenceOptional?,
  model.figureLike_sequenceOptional?,
  model.nameLike.agent_sequenceOptional?,
  model.nameLike.place_sequenceOptional?,
  model.nameLike.label_sequenceOptional?,
  model.locrefLike_sequenceOptional?
model.textphraseLike.limited_sequenceOptionalRepeatable =
  model.addressLike_sequenceOptionalRepeatable*,
  model.biblLike_sequenceOptionalRepeatable*,
  model.dateLike_sequenceOptionalRepeatable*,
  model.editorialLike_sequenceOptionalRepeatable*,
  model.identifierLike_sequenceOptionalRepeatable*,
  model.lbLike_sequenceOptionalRepeatable*,
  model.measurementLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*,
  model.rendLike_sequenceOptionalRepeatable*,
  model.titleLike_sequenceOptionalRepeatable*,
  model.figureLike_sequenceOptionalRepeatable*,
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.nameLike.place_sequenceOptionalRepeatable*,
  model.nameLike.label_sequenceOptionalRepeatable*,
  model.locrefLike_sequenceOptionalRepeatable*
model.textphraseLike.limited_sequenceRepeatable =
  model.addressLike_sequenceRepeatable+,
  model.biblLike_sequenceRepeatable+,
  model.dateLike_sequenceRepeatable+,
  model.editorialLike_sequenceRepeatable+,
  model.identifierLike_sequenceRepeatable+,
  model.lbLike_sequenceRepeatable+,
  model.measurementLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+,
  model.rendLike_sequenceRepeatable+,
  model.titleLike_sequenceRepeatable+,
  model.figureLike_sequenceRepeatable+,
  model.nameLike.agent_sequenceRepeatable+,
  model.nameLike.place_sequenceRepeatable+,
  model.nameLike.label_sequenceRepeatable+,
  model.locrefLike_sequenceRepeatable+
model.titleLike = title
model.titleLike_alternation = title
model.titleLike_sequence = title
model.titleLike_sequenceOptional = title?
model.titleLike_sequenceOptionalRepeatable = title*
model.titleLike_sequenceRepeatable = title+
abbr =
  
  ## abbreviation ―
  ##         A generic element for 1) a shortened form of a word, including an acronym or 2) a shorthand
  ##         notation. The type attribute may be used to classify the abbreviation according to some
  ##         convenient typology. Sample values include: suspension - the abbreviation provides the first
  ##         letter(s) of the word or phrase, omitting the remainder; contraction - the abbreviation
  ##         omits some letter(s) in the middle; brevigraph - the abbreviation comprises a special symbol
  ##         or mark; superscription - the abbreviation includes writing above the line; acronym - the
  ##         abbreviation comprises the initial letters of the words of a phrase; title - the
  ##         abbreviation is for a title of address (Dr, Ms, Mr, ...); organization - the abbreviation is
  ##         for the name of an organization; geographic - the abbreviation is for a geographic name.
  ##         This tag is the mirror image of the <expan> tag; both allow the encoder to transcribe
  ##         both an abbreviation and its expansion. In <abbr>, however, the original is
  ##         transcribed as the content of the element and the expansion as an attribute value;
  ##         <expan> reverses this. The choice between the two is up to the user. The <abbr>
  ##         tag is not required; if appropriate, the encoder may transcribe abbreviations in the source
  ##         text silently, without tagging them. If abbreviations are not transcribed directly but
  ##         expanded silently, then the MEI header should so indicate. The cert attribute signifies the
  ##         degree of certainty ascribed to the expansion of the abbreviation. The expan attribute gives
  ##         an expansion of the abbreviation. The resp attribute contains an ID reference to an element
  ##         containing the name of the editor or transcriber responsible for supplying the expansion of
  ##         the abbreviation. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element abbr {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## records the
    ##             expansion of a text abbreviation.
    attribute expan { text }?,
    empty
  }
accid =
  
  ## accidental ―
  ##         Records a temporary alteration to the pitch of a note. An accidental may raise a pitch by
  ##         one or two semitones or it may cancel a previous accidental or part of a key signature. This
  ##         element provides an alternative to the accid and accid.ges attributes on the <note>
  ##         element. The element should be used when specific display info, such as size or color, needs
  ##         to be recorded for the accidental or when multiple accidentals occur on a single note. The
  ##         func attribute can be used to differentiate between the accidental's functions, such as
  ##         'cautionary' or 'editorial'.
  element accid {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.typography.attributes,
    att.accid.log.attributes,
    att.accid.vis.attributes,
    att.accid.ges.attributes,
    att.accid.anl.attributes,
    empty
  }
actor =
  
  ## actor ― Name of
  ##         an actor appearing within a cast list.
  element actor {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
address =
  
  ## address ―
  ##         Contains a postal address, for example of a publisher, an organization, or an individual.
  ##         This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element address {
    addrLine+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
addrLine =
  
  ## addrLine ―
  ##         Single line of a postal address. This element may be repeated as many times as necessary to
  ##         enter all lines of an address. This element is modelled on elements in Encoded Archival
  ##         Description (EAD) and the Text Encoding Initiative (TEI).
  element addrLine {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
annot =
  
  ## annotation ―
  ##         Provides a short statement explaining the text or indicating the basis for an assertion. It
  ##         is used for both general comments and for an annotation of the musical text. The
  ##         <annot> element provides a way to group participating *events* and/or *control
  ##         events*, for example, the notes that form a descending bass line or phrase marks, and a
  ##         label for or comment regarding the group. Participating entities may be identified in the
  ##         plist attribute. An editorial or analytical comment or observation may be included directly
  ##         within the <annot> element. The starting point of the annotation may be indicated by
  ##         either a tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending point may be
  ##         recorded by either a dur, dur.ges or endid attribute. The resp attribute records the
  ##         editor(s) responsible for identifying or creating the annotation.
  element annot {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.source.attributes,
    att.typed.attributes,
    att.annot.log.attributes,
    att.annot.vis.attributes,
    att.annot.ges.attributes,
    att.annot.anl.attributes,
    att.plist.attributes,
    att.responsibility.attributes,
    empty
  }
artic =
  
  ## articulation ―
  ##         An indication of how to play a note or chord. Articulations typically affect duration, such
  ##         as staccato marks, or the force of attack, such as accents. This element provides an
  ##         alternative to the artic attributes on the <note> and <chord> elements. It
  ##         should be used when specific display info, such as size or color, needs to be recorded for
  ##         the articulation or when multiple articulation marks occur on a single note or
  ##         chord.
  element artic {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.typography.attributes,
    att.artic.log.attributes,
    att.artic.vis.attributes,
    att.artic.ges.attributes,
    att.artic.anl.attributes,
    empty
  }
barLine =
  
  ## bar line ―
  ##         Vertical line drawn through one or more staves that divides musical notation into metrical
  ##         units. This element is provided for repertoires, such as mensural notation, that lack
  ##         measures. Because the barLine element's attributes, from which the logical and visual
  ##         characteristics of the bar line can be discerned, largely duplicate those of measure, the
  ##         use of barLine is not necessary within measure elements in CMN.
  element barLine {
    empty
    >> sch:pattern [
         id = "barLine-constraint-Check_barLinetaktplace"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:barLine[@taktplace]"
           "\x{a}" ~
           "          "
           sch:let [ name = "staff" value = "ancestor::mei:staff/@n" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "staffpos"
             value =
               "count(ancestor::mei:staff/preceding-sibling::mei:staff) +                 1"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@taktplace) <= number(2 *                 preceding::mei:staffDef[@n=$staff and @lines][1]/@lines)"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.barLine.log.attributes,
    att.barLine.vis.attributes,
    att.barLine.ges.attributes,
    att.barLine.anl.attributes,
    empty
  }
bibl =
  
  ## bibliographic
  ##         reference ― Provides a citation for a published work. <bibref> may contain a mix of
  ##         text and more specific elements such as <title>, <edition>, <persName>,
  ##         and <corpName>. This element may also function as a hypertext reference to an external
  ##         electronic resource. Do not confuse this element with <ref>, which does not provide
  ##         special bibliographic sub-elements.
  element bibl {
    (text | model.biblPart | model.textphraseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    empty
  }
body =
  
  ## body ― This
  ##         element contains the actual music data of the MEI encoding, as opposed to the header, front,
  ##         and back elements, which do not. When the music can be broken into high-level, discrete,
  ##         linear segments, such as movements of a symphony, there may be multiple <mdiv>
  ##         elements within this element. This is the highest level indication of the structure of the
  ##         music. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element body {
    model.mdivLike+,
    att.common.attributes,
    att.declaring.attributes,
    empty
  }
caption =
  
  ## caption ― A
  ##         label which accompanies an illustration or a table.
  element caption {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castList =
  
  ## cast list ―
  ##         Contains a single cast list or dramatis personae.
  element castList {
    model.headLike?,
    (castItem | castGrp)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castItem =
  
  ## cast list item
  ##         ― Contains a single entry within a cast list, describing either a single role or a list of
  ##         non-speaking roles.
  element castItem {
    (text | role | roleDesc | actor)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
castGrp =
  
  ## cast list group
  ##         ― Groups one or more individual castItem elements within a cast list.
  element castGrp {
    (castItem | castGrp | roleDesc)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
chord =
  
  ## chord ― A
  ##         simultaneous sounding of two or more notes in the same layer *with the same
  ##         duration*.
  element chord {
    (note | artic)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.chord.log.attributes,
    att.chord.vis.attributes,
    att.chord.ges.attributes,
    att.chord.anl.attributes,
    empty
  }
clef =
  
  ## clef ―
  ##         Indication of the exact location of a particular note on the staff and, therefore, the other
  ##         notes as well. This element can be used as an alternative to the staff element's clef.*
  ##         attributes. It should be used when specific display info, such as size or color, needs to be
  ##         recorded for the clef or when multiple, simultaneous clefs occur on a single staff. This
  ##         element may also be used within the staff context to indicate changes of
  ##         clef.
  element clef {
    empty
    >> sch:pattern [
         id = "clef-constraint-Check_clef_position_clef"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[@lines]]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=                 number(ancestor::mei:staffDef[@n=$thisstaff and                 @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines on the\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "clef-constraint-Check_clef_position_clef"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:clef[ancestor::mei:staffDef[not(@lines)]]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staffDef/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=                 number(preceding::mei:staffDef[@n=$thisstaff and                 @lines][1]/@lines)"
             "The clef position must be less than or equal to the number of lines on the\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.clef.anl.attributes,
    att.clef.ges.attributes,
    att.clef.log.attributes,
    att.clef.vis.attributes,
    empty
  }
clefGrp =
  
  ## clef group ― A
  ##         set of simultaneously-occurring clefs
  element clefGrp {
    clef+,
    att.common.attributes,
    att.event.attributes,
    att.facsimile.attributes,
    att.clefGrp.log.attributes,
    att.clefGrp.vis.attributes,
    att.clefGrp.ges.attributes,
    att.clefGrp.anl.attributes,
    empty
  }
custos =
  
  ## custos ― Symbol
  ##         placed at the end of a line of music to indicate the first note of the next line. Sometimes
  ##         called a "direct". The most common visual form is a sign resembling a mordent. Other
  ##         graphical forms may be indicated by the altsym attribute. Together the pname and oct
  ##         attributes identify the location where the custos appears. 
  element custos {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.custos.log.attributes,
    att.custos.vis.attributes,
    att.custos.ges.attributes,
    att.custos.anl.attributes,
    empty
  }
date =
  
  ## date ― A date
  ##         in any format, including a date range. A date range may be expressed either as textual
  ##         content, e.g., <date>March 1-21, 1812</date>, or using date sub-elements,
  ##         possibly combined with text, e.g., <date> <date>March 1, 1812</date> -
  ##         <date>March 21, 1812</date> </date>. The latter form is useful when the
  ##         starting and ending points of the date range require qualification. This element is modelled
  ##         on an element in the Text Encoding Initiative (TEI).
  element date {
    (text | model.textphraseLike)*,
    att.bibl.attributes,
    att.calendared.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    
    ## gives the
    ##             value of a date in standard ISO form.
    attribute reg { data.ISODATE }?,
    empty
  }
dir =
  
  ## directive ― A
  ##         text expression that is on the score (typically above, below, or between staves, but not on
  ##         the staff) not encoded elsewhere in more specific elements, such as <tempo> or
  ##         <dynam>. Examples include text strings, such as 'affettuoso' or fingering numbers, and
  ##         music symbols, such as segno and coda symbols, fermatas over a bar line, etc. Directives can
  ##         be control elements. That is, they can linked via their attributes to other events. The
  ##         starting point of the directive may be indicated by either a tstamp, tstamp.ges, tstamp.real
  ##         or startid attribute, while the ending point may be recorded by either a dur, dur.ges or
  ##         endid attribute. It is a semantic error not to specify a starting point
  ##         attribute.
  element dir {
    ((text
      | model.textphraseLike.limited
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "dir-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:dir"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    att.dir.log.attributes,
    att.dir.vis.attributes,
    att.dir.ges.attributes,
    att.dir.anl.attributes,
    empty
  }
dot =
  
  ## dot ― This
  ##         element provides an alternative to the dots attribute on chord, note, rest, space, tuplet,
  ##         and tupletSpan elements. It should be used when specific display info, such as size or
  ##         color, needs to be recorded for the dot. This element may also be used for dots of division
  ##         in the mensural repertoire.
  element dot {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.dot.log.attributes,
    att.dot.vis.attributes,
    att.dot.ges.attributes,
    att.dot.anl.attributes,
    empty
  }
dynam =
  
  ## dynamic ―
  ##         Indication of the volume of a note, phrase, or section of music. This element may be used
  ##         for instantaneous or continuous textual dynamics, e.g. 'p', 'mf', or 'cresc. poco a poco'.
  ##         The <hairpin> element should be used for graphical, i.e., crescendo and diminuendo,
  ##         dynamic markings. The starting point of the dynamic marking may be indicated by either a
  ##         tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending point may be recorded
  ##         by either a dur, dur.ges or endid attribute. It is a semantic error not to specify a
  ##         starting point attribute. Please note that the dur attribute is not a true duration, but
  ##         rather a time stamp for the end point of the dynamic mark. A MIDI value associated with the
  ##         graphical dynamic sign may be recorded in the val attribute.
  element dynam {
    ((text
      | model.textphraseLike.limited
      | model.editLike
      | model.transcriptionLike)*)
    >> sch:pattern [
         id =
           "dynam-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:dynam"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.dynam.log.attributes,
    att.dynam.vis.attributes,
    att.dynam.ges.attributes,
    att.dynam.anl.attributes,
    empty
  }
edition =
  
  ## edition
  ##         designation ― A word or text phrase that indicates a difference in either content or form
  ##         between the item being described and a related item previously issued by the same
  ##         publisher/distributor (e.g. 2nd edition, version 2.0, etc.), or simultaneously issued by
  ##         either the same publisher/distributor or another publisher/distributor (e.g. large print
  ##         edition, British edition, etc.). This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element edition {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
ending =
  
  ## ending ―
  ##         Alternative ending for a repeated passage of music; i.e., prima volta, seconda volta, etc.
  ##         The scoreDef element is allowed as a sub-element so that an ending may have its own
  ##         meta-data without the overhead of child <section>s. Div sub-elements are not allowed
  ##         within ending in order to avoid collisions with the brackets that are usually displayed over
  ##         endings. Endings may *not* contain other ending elements.
  element ending {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.sectionPart)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.ending.anl.attributes,
    att.ending.ges.attributes,
    att.ending.log.attributes,
    att.ending.vis.attributes,
    empty
  }
expan =
  
  ## expansion ―
  ##         Contains the expansion of an abbreviation. The type attribute may be used to classify the
  ##         abbreviation according to some convenient typology. This element is the mirror image of
  ##         <abbr>. Both allow the encoder to transcribe both an abbreviation and its expansion.
  ##         In <abbr>, however, the original is transcribed as the content of the element and the
  ##         expansion as an attribute value; <expan> reverses this. The choice between the two
  ##         elements is up to the user. If appropriate, the encoder may expand abbreviations in the
  ##         source text silently, without tagging them. If this is done, the MEI header should indicate
  ##         this has been done. The abbr attribute gives the abbreviation in its unexpanded form. The
  ##         cert attribute signifies the degree of certainty ascribed to the expansion of the
  ##         abbreviation. The resp attribute contains an ID reference to an element containing the name
  ##         of the editor or transcriber responsible for supplying the expansion of the abbreviation
  ##         held as the content of the <expan> element. This element is modelled on an element in
  ##         the Text Encoding Initiative (TEI).
  element expan {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## captures
    ##             the unabbreviated form of the text.
    attribute abbr { text }?,
    empty
  }
expansion =
  
  ## expansion ―
  ##         Indicates how a section may be programmatically expanded into its 'through-composed' form.
  ##         The plist attribute contains an ordered list of identifiers of descendant <section>,
  ##         <ending>, <lem>, or <rdg> elements. For example, the sequence "#A #End1 #A
  ##         #End2" indicates that the section labelled 'A' comes first, then the ending labelled 'End1',
  ##         followed by the 'A' section again, and finally the ending labelled 'End2'.
  element expansion {
    empty,
    att.common.attributes,
    att.source.attributes,
    att.typed.attributes,
    att.plist.attributes,
    empty
  }
fw =
  
  ## forme work ―
  ##         This element is intended for capture of header/footer material that is non-repeating; that
  ##         is, it occurs on isolated pages. For recurring headers and footers use pgHead* and pgFoot*
  ##         elements. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element fw {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    empty
  }
group =
  
  ## group ― Enables
  ##         the gathering of multiple documents into a single file. Because its model contains the music
  ##         element, each of the documents can have its own front and back matter. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element group {
    (music | group),
    (music | group)*,
    att.common.attributes,
    att.declaring.attributes,
    empty
  }
grpSym =
  
  ## group symbol ―
  ##         A brace or bracket used to group two or more staves of a score or part. This element
  ##         provides an alternative to the staffGrp element's symbol attribute. It may be used when
  ##         exact placement or editorial details for the grouping symbol must be
  ##         recorded.
  element grpSym {
    model.labelLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.grpSym.log.attributes,
    att.grpSym.vis.attributes,
    att.grpSym.ges.attributes,
    att.grpSym.anl.attributes,
    empty
  }
identifier =
  
  ## identifier ― An
  ##         alpha-numeric string that establishes the identity of the described material, such as an
  ##         International Standard Book/Music Number, Library of Congress Control Number, publisher's
  ##         number, a personal identification number, an entry in a bibliography or catalog, etc. The
  ##         type attribute may be used to indicate the system from which the identifier was
  ##         derived.
  element identifier {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
incip =
  
  ## incipit ― The
  ##         opening music and/or words of a composition. The <incipText> element may be used to
  ##         capture a text incipit, while <score> is available to provide an MEI-encoded musical
  ##         incipit. Images of an incipit may be referenced using the >graphic< element. An
  ##         incipit encoded in a text format other than MEI may be placed in the <incipCode>
  ##         element.
  element incip {
    (incipCode | incipText | model.scoreLike | model.graphicLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.typed.attributes,
    empty
  }
instrGrp =
  
  ## instrument
  ##         group ― Collects MIDI instrument definitions.
  element instrGrp { model.instrDefLike+, att.common.attributes, empty }
instrDef =
  
  ## instrument
  ##         definition ― MIDI instrument declaration. This element provides a starting or default
  ##         instrument declaration for a staff, a group of staves, or a layer. MIDI prog elements may
  ##         then change the instrument as necessary.
  element instrDef {
    empty,
    att.common.attributes,
    att.channelized.attributes,
    att.midiinstrument.attributes,
    empty
  }
keyAccid =
  
  ## key accidental
  ##         ― Accidental in a key signature. It is a semantic error not to provide either the x and y
  ##         pair of attributes or the staffloc attribute.
  element keyAccid {
    empty,
    att.accidental.attributes,
    att.common.attributes,
    att.enclosingchars.attributes,
    att.facsimile.attributes,
    att.pitched.attributes,
    att.staffloc.attributes,
    att.xy.attributes,
    
    ## specifies
    ##             whether enharmonic (written) values or implicit ("perform-able") values are
    ##             allowed.
    attribute form {
      
      ## only
      ##               performed values (sharp, flat, natural) allowed
      "implicit"
      | 
        ## all
        ##               enharmonic (written) values allowed
        "explicit"
    }?,
    empty
  }
keySig =
  
  ## key signature ―
  ##         This element may be used as an alternative to the key.* attributes (especially
  ##         key.sig.mixed) on scoreDef and staffDef.
  element keySig {
    model.keyAccidLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.accidental.attributes,
    att.pitch.attributes,
    
    ## indicates
    ##             major, minor, or other tonality.
    attribute mode { data.MODE }?,
    empty
  }
label =
  
  ## label ― A text
  ##         string that identifies a staff, staff group, or contentItem.
  element label {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.typed.attributes,
    empty
  }
layer =
  
  ## layer ― An
  ##         independent stream of events on a staff. The term 'layer' is used instead of 'voice' in
  ##         order to avoid confusion between 'voice' and 'voice leading'. The def attribute may be used
  ##         to create a connection with a layerDef element where logical and visual information about
  ##         the layer is recorded. Alternatively, the n attribute may be used as a reference to a
  ##         layerDef element with the same value in its n attribute. If neither def nor n attributes are
  ##         present, then encoding order of the layers is presumed to match the encoding order of the
  ##         layer definitions.
  element layer {
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.scoreDefLike
      | model.staffDefLike
      | model.staffGrpLike
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.layerPart)*)
    >> sch:pattern [
         id = "layer-constraint-Check_layern"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:layer[@n]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "The n attribute must be a single\x{a}" ~
             "            integer."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.layer.log.attributes,
    att.layer.vis.attributes,
    att.layer.ges.attributes,
    att.layer.anl.attributes,
    empty
  }
layerDef =
  
  ## layer
  ##         definition ― Container for layer meta-information.
  element layerDef {
    model.labelLike*,
    (model.instrDefLike*)
    >> sch:pattern [
         id = "layerDef-constraint-Check_layerDefn"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:layerDef"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "An n attribute with a single integer\x{a}" ~
             "            value must be present."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.layerDef.log.attributes,
    att.layerDef.vis.attributes,
    att.layerDef.ges.attributes,
    att.layerDef.anl.attributes,
    empty
  }
lb =
  
  ## line break ― An
  ##         empty formatting element that forces text to begin on a new line. The n attribute should be
  ##         used to record a label for the line, i.e., most likely a line number. See comment on
  ##         <verse> element for description of func attribute. Do not confuse this element with
  ##         the <sb> element, which performs a similar function for musical notation. This element
  ##         is modelled on an element in the Text Encoding Initiative (TEI).
  element lb {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.typed.attributes,
    
    ## states
    ##             whether the line break follows a single line or a line group.
    attribute func {
      
      ##
      "line"
      | 
        ##
        "group"
    }?,
    empty
  }
mdiv =
  
  ## musical
  ##         division ― The mdiv element may contain one or both of 2 possible views of the music. The
  ##         score view is the traditional full and open score while the parts view contains each
  ##         performer's view of the score; that is, his part. These 2 views are necessary because it is
  ##         not always possible or desirable to generate one from the other. The score and parts
  ##         elements are placed here and not directly within the body element because score and part
  ##         characteristics may change from mdiv to mdiv. For example, the 2nd movement of a symphony
  ##         may require different performing forces (and therefore different score and part layout) than
  ##         the other movements. The mdiv element may be recursively nested in order to represent music
  ##         which exhibits this kind of structure. For example, an opera is normally divided into acts,
  ##         which are in turn divided into scenes. This may be represented by the following markup:
  ##         <mdiv> <- the opera <mdiv> <- act I <mdiv> <- scene i
  ##         <mdiv> <- scene ii </mdiv> <mdiv> <- act II <mdiv> <- scene
  ##         i <mdiv> <- scene ii </mdiv> </mdiv>
  element mdiv {
    ((model.scoreLike?, model.partsLike?) | model.mdivLike*),
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
mei =
  
  ## mei ― The
  ##         document element for a single document, containing a header and data. The <mei>
  ##         element defines a particular instance of a document encoded with the MEI schema. The name of
  ##         this element should not be changed in order to assure an absolute minimum level of MEI
  ##         compliance.
  element mei {
    meiHead,
    music
    >> sch:ns [
         prefix = "mei"
         uri = "http://www.music-encoding.org/ns/mei"
       ]
    >> sch:pattern [
         id = "mei-constraint-Check_staff"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:*[@staff]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "every $i in tokenize(@staff, '\s+') satisfies                 $i=//mei:staffDef/@n"
             "The values in @staff must correspond to @n attribute of a staffDef\x{a}" ~
             "            element."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.meiversion.attributes,
    
    ## regularizes
    ##             the naming of an element and thus facilitates building links between it and other
    ##             resources. Each id attribute within a document must have a unique
    ##             value.
    attribute xml:id { xsd:ID }?,
    empty
  }
music =
  
  ## music ―
  ##         Container for everything else in the document apart from the header.
  element music {
    model.alignLike*,
    model.facsimileLike*,
    model.performanceLike*,
    macro.musicPart,
    att.common.attributes,
    att.declaring.attributes,
    att.meiversion.attributes,
    empty
  }
name =
  
  ## name ― Contains
  ##         the name of an entity that is difficult to tag more specifically as a <corpName>,
  ##         <geogName>, <persName>, or <title>. The <name> element may be used
  ##         in place of the more specific elements when it is not known what kind of name is being
  ##         described or when a high degree of precision is not necessary. For example, the <name>
  ##         element might be used when it is not clear whether the name "Bach" refers to a person or a
  ##         geographic feature. The <name> element may be used for an individual, such as 'Henry
  ##         VIII, King of England'; a corporate body, such as 'The Beatles'; a geographical place; or a
  ##         generative mechanical process. When name parts are needed, use <name> sub-elements.
  ##         The recommended values for the type attribute are: pers, corp, place, process. The
  ##         <date> sub-element is available within <name> in order to record any dates,
  ##         associated with the name, i.e., birth and death in the case of persons or creation and
  ##         dissolution in the case of a corporate entity or place. The name of the list from which a
  ##         controlled value is taken, such as the Thesaurus of Geographic Names (TGN) or Library of
  ##         Congress Name Authority File (LCNAF), may be recorded using the authority attribute. This
  ##         element is modelled on an element in Encoded Archival Description (EAD).
  element name {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
note =
  
  ## note ― A single
  ##         pitched event. (Read, p. 63) The note element is allowed to contain other events for
  ##         situations where a single (usually ornamented) written note is representative of a group of
  ##         performed notes. The accid and artic sub-elements may be used instead of the note element's
  ##         attributes when accid and artic represent first-class objects, e.g., when they require
  ##         attributes, such as x and y location attributes. Similarly, the syl sub-element may be used
  ##         instead of the syl attribute. The verse sub-element may be used to group text syllables by
  ##         verse. The colored attribute may be used to indicate coloration. In the mensural repertoire,
  ##         coloration is a temporary change in the underlying mensuration from perfect to imperfect. In
  ##         the CMN repertoire, coloration is an inversion of the note head's normal rendition, that is,
  ##         the note head is void when it would otherwise be filled and vice versa. Do not confuse this
  ##         with visual color.
  element note {
    (model.eventLike
     | model.noteModifierLike
     | model.verseLike
     | model.sylLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.note.log.attributes,
    att.note.vis.attributes,
    att.note.ges.attributes,
    att.note.anl.attributes,
    empty
  }
num =
  
  ## number ―
  ##         Numeric information in any form. This element is used only when it is necessary to display a
  ##         number in a special way or to identify it with a type attribute.
  element num {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.measurement.attributes,
    empty
  }
p =
  
  ## paragraph ― One
  ##         or more text phrases that form a logical prose passage. A paragraph is usually
  ##         typographically distinct: The text usually begins on a new line and the first letter of the
  ##         content is often indented, enlarged, or both. This element is modelled on elements in
  ##         Encoded Archival Description, Text Encoding Initiative (TEI), and HTML.
  element p {
    (text | model.paracontentPart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
pad =
  
  ## pad ― An
  ##         indication of extra visual space between notational elements.
  element pad {
    empty,
    att.common.attributes,
    att.pad.log.attributes,
    att.pad.vis.attributes,
    att.pad.ges.attributes,
    att.pad.anl.attributes,
    empty
  }
parts =
  
  ## parts ― Gathers
  ##         performers' parts.
  element parts {
    model.partLike*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.parts.log.attributes,
    att.parts.vis.attributes,
    att.parts.ges.attributes,
    att.parts.anl.attributes,
    empty
  }
part =
  
  ## part ― An
  ##         alternative visual rendition of the score from a particular performer's point of view. Part
  ##         elements are not used in the score to indicate voice leading. Next attributes on event
  ##         elements should be used for this purpose. Part elements are useful for encoding individual
  ##         parts when there is no score, such as early music part books, when the music has
  ##         non-aligning bar lines, when different layout, such as page turns, are needed for the score
  ##         and parts, or for accommodating software that requires part-by-part encoding. When assembly
  ##         of the parts into a score is desired and there are non-aligning bar lines, bar lines which
  ##         indicate points of alignment across all the parts may be marked as 'controlling', while
  ##         non-aligning ones may be marked as 'non-controlling'.
  element part {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.scorePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.part.log.attributes,
    att.part.vis.attributes,
    att.part.ges.attributes,
    att.part.anl.attributes,
    empty
  }
pb =
  
  ## page break ―
  ##         The n attribute should be used to record the page number displayed in the source. It need
  ##         not be an integer, e.g., 'iv', or 'p17-3'. The logical page number can be calculated by
  ##         counting previous <pb> ancestor elements. When used in a score context, a page break
  ##         implies an accompanying system break. This element is modelled on an element in the Text
  ##         Encoding Initiative (TEI).
  element pb {
    macro.metaLike.page,
    att.common.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.source.attributes,
    att.pb.anl.attributes,
    att.pb.ges.attributes,
    att.pb.log.attributes,
    att.pb.vis.attributes,
    empty
  }
pgDesc =
  
  ## page
  ##         description ― Contains a brief prose description of the appearance or description of the
  ##         content of a physical page. Best practice suggests the use of controlled vocabulary. Don't
  ##         confuse this element with a figure caption. A caption is text primarily intended for display
  ##         with an illustration. It may or may not function as a description of the
  ##         illustration.
  element pgDesc {
    (text
     | model.graphicprimitiveLike
     | model.textcomponentLike
     | model.annotLike
     | model.locrefLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
pgHead =
  
  ## page header ― A
  ##         running header on the first page. This element is a specialized form of the fw element for
  ##         capturing the table-formatted textual data that often appears on the first page of printed
  ##         music. It may also be used for similarly formatted material in manuscripts. The pgHead* and
  ##         pgFoot* elements should *not* be used to encode textual notes/annotations. Auto-generated
  ##         page numbers may be indicated with a processing instruction.
  element pgHead {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgHead2 =
  
  ## page header 2 ―
  ##         A running header on the pages following the first. This element is a specialized form of the
  ##         fw element. The pgHead* and pgFoot* elements should *not* be used to encode textual
  ##         notes/annotations. Auto-generated page numbers may be indicated with a processing
  ##         instruction.
  element pgHead2 {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgFoot =
  
  ## page footer ― A
  ##         running footer on the first page. This element is a specialized form of the fw element.
  ##         Auto-generated page numbers may be indicated with a processing instruction. The pgHead* and
  ##         pgFoot* elements should *not* be used to encode textual notes/annotations.
  element pgFoot {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
pgFoot2 =
  
  ## page footer 2 ―
  ##         A running header on the pages following the first. This element is a specialized form of the
  ##         fw element. Auto-generated page numbers may be indicated with a processing instruction. The
  ##         pgHead* and pgFoot* elements should *not* be used to encode textual
  ##         notes/annotations.
  element pgFoot2 {
    (text
     | model.textcomponentLike
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike
     | model.appLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
phrase =
  
  ## phrase ―
  ##         Historically, a phrase mark indicated a "unified melodic idea", while the term "slur" was
  ##         used for two-note legato patterns. (Read, p. 265). Nowadays, however, "phrase" and "slur"
  ##         are often used interchangeably (Read, p. 265-266), since the visual rendition of the two
  ##         concepts is the same. MEI provides two distinct elements so that those users wishing to
  ##         maintain a distinction for historical reasons may do so. If the user does not want to
  ##         maintain the distinction, then the more generic <slur> element should be employed. The
  ##         starting point of the phrase may be indicated by either a tstamp, tstamp.ges, tstamp.real or
  ##         startid attribute, while the ending point may be recorded by either a dur, dur.ges or endid
  ##         attribute. It is a semantic error not to specify one starting and one ending type of
  ##         attribute. Either place, bulge, or bezier attributes may be used to record the curvature of
  ##         the phrase. Please note that the dur attribute here is not a true duration, but rather a
  ##         time stamp for the end point of the phrase mark.
  element phrase {
    empty
    >> sch:pattern [
         id =
           "phrase-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:phrase"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.phrase.log.attributes,
    att.phrase.vis.attributes,
    att.phrase.ges.attributes,
    att.phrase.anl.attributes,
    empty
  }
rend =
  
  ## rend ― A
  ##         formatting element indicating special visual rendering, e.g., bold or italicized, of a text
  ##         word or phrase. When an entire element should be rendered in a special way, a style sheet
  ##         function should be used instead of the <rend> element.
  element rend {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.color.attributes,
    att.common.attributes,
    att.lang.attributes,
    att.typography.attributes,
    att.horizontalalign.attributes,
    
    ## used to
    ##             extend the values of the rend attribute.
    attribute altrend { text }?,
    
    ## captures
    ##             the appearance of the element's contents.
    attribute rend { data.TEXTRENDITION }?,
    
    ## A positive
    ##             value for rotation rotates the text in a counter-clockwise fashion, while negative
    ##             values produce clockwise rotation.
    attribute rotation { data.DEGREES }?,
    
    ## specifies
    ##             the vertical position of the element content relative to the surrounding
    ##             text.
    attribute valign {
      
      ## aligns
      ##               the top of the content with the top of the surrounding text
      "top"
      | 
        ## aligns
        ##               the middle of the content with the middle of the surrounding text
        "middle"
      | 
        ## aligns
        ##               the bottom of the content with the bottom of the surrounding text
        "bottom"
      | 
        ## aligns
        ##               the baseline of the content with the baseline of the surrounding
        ##               text
        "baseline"
    }?,
    empty
  }
repository =
  
  ## repository ―
  ##         Institution or agency which holds a bibliographic item. Sub-units of the institution may be
  ##         marked with <repository> sub-elements. The name of the list from which a controlled
  ##         value is taken may be recorded using the authority attribute. This element is modelled on an
  ##         element in Encoded Archival Description (EAD).
  element repository {
    (text | model.textphraseLike.limited)*,
    att.bibl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
rest =
  
  ## rest ― A
  ##         non-sounding event found in the source being transcribed (Read, p. 96-102). Do not confuse
  ##         this element with the space element, which is used as an aid for visual
  ##         alignment.
  element rest {
    empty
    >> sch:pattern [
         id = "rest-constraint-Check_restline"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:rest[@line]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "thisstaff"
             value = "ancestor::mei:staff/@n"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "number(@line) <=                 number(preceding::mei:staffDef[@n=$thisstaff and                 @lines][1]/@lines)"
             "The value of @line must be less than or equal to the number of lines on the\x{a}" ~
             "            staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.rest.log.attributes,
    att.rest.vis.attributes,
    att.rest.ges.attributes,
    att.rest.anl.attributes,
    empty
  }
role =
  
  ## role ― Name of
  ##         a dramatic role, as given in a cast list.
  element role {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
roleDesc =
  
  ## role
  ##         description ― Describes a character's role in a drama.
  element roleDesc {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
sb =
  
  ## system break ―
  ##         An empty formatting element that forces notation to begin on a new line. Do not confuse this
  ##         element with the <lb> element, which performs a similar function in
  ##         prose.
  element sb {
    custos?,
    att.common.attributes,
    att.facsimile.attributes,
    att.source.attributes,
    att.sb.log.attributes,
    att.sb.vis.attributes,
    att.sb.ges.attributes,
    att.sb.anl.attributes,
    empty
  }
score =
  
  ## score ― Full
  ##         score view of the mdiv. Since the measure element is optional, a score may consist entirely
  ##         of pagebreaks, each of which points to a page image. Div elements are allowed preceding and
  ##         following sections of music data in order to accommodate blocks of explanatory
  ##         text.
  element score {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.scorePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.typed.attributes,
    att.score.log.attributes,
    att.score.vis.attributes,
    att.score.ges.attributes,
    att.score.anl.attributes,
    empty
  }
scoreDef =
  
  ## score
  ##         definition ― Container for score meta-information.
  element scoreDef {
    model.alignLike*,
    model.chordTableLike?,
    model.symbolTableLike?,
    model.keySigLike?,
    model.metaLike.score_sequenceOptional,
    instrGrp?,
    model.staffGrpLike?,
    att.common.attributes,
    att.scoreDef.log.attributes,
    att.scoreDef.vis.attributes,
    att.scoreDef.ges.attributes,
    att.scoreDef.anl.attributes,
    empty
  }
section =
  
  ## section ―
  ##         Container for actual music data. Pointing attributes make it possible to connect this
  ##         element to other internal or external entities, such as media objects or
  ##         annotations.
  element section {
    expansion*,
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.scoreDefLike
      | model.staffDefLike
      | model.staffGrpLike
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.sectionPart)*)
    >> sch:pattern [
         id = "section-constraint-Check_sectionexpansion"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:section[mei:expansion]"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "descendant::mei:section|descendant::mei:ending|descendant::mei:rdg"
             "Must\x{a}" ~
             "            have descendant section, ending, or rdg elements that can be pointed to."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.section.log.attributes,
    att.section.vis.attributes,
    att.section.ges.attributes,
    att.section.anl.attributes,
    empty
  }
space =
  
  ## space ― A
  ##         placeholder used to fill an incomplete measure, layer, etc. most often so that the combined
  ##         duration of the events equals the number of beats in the measure.
  element space {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.space.log.attributes,
    att.space.vis.attributes,
    att.space.ges.attributes,
    att.space.anl.attributes,
    empty
  }
stack =
  
  ## stacked text ―
  ##         An inline table with a single column.
  element stack {
    (text | model.textphraseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    
    ## indicates
    ##             the delimiter used to mark the portions of text that are to be
    ##             stacked.
    attribute delim { text }?,
    
    ## specifies
    ##             how the stacked text components should be aligned.
    attribute align {
      
      ## left
      ##               justified
      "left"
      | 
        ## right
        ##               justified
        "right"
      | 
        ## centered
        "center"
      | 
        ## aligned
        ##               on right-most digit
        "rightdigit"
    }?,
    empty
  }
staff =
  
  ## staff ― A group
  ##         of equidistant horizontal lines on which notes are placed in order to represent pitch. In
  ##         MEI, however, <staff> is a grouping element for individual 'strands' of notes, rests,
  ##         etc. that may or may not be rendered on staff lines; that is, diastematic and
  ##         non-diastematic signs. The def attribute may be used to create a connection with a staffDef
  ##         element where logical and visual information about the staff is recorded. Alternatively, the
  ##         n attribute may be used as a reference to a staffDef element with the same value in its n
  ##         attribute. If neither def nor n attributes are present, then the encoding order of the
  ##         staves is presumed to match the encoding order of the staff defintions.
  element staff {
    ((model.appLike
      | model.divLike
      | model.milestoneLike.music
      | model.scoreDefLike
      | model.staffDefLike
      | model.staffGrpLike
      | model.annotLike
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.staffPart)*)
    >> sch:pattern [
         id = "staff-constraint-Check_staffn"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staff[@n]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@n) = round(number(@n))"
             "The n attribute must be a single\x{a}" ~
             "            integer."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.staff.log.attributes,
    att.staff.vis.attributes,
    att.staff.ges.attributes,
    att.staff.anl.attributes,
    empty
  }
staffDef =
  
  ## staff
  ##         definition ― Container for staff meta-information.
  element staffDef {
    model.labelLike*,
    ((model.instrDefLike | model.layerDefLike | model.staffDefPart)*)
    >> sch:pattern [
         id = "staffDef-constraint-Check_staffDefn"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef"
           "\x{a}" ~
           "          "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@n"
             "A staffDef must have an n attribute."
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@lines or preceding::mei:staffDef[@n=$thisstaff                 and @lines]"
             "The\x{a}" ~
             "            first occurrence of a staff must declare the number of staff lines."
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:clef) + count(mei:clefGrp) < 2"
             "Only one clef or clefGrp is\x{a}" ~
             "            permitted."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "staffDef-constraint-Check_clef_position_staffDef"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@clef.line and @lines]"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@clef.line) <= number(@lines)"
             "The clef position must be less\x{a}" ~
             "            than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "staffDef-constraint-Check_clef_position_staffDef"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@clef.line and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [ name = "thisstaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "stafflines"
             value =
               "preceding::mei:staffDef[@n=$thisstaff and                 @lines][1]/@lines"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "number(@clef.line) <= number($stafflines)"
             "The clef position must be\x{a}" ~
             "            less than or equal to the number of lines on the staff."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "staffDef-constraint-Check_tab_strings"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@tab.strings and @lines]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The tab.strings attribute\x{a}" ~
             "            must have the same number of values as there are staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         id = "staffDef-constraint-Check_tab_strings"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@tab.strings and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@tab.strings), '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:let [ name = "thisStaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisStaff and                 @lines][1]/@lines"
             "The tab.strings attribute must have the same number of values as there are staff\x{a}" ~
             "            lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ]
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@lines.color and @lines]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countTokens = 1 or $countTokens = @lines"
             "The lines.color attribute\x{a}" ~
             "            must have either 1) a single value or 2) the same number of values as there are staff\x{a}" ~
             "            lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffDef[@lines.color and not(@lines)]"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countTokens"
             value =
               "count(tokenize(normalize-space(@lines.color), '\s'))"
           ]
           "\x{a}" ~
           "          "
           sch:let [ name = "thisStaff" value = "@n" ]
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "$countTokens = 1 or $countTokens = preceding::mei:staffDef[@n=$thisStaff and                     @lines][1]/@lines"
             "The lines.color attribute must have either 1) a single value or 2) the same number of\x{a}" ~
             "            values as there are staff lines."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.staffDef.log.attributes,
    att.staffDef.vis.attributes,
    att.staffDef.ges.attributes,
    att.staffDef.anl.attributes,
    empty
  }
staffGrp =
  
  ## staff group ― A
  ##         group of bracketed or braced staves. Bracketed staff groups may contain other bracketed or
  ##         braced staff groups or single staves. See Read, p. 35-38, examples p. 434, 438. System is
  ##         the more proper name for this concept (Read, p. 37-38).
  element staffGrp {
    grpSym*,
    model.labelLike*,
    model.instrDefLike*,
    (model.staffGrpLike | model.staffDefLike)+,
    (grpSym*)
    >> sch:pattern [
         id = "staffGrp-constraint-Check_staffGrp_unique_staff_n_values"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staffGrp"
           "\x{a}" ~
           "          "
           sch:let [
             name = "countstaves"
             value = "count(descendant::mei:staffDef)"
           ]
           "\x{a}" ~
           "          "
           sch:let [
             name = "countuniqstaves"
             value =
               "count(distinct-values(descendant::mei:staffDef/@n))"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "$countstaves eq $countuniqstaves"
             "Each staffDef must have a unique value\x{a}" ~
             "            for the n attribute."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.staffGrp.log.attributes,
    att.staffGrp.vis.attributes,
    att.staffGrp.ges.attributes,
    att.staffGrp.anl.attributes,
    empty
  }
syl =
  
  ## syllable ―
  ##         Individual lyric syllable. Do not confuse this element with the syllable element. The align
  ##         attribute indicates the horizontal alignment of the syllable with respect to the note to
  ##         which it is attached.
  element syl {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.syl.log.attributes,
    att.syl.vis.attributes,
    att.syl.ges.attributes,
    att.syl.anl.attributes,
    empty
  }
tempo =
  
  ## tempo ― Text
  ##         and symbols descriptive of tempo, mood, or style, e.g., "allarg.", "a tempo", "cantabile",
  ##         "Moderato", "[qtrnote]=60", "Moderato [qtrnote] =60"). Both instantaneous and continuous
  ##         tempo markings may be encoded using this element. Please note that the dur attribute here is
  ##         expressed in musical time, i.e., beats or other time stamp. Therefore, it is not a true
  ##         duration, but rather a time stamp for the end point of the directive.
  element tempo {
    (text
     | model.textphraseLike.limited
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.tempo.log.attributes,
    att.tempo.vis.attributes,
    att.tempo.ges.attributes,
    att.tempo.anl.attributes,
    empty
  }
title =
  
  ## title ― Title
  ##         of a bibliographic entity. The type attribute may be used to classify the title according to
  ##         some convenient typology. Sample values include: main (main title), subordinate (subtitle,
  ##         title of part), abbreviated (abbreviated form of title), alternative (alternate title by
  ##         which the work is also known), translated (translated form of title), uniform (collective
  ##         title). The type attribute is provided for convenience in analysing titles and processing
  ##         them according to their type; where such specialized processing is not necessary, there is
  ##         no need for such analysis, and the entire title, including subtitles and any parallel
  ##         titles, may be enclosed within a single <title> element. Title parts may be encoded in
  ##         <title> sub-elements. The name of the list from which a controlled value is taken may
  ##         be recorded using the authority attribute. This element is modelled on an element in the
  ##         Text Encoding Initiative (TEI).
  element title {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    
    ## indicates
    ##             the bibliographic level for a title.
    attribute level {
      
      ## article
      "a"
      | 
        ## monograph
        "m"
      | 
        ## journal
        "j"
      | 
        ## series
        "s"
      | 
        ## unpublished (including theses and dissertations unless published by a commercial
        ##               press)
        "u"
    }?,
    empty
  }
titlePage =
  
  ## title page ―
  ##         Contains a transcription of the title page of a text. It may be used within the physDesc
  ##         element when no other transcription is provided. This element is modelled on an element in
  ##         Encoded Archival Description (EAD).
  element titlePage {
    (model.textcomponentLike | model.milestoneLike.text)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
att.regularmethod.attributes = att.regularmethod.attribute.method
att.regularmethod.attribute.method =
  
  ## indicates the
  ##           method employed to mark corrections and normalizations.
  attribute method {
    
    ## corrections
    ##             and normalizations made silently
    "silent"
    | 
      ## corrections
      ##             and normalizations indicated using elements
      "tags"
  }?
model.editorialDeclPart =
  correction | interpretation | normalization | segmentation | stdVals
model.encodingPart_sequenceOptional =
  appInfo?, editorialDecl?, projectDesc?, samplingDecl?
model.frontPart = titlePage
model.frontPart_alternation = titlePage
model.frontPart_sequence = titlePage
model.frontPart_sequenceOptional = titlePage?
model.frontPart_sequenceOptionalRepeatable = titlePage*
model.frontPart_sequenceRepeatable = titlePage+
model.headerPart_sequenceOptional = encodingDesc?, workDesc?
model.physDescPart =
  model.repositoryLike
  | model.frontPart
  | condition
  | dimensions
  | exhibHist
  | extent
  | handList
  | inscription
  | physLoc
  | physMedium
  | plateNum
  | provenance
  | treatHist
  | treatSched
  | watermark
model.pubStmtPart =
  model.addressLike
  | model.dateLike
  | model.identifierLike
  | availability
  | respStmt
  | model.nameLike.geogName
meiHead =
  
  ## mei header ― A
  ##         wrapper for general bibliographic and descriptive information about the encoded file. This
  ##         information is often essential in a machine-readable environment. Five sub-elements must be
  ##         encoded in the following order: <altId>(optional), <fileDesc>(required),
  ##         <encodingDesc>(optional), <workDesc;>(optional), and
  ##         <revisionDesc>(optional). These elements and their sub-elements provide: a unique
  ##         identifier for the MEI file, bibliographic information about the MEI file and its sources,
  ##         information about the encoding process, information about the creation of the work being
  ##         encoded, and statements regarding significant revisions of the file. The xml:lang attribute
  ##         may be used to indicate the language in which the metadata content of the header is
  ##         provided. In order to encourage uniformity in the provision of metadata across document
  ##         types, this element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element meiHead {
    altId*,
    fileDesc,
    model.headerPart_sequenceOptional,
    revisionDesc?,
    att.bibl.attributes,
    att.common.attributes,
    att.lang.attributes,
    att.meiversion.attributes,
    
    ## specifies
    ##             the kind of document to which the header is attached, for example whether it is a corpus
    ##             or individual text.
    attribute type {
      
      ## header is
      ##               attached to a music document
      "music"
      | 
        ## header is
        ##               attached to a corpus
        "corpus"
    }?,
    empty
  }
accessRestrict =
  
  ## access
  ##         restriction ― Describes the conditions that affect the accessibility of material. May
  ##         indicate the nature of restrictions or the lack of restrictions. Do not confuse this element
  ##         with <useRestrict> (usage restrictions), which captures information about limitations
  ##         on the use of material, such as those afforded by copyright. This element is modelled on an
  ##         element in Encoded Archival Description (EAD).
  element accessRestrict {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
acqSource =
  
  ## acquisition
  ##         source ― Post-publication source, such as a vendor or distributor, from which access to a
  ##         bibliographic item may be obtained, including electronic access. This element is modelled on
  ##         an element in Encoded Archival Description (EAD).
  element acqSource {
    (text | model.textphraseLike.limited)*,
    att.bibl.attributes,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
altId =
  
  ## alternative
  ##         identifier ― May contain a bibliographic identifier that does not fit within the meiHead
  ##         element's id attribute, for example because the id does not fit the definition of an XML id
  ##         or because multiple identifiers are needed. One or the other of <altId> or the id
  ##         attribute on <mei> is required when applicable.
  element altId {
    (text | model.textphraseLike.limited)*,
    att.bibl.attributes,
    att.common.attributes,
    att.typed.attributes,
    empty
  }
appInfo =
  
  ## application
  ##         information ― Groups information about applications which have acted upon the MEI file. This
  ##         is not to be confused with applications which were used to create the MEI file. The latter
  ##         may be recorded in the projectDesc element. This element is modelled on an element in the
  ##         Text Encoding Initiative (TEI).
  element appInfo { application*, att.common.attributes, empty }
application =
  
  ## application ―
  ##         Provides information about an application which has acted upon the current document. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element application {
    model.nameLike+,
    (model.locrefLike* | model.pLike*),
    att.common.attributes,
    att.datable.attributes,
    att.typed.attributes,
    
    ## supplies a
    ##             version number for an application, independent of its identifier or display
    ##             name.
    attribute version { text }?,
    empty
  }
availability =
  
  ## availability ―
  ##         Groups elements that describe the availability of and access to a bibliographic item. When
  ##         used within the fileDesc element, availability indicates access to the MEI-encoded document
  ##         itself. This element is modelled on an element in Encoded Archival Description
  ##         (EAD).
  element availability {
    macro.availabilityPart,
    att.bibl.attributes,
    att.common.attributes,
    att.datapointing.attributes,
    empty
  }
change =
  
  ## change ―
  ##         Individual change within the revision description. Additions, deletions, and significant
  ##         recoding should be noted, but not correction of minor typographical errors. It is
  ##         recommended that revisions should be entered in reverse chronological order, with the most
  ##         recent <change> first. The resp attribute contains a pointer to an element containing
  ##         info about the person/entity responsible for change. The edition element can be used to
  ##         designate an MEI encoding that has been so substantively changed that it constitutes a new
  ##         version that supersedes earlier versions. This element is modelled on an element in Encoded
  ##         Archival Description (EAD).
  element change {
    respStmt,
    changeDesc,
    model.dateLike,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
changeDesc =
  
  ## change
  ##         description ― Description of a revision of the MEI file.
  element changeDesc {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
classCode =
  
  ## classification
  ##         code ― Holds a citation to the source of controlled-vocabulary terms used in the
  ##         <termList> element; for example, Library of Congress Subject Headings (LCSH), Library
  ##         of Congress Classification (LCC), Library of Congress Name Authority File (LCNAF), or other
  ##         thesaurus or ontology. The citation may be provided in the authority attribute or as textual
  ##         content of the element when additional markup is needed.
  element classCode {
    (text | model.lbLike | model.rendLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.bibl.attributes,
    empty
  }
classification =
  
  ## classification
  ##         ― Groups information which describes the nature or topic of an entity. Although use of names
  ##         and terms from locally controlled vocabularies is possible, terms used here should come from
  ##         standard national or international vocabularies whenever they are available in order to
  ##         enable searches in systems that include multiple MEI documents, or MEI documents and
  ##         bibliographic records from many institutions.
  element classification {
    (classCode | termList)+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    empty
  }
condition =
  
  ## condition ― The
  ##         physical condition of an item, particularly any variances between the physical makeup of the
  ##         item and that of other copies of the same item (e.g., missing pages, plates, etc.).
  ##         Condition may reflect other aspects of the physical condition of the item as well (e.g.,
  ##         brittleness, faded images, etc.). This element is modelled on an element in Encoded Archival
  ##         Description (EAD).
  element condition {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
correction =
  
  ## correction ―
  ##         States how and under what circumstances corrections have been made in the text. This element
  ##         is modelled on an element in the Text Encoding Initiative (TEI).
  element correction {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    att.regularmethod.attributes,
    
    ## indicates
    ##             the degree of correction applied to the text.
    attribute corrlevel {
      
      ## the text
      ##               has been thoroughly checked and proofread
      "high"
      | 
        ## the text
        ##               has been checked at least once
        "medium"
      | 
        ## the text
        ##               has not been checked
        "low"
      | 
        ## the
        ##               correction status of the text is unknown
        "unknown"
    }?,
    empty
  }
contents =
  
  ## contents ―
  ##         description of the material contained within a resource.
  element contents {
    model.headLike?,
    (model.pLike? | (model.labelLike?, contentItem)+),
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
contentItem =
  
  ## content item ―
  ##         Contains a single entry within a content description element.
  element contentItem {
    text*, att.bibl.attributes, att.common.attributes, empty
  }
creation =
  
  ## creation ―
  ##         Non-bibliographic creation details for the work being encoded, in narrative form. Contains
  ##         phrases describing the origin of the text, e.g. the date, place, and circumstances of its
  ##         composition. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element creation {
    (text | date | geogName)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
dimensions =
  
  ## dimensions ―
  ##         Information about the physical size of a bibliographic source; usually includes numerical
  ##         data. There are no height and width sub-elements; however, num sub-elements may be used with
  ##         appropriate n attribute values. Measurements may be expressed in any convenient unit. Do not
  ##         confuse this element with the <extent> element, which is used to indicate the quantity
  ##         of described materials. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element dimensions {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.measurement.attributes,
    empty
  }
editionStmt =
  
  ## edition
  ##         statement ― Container for meta-data pertaining to a particular edition of the material being
  ##         described. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element editionStmt {
    (model.editionLike, respStmt*)+,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
editorialDecl =
  
  ## editorial
  ##         declaration ― Used to provide details of editorial principles and practices applied during
  ##         the encoding of musical text. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element editorialDecl {
    (model.pLike+ | (model.editorialDeclPart+, model.pLike*)),
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
encodingDesc =
  
  ## encoding
  ##         description ― Documents the relationship between an electronic file and the source or
  ##         sources from which it was derived as well as applications used in the encoding/editing
  ##         process. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element encodingDesc {
    model.encodingPart_sequenceOptional,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
ensemble =
  
  ## ensemble ― Used
  ##         when an ensemble, such as an orchestra, is included in the performing forces of a
  ##         composition. It is recommended that name values (recorded in the reg attribute or in the
  ##         element's content) be taken from a standardized list, such as the International Association
  ##         of Music Libraries' Medium of performance Codes List or the MARC Instruments and Voices Code
  ##         List.
  element ensemble {
    instrVoice,
    role?,
    performer*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
exhibHist =
  
  ## exhibition
  ##         history ― A record of public exhibitions, including dates, venues, etc. This element is
  ##         modelled on an element in Encoded Archival Description (EAD).
  element exhibHist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
extent =
  
  ## extent ― Used
  ##         to express size in terms other than physical dimensions, such as number of pages, number of
  ##         records in file, number of bytes, performance duration for music, audio recordings and
  ##         visual projections, etc. Use the <dimensions> element when it is necessary to specify
  ##         the physical size of materials being described, for example, height and width. This element
  ##         is modelled on an element in the Text Encoding Initiative (TEI).
  element extent {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.measurement.attributes,
    empty
  }
fileDesc =
  
  ## file
  ##         description ― Contains a full bibliographic description of the MEI file. Extent in this
  ##         context is file size. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element fileDesc {
    titleStmt,
    editionStmt?,
    extent?,
    fingerprint?,
    pubStmt,
    seriesStmt?,
    notesStmt?,
    sourceDesc?,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
fingerprint =
  
  ## fingerprint ―
  ##         Traditionally, an identifier, constructed by combining groups of characters transcribed from
  ##         specified pages of a printed item, which makes it possible to signal differences between
  ##         copies of the item. For an electronic item, such as an MEI file, however, the fingerprint
  ##         should be a checksum.
  element fingerprint {
    text, att.common.attributes, att.lang.attributes, empty
  }
hand =
  
  ## hand ― Defines
  ##         a distinct scribe or handwriting style. The initial attribute indicates whether this is the
  ##         first or main scribe of the document. The medium attribute describes the writing medium,
  ##         e.g., 'pencil', or the tint or type of ink, e.g. 'brown'. The resp attribute contains an ID
  ##         reference to an element containing the name of the editor or transcriber responsible for
  ##         identifying the hand. The characteristics of the hand, particularly those related to the
  ##         quality of the writing, such as 'shaky', 'thick', etc. may be described within the content
  ##         of the hand element. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element hand {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.medium.attributes,
    att.responsibility.attributes,
    
    ## marks this
    ##             hand as the first one of the document.
    attribute initial { data.BOOLEAN }?,
    empty
  }
handList =
  
  ## hand list ―
  ##         Container for one or more hand elements. This element is modelled on an element in the Text
  ##         Encoding Initiative (TEI).
  element handList {
    hand+, att.common.attributes, att.bibl.attributes, empty
  }
history =
  
  ## history ―
  ##         History provides a container for information about the creation and history of a
  ##         resource.
  element history {
    model.headLike?,
    creation?,
    (eventList | p)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
incipCode =
  
  ## incipit code ―
  ##         Incipit coded in a non-XML, plain text format, such as Plaine & Easie
  ##         Code.
  element incipCode {
    text
    >> sch:pattern [
         id = "incipCode-constraint-Check_incipCode_form_mimetype"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:incipCode"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@form or @mimetype"
             "incipCode must have a form or mimetype\x{a}" ~
             "            attribute."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.bibl.attributes,
    att.internetmedia.attributes,
    
    ## identifies
    ##             the language of the element's content. The values for this attribute are language 'tags'
    ##             as defined in BCP 47. All language tags that make use of private use sub-tags must be
    ##             documented in a corresponding language element in the MEI header whose id attribute is
    ##             the same as the language tag's value.
    attribute xml:space {
      
      ## allows
      ##               the application to handle white space as necessary. Not including an xml:space
      ##               attribute produces the same result as using the default value.
      "default"
      | 
        ## instructs
        ##               the application to maintain white space as is, suggesting that it might have
        ##               meaning.
        "preserve"
    }?,
    
    ## describes
    ##             the notational form of the coded text Suggested values include: 1] plaineAndEasie; 2]
    ##             humdrumKern
    attribute form {
      
      ## Plaine
      ##               & Easie Code
      "plaineAndEasie"
      | 
        ## Humdrum
        ##               Kern format
        "humdrumKern"
      | xsd:Name
    }?,
    empty
  }
incipText =
  
  ## incipit text ―
  ##         The opening words of a musical composition.
  element incipText {
    (model.pLike | model.lgLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    att.internetmedia.attributes,
    empty
  }
inscription =
  
  ## inscription ―
  ##         An inscription added to an item, such as a bookplate, a note designating the item as a gift,
  ##         and/or the author's signature.
  element inscription {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
instrVoice =
  
  ## instrument or
  ##         voice ― Name of an ensemble, an instrument on which a performer plays, or a performer's
  ##         voice range designation.
  element instrVoice {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    att.regularized.attributes,
    
    ## indicates
    ##             the number of parts or performers, e.g., in a composition for 2
    ##             flutes.
    attribute count { xsd:positiveInteger }?,
    
    ## marks this
    ##             instrument or vocal part as a soloist. Do not use this attribute for a solo instrument
    ##             which is not accompanied.
    attribute solo { data.BOOLEAN }?,
    empty
  }
interpretation =
  
  ## interpretation
  ##         ― Describes the scope of any analytic or interpretive information added to the transcription
  ##         of the music. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element interpretation {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
key =
  
  ## key ― Key
  ##         captures information about tonal center and mode. It is used exclusively within
  ##         bibliographic descriptions. Do not confuse this element with <keySig>, which is used
  ##         within the body of an MEI file to record this data.
  element key {
    text,
    att.common.attributes,
    att.bibl.attributes,
    att.accidental.attributes,
    att.pitch.attributes,
    
    ## indicates
    ##             major, minor, or other tonality.
    attribute mode { data.MODE }?,
    empty
  }
meter =
  
  ## meter ―
  ##         Captures information about the time signature. It is used exclusively within bibliographic
  ##         descriptions. Do not confuse this element with the attributes used by staffDef and scoreDef
  ##         to record this data within the body of an MEI file.
  element meter {
    empty, att.meters.log.attributes, att.meters.vis.attributes, empty
  }
termList =
  
  ## termList ―
  ##         Collection of text phrases which describe a work or source document.
  element termList {
    term+,
    att.common.attributes,
    att.bibl.attributes,
    
    ## contains a
    ##             reference to the controlled vocabulary from which the terms are drawn. The value must
    ##             match the value of an ID attribute on a classCode element given elsewhere in the
    ##             document.
    attribute classcode { data.URI }?,
    empty
  }
language =
  
  ## language ―
  ##         Description of a language used in the document. A text element may be related to this
  ##         element via its xml:lang attribute, which normally takes the form of a code, drawn from a
  ##         coded list, such as ISO639-2b. The name and web location of the authorizing list may be
  ##         encoded in the authority attribute and the authURI attribute, respectively. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element language {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    empty
  }
langUsage =
  
  ## language usage
  ##         ― langUsage groups elements describing the languages, sub-languages, dialects, etc.,
  ##         represented within the encoded work. This element is modelled on an element in the Text
  ##         Encoding Initiative (TEI).
  element langUsage {
    language+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    empty
  }
normalization =
  
  ## normalization ―
  ##         Indicates the extent of normalization or regularization of the original source carried out
  ##         in converting it to electronic form. This element is modelled on an element in the Text
  ##         Encoding Initiative (TEI).
  element normalization {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    att.regularmethod.attributes,
    empty
  }
notesStmt =
  
  ## notes statement
  ##         ― Collects together any notes providing information about a text additional to that recorded
  ##         in other parts of the bibliographic description. This element is modelled on an element in
  ##         the Text Encoding Initiative (TEI).
  element notesStmt {
    model.annotLike+, att.common.attributes, att.bibl.attributes, empty
  }
perfMedium =
  
  ## performance
  ##         medium ― Indicates the number and character of the performing forces used in a musical
  ##         composition. The function of instrumentalists or vocalists is represented by the choice of
  ##         ensemble and performer child elements. Arrangements are coded for the medium of the work
  ##         being described, not for the original medium.
  element perfMedium {
    head?,
    (ensemble | performer)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    empty
  }
performer =
  
  ## performer ―
  ##         Used when performing forces includes specific instrumental or vocal performers. All
  ##         instruments and roles for a single performer can be included. However, in AACR2 the
  ##         following restrictions apply: if the performer plays more than one instrument in a
  ##         composition, the first named instrument is given. If a principal instrument can be
  ##         determined, the name or code for that instrument is given. For percussion music, whether for
  ##         a single performer or more than one, the number of performers is given, rather than the
  ##         number of instruments. For monologues, or works with narration, an indication of unspecified
  ##         voice is given for the speaker or narrator.
  element performer {
    instrVoice+,
    role*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
physDesc =
  
  ## physical
  ##         description ― Container for information about the location, appearance, construction, or
  ##         handling of physical materials, such as their dimension, quantity, color, style, and
  ##         technique of creation. Dedicatory text and title page features may also be encoded here when
  ##         they are not transcribed as part of the front or back matter; i.e., when they are considered
  ##         to be meta-data rather than a transcription. This element is modelled on an element in
  ##         Encoded Archival Description (EAD).
  element physDesc {
    model.physDescPart+,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
physLoc =
  
  ## physical
  ##         location ― Location of the source within a repository, e.g., shelf mark or other locational
  ##         information. This element is modelled on an element in Encoded Archival Description
  ##         (EAD).
  element physLoc {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
physMedium =
  
  ## physical medium
  ##         ― Records the physical materials used in the source, such as ink and paper. All materials
  ##         may be described in a single <physMedium> element or multiple elements may be used,
  ##         one for each medium. This element is modelled on an element in Encoded Archival Description
  ##         (EAD).
  element physMedium {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.authorized.attributes,
    att.lang.attributes,
    empty
  }
plateNum =
  
  ## plate number ―
  ##         Designation assigned to a resource by a music publisher, usually printed at the bottom of
  ##         each page, and sometimes appearing also on the title page. While it is often called a "plate
  ##         number", it does not always contain numbers. The facs attribute may be used to record the
  ##         location of the plate number in a facsimile image.
  element plateNum {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
price =
  
  ## price ― The
  ##         cost of access to a bibliographic item.
  element price {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.measurement.attributes,
    empty
  }
projectDesc =
  
  ## project
  ##         description ― Project-level meta-data describing the aim or purpose for which the electronic
  ##         file was encoded, funding agencies, etc. together with any other relevant information
  ##         concerning the process by which it was assembled or collected. This element is modelled on
  ##         an element in the Text Encoding Initiative (TEI).
  element projectDesc {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
provenance =
  
  ## provenance ―
  ##         The record of ownership or custodianship of an item. This element is modelled on an element
  ##         in the Encoded Archival Description (EAD) and Text Encoding Initiative
  ##         (TEI).
  element provenance {
    (eventList? | (text | model.textphraseLike.limited)*),
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
pubStmt =
  
  ## publication
  ##         statement ― Container for information regarding the publication or distribution of a
  ##         bibliographic item, including the publisher's name and address, the date of publication, and
  ##         other relevant details. When an item is unpublished, use only the <unpub> sub-element.
  ##         This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element pubStmt {
    (unpub? | model.pubStmtPart*),
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
relatedItem =
  
  ## related item ―
  ##         contains or references another bibliographic item which is related to the present one in
  ##         some specified manner, for example as a constituent or alternative version of it. A URI for
  ##         the related item should be placed in the <identifier> sub-element. This element is
  ##         modelled on the relatedItem element in the Text Encoding Initiative (TEI) and MODS
  ##         schemas.
  element relatedItem {
    model.identifierLike*,
    titleStmt?,
    macro.bibldescPart,
    notesStmt?,
    macro.workPart,
    classification?,
    castList?,
    model.incipLike?,
    contents?,
    relatedItem*,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    
    ## describes
    ##             the relationship between the <relatedItem> and the resource described in the
    ##             parent element, i.e. <source> or <relatedItem>. "preceding" indicates a
    ##             predecessor to the resource; "succeeding" applies to a successor to the resource;
    ##             "original" indicates the original form of the resource; "host" provides info concerning
    ##             an intellectual or physical constituent unit of the resource; "otherVersion" indicates a
    ##             change in the intellectual content of the resource not significant enough to be a
    ##             different work; "otherFormat" indicates a change in physical format of the resource;
    ##             "isReferencedBy" applies to a citation or reference to published bibliographic
    ##             descriptions, reviews, abstracts, or indexes of the content of the resource;
    ##             "references" applies to a resource cited or referred to in the resource. These values
    ##             are based on MODS version 3.4.
    attribute rel {
      
      ##
      "preceding"
      | 
        ##
        "succeeding"
      | 
        ##
        "original"
      | 
        ##
        "host"
      | 
        ##
        "constituent"
      | 
        ##
        "otherVersion"
      | 
        ##
        "otherFormat"
      | 
        ##
        "isReferencedBy"
      | 
        ##
        "references"
    }?,
    empty
  }
resp =
  
  ## responsibility
  ##         ― A phrase describing the nature of a person's intellectual responsibility. The name of the
  ##         list from which a controlled value is taken may be recorded using the authority attribute.
  ##         This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element resp { text, att.authorized.attributes, empty }
respStmt =
  
  ## responsibility
  ##         statement ― Names one or more individuals, groups, or in rare cases, mechanical processes,
  ##         responsible for creation or realization of the intellectual or artistic content. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element respStmt {
    (resp | model.nameLike | model.nameLike.agent)*,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
revisionDesc =
  
  ## revision
  ##         description ― Container for information about alterations that have been made to an MEI
  ##         file. It is recommended that changes be recorded in reverse chronological order, with the
  ##         most recent alteration first. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element revisionDesc {
    change+, att.common.attributes, att.bibl.attributes, empty
  }
samplingDecl =
  
  ## sampling
  ##         declaration ― Contains a prose description of the rationale and methods used in sampling
  ##         texts in the creation of a corpus or collection. This element is modelled on an element in
  ##         the Text Encoding Initiative (TEI).
  element samplingDecl {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
segmentation =
  
  ## segmentation ―
  ##         Describes the principles according to which the musical text has been segmented, for example
  ##         into movements, sections, etc. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element segmentation {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
seriesStmt =
  
  ## series
  ##         statement ― Groups information about the series, if any, to which a publication belongs. In
  ##         this context, the <title> element records the series title, the <respStmt>
  ##         element records the person or group responsible for the series, and the <identifier>
  ##         element contains a series identifier. The <contents> element should be used when it is
  ##         necessary to enumerate the content of the series. The <seriesStmt> element is provided
  ##         within seriesStmt for the description of a sub-series. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element seriesStmt {
    model.titleLike+,
    respStmt*,
    model.identifierLike*,
    contents?,
    seriesStmt*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
source =
  
  ## source ― A
  ##         bibliographic description of a source used in the creation of the electronic file. Multiple
  ##         physDesc sub-elements may be used to describe the physically separate parts of a single
  ##         source. The data attribute may be used to reference one or more features that occur in this
  ##         particular source. A URI referencing a description of the related item may be placed in the
  ##         target attribute. This element is modelled on the sourceDesc element in the Text Encoding
  ##         Initiative (TEI).
  element source {
    model.identifierLike*,
    titleStmt?,
    macro.bibldescPart,
    notesStmt?,
    macro.workPart,
    classification?,
    castList?,
    model.incipLike?,
    contents?,
    relatedItem*,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    att.pointing.attributes,
    empty
  }
sourceDesc =
  
  ## source
  ##         description ― A container for the descriptions of the source(s) used in the creation of the
  ##         electronic file. This element is recommended where the MEI file is a transcription of
  ##         existing music, but is not required when the data is originally created in MEI
  ##         form.
  element sourceDesc { source+, att.common.attributes, empty }
stdVals =
  
  ## standard values
  ##         ― Specifies the format used when standardized date or number values are supplied. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element stdVals {
    model.pLike+,
    att.common.attributes,
    att.bibl.attributes,
    att.datapointing.attributes,
    att.lang.attributes,
    empty
  }
sysReq =
  
  ## system
  ##         requirements ― System requirements for using the electronic item.
  element sysReq {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.lang.attributes,
    empty
  }
term =
  
  ## term ― Single
  ##         keyword or phrase which describes the work. The classcode attribute may be used to link the
  ##         term to a terminological source given in a classCode element. The term element may include
  ##         other term elements in order to allow the creation of coordinated terms; i.e., terms created
  ##         from a combination of other, independent terms. This element is modelled on an element in
  ##         the Text Encoding Initiative (TEI).
  element term {
    (text | term | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    
    ## contains a
    ##             reference to the controlled vocabulary from which the term is drawn. The value must
    ##             match the value of an ID attribute on a classCode element given elsewhere in the
    ##             document.
    attribute classcode { data.URI }?,
    empty
  }
titleStmt =
  
  ## title statement
  ##         ― Container for title and responsibility meta-data. This element is modelled on an element
  ##         in the Text Encoding Initiative (TEI).
  element titleStmt {
    model.titleLike+,
    respStmt*,
    att.bibl.attributes,
    att.common.attributes,
    empty
  }
treatHist =
  
  ## treatment
  ##         history ― A record of the treatment the item has undergone (e.g., de-acidification,
  ##         restoration, etc.) Treatment history may also comprise details of the treatment process
  ##         (e.g., chemical solutions used, techniques applied, etc.), the date the treatment was
  ##         applied, etc. This element is modelled on an element in Encoded Archival Description
  ##         (EAD).
  element treatHist {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
treatSched =
  
  ## treatment
  ##         scheduled ― Scheduled treatment, e.g. de-acidification, restoration, etc., for an item. This
  ##         element is modelled on an element in Encoded Archival Description (EAD).
  element treatSched {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
unpub =
  
  ## unpublished ―
  ##         Used to explicitly indicate that a bibliographic source is unpublished. A short phrase
  ##         indicating the nature of or the reason for the unpublished status may be given as the
  ##         element's content.
  element unpub {
    text, att.common.attributes, att.bibl.attributes, empty
  }
useRestrict =
  
  ## usage
  ##         restrictions ― Container for information about the conditions that affect use of a
  ##         bibliographic item after access has been granted. It may indicate limitations imposed by an
  ##         owner, repository, or legal statute (for example, copyright law) regarding the reproduction,
  ##         publication, or quotation of the item. It may also indicate the absence of restrictions,
  ##         such as when rights have been ceded to the public domain. Do not confuse this element with
  ##         the <accessRestrict> element, which holds information about conditions affecting the
  ##         availability of the material. This element is modelled on an element in Encoded Archival
  ##         Description (EAD).
  element useRestrict {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
watermark =
  
  ## watermark ―
  ##         Contains a description of a watermark or similar device. The facs attribute may be used to
  ##         record the location of the watermark in a facsimile image. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element watermark {
    (text | model.textphraseLike.limited)*,
    att.common.attributes,
    att.bibl.attributes,
    att.facsimile.attributes,
    empty
  }
workDesc =
  
  ## work
  ##         description ― A container for description of the work(s) used in the creation of the
  ##         electronic file.
  element workDesc { work+, att.common.attributes, empty }
work =
  
  ##
  element work {
    model.identifierLike*,
    titleStmt?,
    macro.workPart,
    notesStmt?,
    classification?,
    castList?,
    model.incipLike?,
    contents?,
    relatedItem*,
    att.datapointing.attributes,
    att.common.attributes,
    att.bibl.attributes,
    empty
  }
eventList =
  
  ## event list ―
  ##         Contains historical information given as a sequence of significant past events.
  ##         <eventList> contains <event> elements that contain a brief description of the
  ##         associated event, including dates and locations where the event took place. An
  ##         <eventList> describes events associated with a work when it appears in the
  ##         <workDesc> element or events associated with the custodial history of a given copy of
  ##         a source for the encoding when it appears within the <source> or <relatedItem>
  ##         elements. The type attribute may be used to distinguish between event lists with different
  ##         functions, such as a list of events in the compositional process and a list of performance
  ##         dates.
  element eventList {
    model.headLike?,
    event+,
    att.bibl.attributes,
    att.common.attributes,
    att.typed.attributes,
    empty
  }
event =
  
  ## event ―
  ##         contains a description of an event, including the dates and locations of its occurrence and
  ##         prominent participants. When a single date can be associated with the event, the attributes
  ##         in the att.datable class may provide a more machine-processable alternative than date
  ##         elements within the content of <event>. <table> and <list> elements are
  ##         allowed within <event> in order to accommodate structured content.
  element event {
    ((text | model.textphraseLike.limited)*
     | (model.tableLike | model.listLike)*),
    att.bibl.attributes,
    att.calendared.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.lang.attributes,
    
    ## gives the
    ##             value of a date in standard ISO form.
    attribute reg { data.ISODATE }?,
    empty
  }
att.beamed.attributes = att.beamed.attribute.beam
att.beamed.attribute.beam =
  
  ## indicates
  ##           that this event is "under a beam".
  attribute beam { data.BEAMS }?
att.beamedwith.attributes = att.beamedwith.attribute.beam.with
att.beamedwith.attribute.beam.with =
  
  ## In the case
  ##           of cross-staff beams, the beam.with attribute is used to indicate which staff the beam is
  ##           connected to; that is, the staff above or the staff below.
  attribute beam.with { data.OTHERSTAFF }?
att.beaming.log.attributes =
  att.beaming.log.attribute.beam.group,
  att.beaming.log.attribute.beam.rests
att.beaming.log.attribute.beam.group =
  
  ## provides an
  ##           example of how automated beaming (including secondary beams) is to be performed. It can be
  ##           used to set a default beaming pattern to be used when no beaming is indicated at the event
  ##           level. beam.group must contain a comma-separated list of time values that add up to a
  ##           measure, e.g., in 4/4 time '4,4,4,4' indicates each quarter note worth of shorter notes
  ##           would be beamed together. Parentheses can be used to indicate sub-groupings of secondary
  ##           beams. For example, '(4.,4.,4.)' in 9/8 meter indicates one outer beam per measure with
  ##           secondary beams broken at each dotted quarter duration, while a measure of 16th notes in
  ##           4/4 with beam.group equal to '(4,4),(4,4)' will result in a primary beam covering all the
  ##           notes and secondary beams each group of 4 notes. This beaming "directive" can be
  ##           overridden by using <beam> elements. If neither <beam> elements or the
  ##           beam.group attribute is used, then no beaming is rendered. Beaming can be 'turned off' by
  ##           setting beam.group to an empty string.
  attribute beam.group { text }?
att.beaming.log.attribute.beam.rests =
  
  ## indicates
  ##           whether automatically-drawn beams should include rests shorter than a quarter note
  ##           duration.
  attribute beam.rests { data.BOOLEAN }?
att.beamrend.attributes =
  att.beamrend.attribute.rend, att.beamrend.attribute.slope
att.beamrend.attribute.rend =
  
  ## captures
  ##           whether a beam is "feathered" and in which direction.
  attribute rend {
    
    ## (accelerando) indicates that the secondary beams get progressively closer together
    ##             toward the end of the beam
    "acc"
    | 
      ## (ritardando) means that the secondary beams become progressively more distance toward
      ##             the end of the beam
      "rit"
    | 
      ## (normal)
      ##             indicates that the secondary beams are equidistant along the course of the
      ##             beam
      "norm"
  }?
att.beamrend.attribute.slope =
  
  ## records the
  ##           slope of the beam.
  attribute slope { xsd:decimal }?
att.beamsecondary.attributes = att.beamsecondary.attribute.breaksec
att.beamsecondary.attribute.breaksec =
  
  ## presence of
  ##           this attribute indicates that the secondary beam should be broken following this
  ##           note/chord. The value of the attribute records the number of beams which should remain
  ##           unbroken.
  attribute breaksec { xsd:positiveInteger }?
att.cutout.attributes = att.cutout.attribute.cutout
att.cutout.attribute.cutout =
  
  ## "Cut-out"
  ##           style indicated for this measure.
  attribute cutout {
    
    ## the staff
    ##             lines should not be drawn
    "cutout"
  }?
att.expandable.attributes = att.expandable.attribute.expand
att.expandable.attribute.expand =
  
  ## indicates
  ##           whether to render a repeat symbol or the source material to which it refers. A value of
  ##           'true' renders the source material, while 'false' displays the repeat
  ##           symbol.
  attribute expand { data.BOOLEAN }?
att.graced.attributes =
  att.graced.attribute.grace, att.graced.attribute.grace.time
att.graced.attribute.grace =
  
  ## marks a note
  ##           or chord as a "grace" (without a definitive written duration) and records from which other
  ##           note/chord it should "steal" time.
  attribute grace { data.GRACE }?
att.graced.attribute.grace.time =
  
  ## records the
  ##           amount of time to be "stolen" from a non-grace note/chord.
  attribute grace.time { data.PERCENT }?
att.lvpresent.attributes = att.lvpresent.attribute.lv
att.lvpresent.attribute.lv =
  
  ## indicates the
  ##           attachment of an l.v. (laissez vibrer) sign to this element.
  attribute lv { data.BOOLEAN }?
att.measure.vis.attributes =
  att.barplacement.attributes,
  att.measurement.attributes,
  att.width.attributes
att.numbered.attributes = att.numbered.attribute.num
att.numbered.attribute.num =
  
  ## along with
  ##           numbase, describes duration as a ratio. num is the first value in the ratio, while numbase
  ##           is the second.
  attribute num { xsd:positiveInteger }?
att.numberplacement.attributes =
  att.numberplacement.attribute.num.place,
  att.numberplacement.attribute.num.visible
att.numberplacement.attribute.num.place =
  
  ## states where
  ##           the tuplet number will be placed in relation to the note heads.
  attribute num.place { data.PLACE }?
att.numberplacement.attribute.num.visible =
  
  ## determines if
  ##           the tuplet number is visible.
  attribute num.visible { data.BOOLEAN }?
att.slurrend.attributes = att.slurrend.attribute.slur.rend
att.slurrend.attribute.slur.rend =
  
  ## describes the
  ##           line style of the slur.
  attribute slur.rend { data.CURVERENDITION }?
att.stemmed.cmn.attributes =
  att.stemmed.cmn.attribute.stem.mod,
  att.stemmed.cmn.attribute.stem.with
att.stemmed.cmn.attribute.stem.mod =
  
  ## encodes any
  ##           stem "modifiers"; that is, symbols rendered on the stem, such as tremolo or Sprechstimme
  ##           indicators.
  attribute stem.mod { data.STEMMODIFIER }?
att.stemmed.cmn.attribute.stem.with =
  
  ## contains an
  ##           indication of which staff a note or chord that logically belongs to the current staff
  ##           should be visually placed on; that is, the one above or the one below.
  attribute stem.with { data.OTHERSTAFF }?
att.tierend.attributes = att.tierend.attribute.tie.rend
att.tierend.attribute.tie.rend =
  
  ## describes the
  ##           line style of the tie
  attribute tie.rend { data.CURVERENDITION }?
att.arpeg.anl.attributes = att.common.anl.attributes
att.arpeg.ges.attributes = empty
att.arpeg.log.attributes =
  att.controlevent.attributes, att.arpeg.log.attribute.order
att.arpeg.log.attribute.order =
  
  ## describes the
  ##           direction in which an arpeggio is to be performed.
  attribute order {
    
    ## lowest to
    ##             highest pitch
    "up"
    | 
      ## highest to
      ##             lowest pitch
      "down"
    | 
      ## non-arpeggiated style (usually rendered with a preceding bracket instead of a wavy
      ##             line)
      "nonarp"
  }?
att.arpeg.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.arpeg.vis.attribute.arrow
att.arpeg.vis.attribute.arrow =
  
  ## indicates if
  ##           an arrowhead is to be drawn as part of the arpeggiation symbol.
  attribute arrow { data.BOOLEAN }?
att.beam.anl.attributes = att.common.anl.attributes
att.beam.ges.attributes = empty
att.beam.log.attributes =
  att.event.attributes, att.beamedwith.attributes
att.beam.vis.attributes = att.beamrend.attributes
att.beamSpan.anl.attributes = att.common.anl.attributes
att.beamSpan.ges.attributes = att.duration.performed.attributes
att.beamSpan.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.beamedwith.attributes,
  att.duration.musical.attributes
att.beamSpan.vis.attributes = att.beamrend.attributes
att.beatRpt.anl.attributes = att.common.anl.attributes
att.beatRpt.ges.attributes = empty
att.beatRpt.log.attributes = att.event.attributes
att.beatRpt.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.expandable.attributes,
  att.beatRpt.vis.attribute.rend
att.beatRpt.vis.attribute.rend =
  
  ## indicates the
  ##         number of slashes required to render the appropriate beat repeat symbol. When a single beat
  ##         is repeated, consisting of a single note or chord, it is indicated by a single thick,
  ##         slanting slash; therefore, the value '1' should be used. The following values should be used
  ##         when the beat is divided into even notes: 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4,
  ##         128ths=5. When the beat is comprised of mixed duration values, the symbol is always rendered
  ##         as 2 slashes and 2 dots.
  attribute rend { data.BEATRPT.REND }
att.bend.anl.attributes = att.common.anl.attributes
att.bend.ges.attributes = att.bend.ges.attribute.amount
att.bend.ges.attribute.amount =
  
  ## records the
  ##           amount of detuning. The decimal values should be rendered as a fraction (or an integer
  ##           plus a fraction) along with the bend symbol.
  attribute amount { data.BEND.AMOUNT }?
att.bend.log.attributes =
  att.controlevent.attributes, att.startendid.attributes
att.bend.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.breath.anl.attributes = att.common.anl.attributes
att.breath.ges.attributes = empty
att.breath.log.attributes =
  att.controlevent.attributes, att.startendid.attributes
att.breath.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.bTrem.anl.attributes = att.common.anl.attributes
att.bTrem.ges.attributes = empty
att.bTrem.log.attributes =
  att.event.attributes,
  att.numbered.attributes,
  att.slashcount.attributes,
  att.bTrem.log.attribute.form
att.bTrem.log.attribute.form =
  
  ## describes the
  ##           style of the tremolo.
  attribute form {
    
    ## measured
    ##             tremolo
    "meas"
    | 
      ## unmeasured
      ##             tremolo
      "unmeas"
  }?
att.bTrem.vis.attributes = att.numberplacement.attributes
att.chord.ges.cmn.attributes = att.graced.attributes
att.chord.log.cmn.attributes =
  att.beamed.attributes, att.lvpresent.attributes
att.chord.vis.cmn.attributes = att.beamsecondary.attributes
att.fermata.anl.attributes = att.common.anl.attributes
att.fermata.ges.attributes = att.duration.performed.attributes
att.fermata.log.attributes =
  att.controlevent.attributes, att.startendid.attributes
att.fermata.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes,
  att.fermata.vis.attribute.form,
  att.fermata.vis.attribute.shape
att.fermata.vis.attribute.form =
  
  ## describes the
  ##           visual appearance of the fermata; that is, whether it occurs as upright or
  ##           inverted.
  attribute form {
    
    ## inverted,
    ##             i.e., curve or bracket below the dot
    "inv"
    | 
      ## upright;
      ##             i.e., curve or bracket above the dot
      "norm"
  }?
att.fermata.vis.attribute.shape =
  
  ## describes the
  ##           visual appearance of the fermata; that is, whether it has a curved or square
  ##           shape.
  attribute shape {
    
    ## a curve
    ##             above or below the dot
    "curved"
    | 
      ## a bracket
      ##             above or below the dot
      "square"
  }?
att.fTrem.anl.attributes = att.common.anl.attributes
att.fTrem.ges.attributes = att.fTrem.ges.attribute.form
att.fTrem.ges.attribute.form =
  
  ## describes the
  ##           style of the tremolo.
  attribute form {
    
    ## measured
    ##             tremolo
    "meas"
    | 
      ## unmeasured
      ##             tremolo
      "unmeas"
  }?
att.fTrem.log.attributes = att.event.attributes
att.fTrem.vis.attributes = att.slashcount.attributes
att.gliss.anl.attributes = att.common.anl.attributes
att.gliss.ges.attributes = empty
att.gliss.log.attributes =
  att.controlevent.attributes, att.startendid.attributes
att.gliss.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.linerend.attributes,
  att.gliss.vis.attribute.text
att.gliss.vis.attribute.text =
  
  ## records a
  ##           text string, such as 'gliss', that accompanies the glissando mark.
  attribute text { text }?
att.hairpin.anl.attributes = att.common.anl.attributes
att.hairpin.ges.attributes = att.duration.performed.attributes
att.hairpin.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes,
  att.hairpin.log.attribute.form
att.hairpin.log.attribute.form =
  
  ## captures the
  ##         visual rendition and function of the hairpin; that is, whether it indicates an increase or a
  ##         decrease in volume.
  attribute form {
    
    ## crescendo;
    ##           i.e., louder
    "cres"
    | 
      ## diminuendo;
      ##           i.e., softer
      "dim"
  }
att.hairpin.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.hairpin.vis.attribute.opening
att.hairpin.vis.attribute.opening =
  
  ## specifies the
  ##           distance between the points of the open end of a hairpin dynamic mark.
  attribute opening { data.INTERLINE }?
att.halfmRpt.anl.attributes = att.common.anl.attributes
att.halfmRpt.ges.attributes = empty
att.halfmRpt.log.attributes =
  att.event.attributes, att.duration.musical.attributes
att.halfmRpt.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.expandable.attributes,
  att.visualoffset.attributes
att.harpPedal.anl.attributes = att.common.anl.attributes
att.harpPedal.ges.attributes = att.duration.performed.attributes
att.harpPedal.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.harpPedal.log.attribute.c,
  att.harpPedal.log.attribute.d,
  att.harpPedal.log.attribute.e,
  att.harpPedal.log.attribute.f,
  att.harpPedal.log.attribute.g,
  att.harpPedal.log.attribute.a,
  att.harpPedal.log.attribute.b
att.harpPedal.log.attribute.c =
  
  ## indicates the pedal setting for the harp's C strings.
  [ a:defaultValue = "n" ]
  attribute c {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.d =
  
  ## indicates the pedal setting for the harp's D strings.
  [ a:defaultValue = "n" ]
  attribute d {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.e =
  
  ## indicates the pedal setting for the harp's E strings.
  [ a:defaultValue = "n" ]
  attribute e {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.f =
  
  ## indicates the pedal setting for the harp's F strings.
  [ a:defaultValue = "n" ]
  attribute f {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.g =
  
  ## indicates the pedal setting for the harp's G strings.
  [ a:defaultValue = "n" ]
  attribute g {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.a =
  
  ## indicates the pedal setting for the harp's A strings.
  [ a:defaultValue = "n" ]
  attribute a {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.log.attribute.b =
  
  ## indicates the pedal setting for the harp's B strings.
  [ a:defaultValue = "n" ]
  attribute b {
    
    ## flat
    "f"
    | 
      ## natural
      "n"
    | 
      ## sharp
      "s"
  }?
att.harpPedal.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.layerDef.log.cmn.attributes = att.beaming.log.attributes
att.mRest.anl.attributes = att.common.anl.attributes
att.mRest.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.mRest.log.attributes =
  att.event.attributes,
  att.fermatapresent.attributes,
  att.duration.musical.attributes
att.mRest.vis.attributes =
  att.altsym.attributes,
  att.cutout.attributes,
  att.visualoffset.attributes,
  att.visibility.attributes,
  att.xy.attributes,
  att.relativesize.attributes
att.mRpt.anl.attributes = att.common.anl.attributes
att.mRpt.ges.attributes = empty
att.mRpt.log.attributes = att.event.attributes
att.mRpt.vis.attributes =
  att.altsym.attributes, att.color.attributes, att.expandable.attributes
att.mRpt2.anl.attributes = att.common.anl.attributes
att.mRpt2.ges.attributes = empty
att.mRpt2.log.attributes = att.event.attributes
att.mRpt2.vis.attributes =
  att.altsym.attributes, att.color.attributes, att.expandable.attributes
att.mSpace.anl.attributes = att.common.anl.attributes
att.mSpace.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.mSpace.log.attributes =
  att.event.attributes,
  att.fermatapresent.attributes,
  att.duration.musical.attributes
att.mSpace.vis.attributes =
  att.altsym.attributes,
  att.cutout.attributes,
  att.visibility.attributes,
  att.xy.attributes
att.multiRest.anl.attributes = att.common.anl.attributes
att.multiRest.ges.attributes =
  att.duration.performed.attributes, att.instrumentident.attributes
att.multiRest.log.attributes =
  att.event.attributes, att.numbered.attributes
att.multiRest.vis.attributes =
  att.altsym.attributes, att.multiRest.vis.attribute.block
att.multiRest.vis.attribute.block =
  
  ## When the
  ##           block attribute is used, combinations of the 1, 2, and 4 measure rest forms (Read, p. 104)
  ##           should be rendered instead of the modern form or an alternative symbol.
  attribute block { data.BOOLEAN }?
att.multiRpt.anl.attributes = att.common.anl.attributes
att.multiRpt.ges.attributes = empty
att.multiRpt.log.attributes =
  att.event.attributes, att.numbered.attributes
att.multiRpt.vis.attributes =
  att.altsym.attributes, att.expandable.attributes
att.note.ges.cmn.attributes =
  att.graced.attributes, att.note.ges.cmn.attribute.gliss
att.note.ges.cmn.attribute.gliss =
  
  ## indicates
  ##           that this element participates in a glissando.
  attribute gliss { data.GLISSANDO }?
att.note.log.cmn.attributes =
  att.beamed.attributes, att.lvpresent.attributes
att.note.vis.cmn.attributes = att.beamsecondary.attributes
att.octave.anl.attributes = att.common.anl.attributes
att.octave.ges.attributes = att.duration.performed.attributes
att.octave.log.attributes =
  att.controlevent.attributes,
  att.octavedisplacement.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes,
  att.octave.log.attribute.coll
att.octave.log.attribute.coll =
  
  ## indicates
  ##           whether the octave displacement should be performed simultaneously with the written notes,
  ##           i.e., "coll' ottava". Unlike other octave signs which are indicated by broken lines, coll'
  ##           ottava typically uses an unbroken line or a series of longer broken lines, ending with a
  ##           short vertical stroke. See Read, p. 47-48.
  attribute coll {
    
    ## coll'
    ##             ottava (with the octave)
    "coll"
  }?
att.octave.vis.attributes =
  att.xy.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.linerend.attributes
att.ossia.anl.attributes = att.common.anl.attributes
att.ossia.ges.attributes = empty
att.ossia.log.attributes = empty
att.ossia.vis.attributes = empty
att.pedal.anl.attributes = att.common.anl.attributes
att.pedal.ges.attributes = empty
att.pedal.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.pedal.log.attribute.dir
att.pedal.log.attribute.dir =
  
  ## records the
  ##         position of the piano damper pedal.
  attribute dir {
    
    ## depress the
    ##           pedal
    "down"
    | 
      ## release the
      ##           pedal
      "up"
    | 
      ## half
      ##           pedal
      "half"
    | 
      ## depress then
      ##           immediately release the pedal
      "bounce"
  }
att.pedal.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.xy.attributes,
  att.visualoffset.attributes,
  att.pedal.vis.attribute.style
att.pedal.vis.attribute.style =
  
  ## determines
  ##           whether piano pedal marks should be rendered as lines or as terms.
  attribute style {
    
    ## continuous
    ##             line with start and end positions rendered by vertical bars and bounces shown by
    ##             upward-pointing "blips"
    "line"
    | 
      ## pedal down
      ##             and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered
      ##             with "* Ped."
      "pedstar"
    | 
      ## pedal up
      ##             and down indications same as with "pedstar", but bounce is rendered with "Ped."
      ##             only
      "altpedstar"
  }?
att.phrase.vis.cmn.attributes =
  att.curvature.attributes, att.curverend.attributes
att.pianopedals.attributes = att.pianopedals.attribute.pedal.style
att.pianopedals.attribute.pedal.style =
  
  ## determines
  ##           whether piano pedal marks should be rendered as lines or as terms.
  attribute pedal.style {
    
    ## continuous
    ##             line with start and end positions rendered by vertical bars and bounces shown by
    ##             upward-pointing "blips"
    "line"
    | 
      ## pedal down
      ##             and half pedal rendered with "Ped.", pedal up rendered by "*", pedal "bounce" rendered
      ##             with "* Ped."
      "pedstar"
    | 
      ## pedal up
      ##             and down indications same as with "pedstar", but bounce is rendered with "Ped."
      ##             only
      "altpedstar"
  }?
att.rehearsal.attributes = att.rehearsal.attribute.reh.enclose
att.rehearsal.attribute.reh.enclose =
  
  ## describes the
  ##           enclosing shape for rehearsal marks.
  attribute reh.enclose {
    
    ## enclosed by
    ##             box
    "box"
    | 
      ## enclosed by
      ##             circle
      "circle"
    | 
      ## no
      ##             enclosing shape
      "none"
  }?
att.reh.anl.attributes = att.common.anl.attributes
att.reh.ges.attributes = empty
att.reh.log.attributes =
  att.staffident.attributes,
  att.startid.attributes,
  att.timestamp.musical.attributes,
  att.timestamp.performed.attributes
att.reh.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.typography.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
att.rest.log.cmn.attributes = att.beamed.attributes
att.rest.vis.cmn.attributes = empty
att.scoreDef.log.cmn.attributes = att.beaming.log.attributes
att.scoreDef.vis.cmn.attributes =
  att.beaming.vis.attributes,
  att.pianopedals.attributes,
  att.rehearsal.attributes,
  att.slurrend.attributes,
  att.tierend.attributes,
  att.scoreDef.vis.cmn.attribute.grid.show
att.scoreDef.vis.cmn.attribute.grid.show =
  
  ## determines
  ##           whether to display guitar chord grids.
  attribute grid.show { data.BOOLEAN }?
att.slur.anl.attributes =
  att.common.anl.attributes, att.joined.attributes
att.slur.ges.attributes = att.duration.performed.attributes
att.slur.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes
att.slur.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.space.log.cmn.attributes = att.beamed.attributes
att.staffDef.log.cmn.attributes = att.beaming.log.attributes
att.staffDef.vis.cmn.attributes =
  att.beaming.vis.attributes,
  att.pianopedals.attributes,
  att.rehearsal.attributes,
  att.slurrend.attributes,
  att.tierend.attributes
att.tie.anl.attributes = att.common.anl.attributes
att.tie.ges.attributes = empty
att.tie.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes
att.tie.vis.attributes =
  att.color.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.attributes,
  att.xy.attributes,
  att.xy2.attributes,
  att.curvature.attributes,
  att.curverend.attributes
att.tuplet.anl.attributes = att.common.anl.attributes
att.tuplet.ges.attributes = att.duration.performed.attributes
att.tuplet.log.attributes =
  att.event.attributes,
  att.beamedwith.attributes,
  att.augmentdots.attributes,
  att.duration.ratio.attributes,
  att.startendid.attributes,
  att.tuplet.log.attribute.dur
att.tuplet.log.attribute.dur =
  
  ## records the
  ##           duration of the tuplet using the optionally dotted, relative durational values provided by
  ##           the data.DURATION datatype. When the tuplet duration is "irrational", @dur may contain
  ##           multiple, space-separated values that add up to the total duration. For unmeasured music,
  ##           use the attributes found in att.duration.ratio (num and numbase) to capture the tuplet's
  ##           duration instead of this attribute.
  attribute dur {
    list {
      xsd:token {
        pattern = "(long|breve|1|2|4|8|16|32|64|128|256|1024|2048)(\.)*"
      }+
    }
  }?
att.tuplet.vis.attributes =
  att.numberplacement.attributes,
  att.tuplet.vis.attribute.bracket.place,
  att.tuplet.vis.attribute.bracket.visible,
  att.tuplet.vis.attribute.dur.visible,
  att.tuplet.vis.attribute.num.format
att.tuplet.vis.attribute.bracket.place =
  
  ## used to state
  ##           where a tuplet bracket will be placed in relation to the note heads.
  attribute bracket.place { data.PLACE }?
att.tuplet.vis.attribute.bracket.visible =
  
  ## states
  ##           whether a bracket should be rendered with a tuplet.
  attribute bracket.visible { data.BOOLEAN }?
att.tuplet.vis.attribute.dur.visible =
  
  ## determines if
  ##           the tuplet duration is visible.
  attribute dur.visible { data.BOOLEAN }?
att.tuplet.vis.attribute.num.format =
  
  ## controls how
  ##           the num:numbase ratio is to be displayed.
  attribute num.format {
    
    ## only the
    ##             num attribute is displayed, e.g., '7'
    "count"
    | 
      ## both the
      ##             num and numbase attributes are displayed, e.g., '7:4'
      "ratio"
  }?
att.tupletSpan.anl.attributes = att.tuplet.anl.attributes
att.tupletSpan.ges.attributes = att.tuplet.ges.attributes
att.tupletSpan.log.attributes =
  att.controlevent.attributes,
  att.beamedwith.attributes,
  att.augmentdots.attributes,
  att.duration.ratio.attributes,
  att.startendid.attributes,
  att.tupletSpan.log.attribute.dur
att.tupletSpan.log.attribute.dur =
  
  ## records the
  ##           duration of the tuplet using the optionally dotted, relative durational values provided by
  ##           the data.DURATION datatype. When the tuplet duration is "irrational", a @dur may contain
  ##           multiple, space-separated values that add up to the total duration. For unmeasured music,
  ##           use the attributes found in att.duration.ratio (num and numbase) to capture the tuplet's
  ##           duration instead of this attribute.
  attribute dur {
    list {
      xsd:token {
        pattern = "(long|breve|1|2|4|8|16|32|64|128|256|1024|2048)(\.)*"
      }+
    }
  }?
att.tupletSpan.vis.attributes = att.tuplet.vis.attributes
model.controleventLike.cmn =
  arpeg
  | beamSpan
  | breath
  | fermata
  | hairpin
  | harpPedal
  | octave
  | pedal
  | reh
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn
model.controleventLike.cmn_alternation =
  arpeg
  | beamSpan
  | breath
  | fermata
  | hairpin
  | harpPedal
  | octave
  | pedal
  | reh
  | slur
  | tie
  | tupletSpan
  | model.ornamentLike.cmn_alternation
model.controleventLike.cmn_sequence =
  arpeg,
  beamSpan,
  breath,
  fermata,
  hairpin,
  harpPedal,
  octave,
  pedal,
  reh,
  slur,
  tie,
  tupletSpan,
  model.ornamentLike.cmn_sequence
model.controleventLike.cmn_sequenceOptional =
  arpeg?,
  beamSpan?,
  breath?,
  fermata?,
  hairpin?,
  harpPedal?,
  octave?,
  pedal?,
  reh?,
  slur?,
  tie?,
  tupletSpan?,
  model.ornamentLike.cmn_sequenceOptional?
model.controleventLike.cmn_sequenceOptionalRepeatable =
  arpeg*,
  beamSpan*,
  breath*,
  fermata*,
  hairpin*,
  harpPedal*,
  octave*,
  pedal*,
  reh*,
  slur*,
  tie*,
  tupletSpan*,
  model.ornamentLike.cmn_sequenceOptionalRepeatable*
model.controleventLike.cmn_sequenceRepeatable =
  arpeg+,
  beamSpan+,
  breath+,
  fermata+,
  hairpin+,
  harpPedal+,
  octave+,
  pedal+,
  reh+,
  slur+,
  tie+,
  tupletSpan+,
  model.ornamentLike.cmn_sequenceRepeatable+
model.layerPart.cmn = model.eventLike.measureFilling
model.layerPart.cmn_alternation =
  model.eventLike.measureFilling_alternation
model.layerPart.cmn_sequence = model.eventLike.measureFilling_sequence
model.layerPart.cmn_sequenceOptional =
  model.eventLike.measureFilling_sequenceOptional?
model.layerPart.cmn_sequenceOptionalRepeatable =
  model.eventLike.measureFilling_sequenceOptionalRepeatable*
model.layerPart.cmn_sequenceRepeatable =
  model.eventLike.measureFilling_sequenceRepeatable+
model.eventLike.cmn =
  beam | beatRpt | bend | bTrem | fTrem | gliss | halfmRpt | tuplet
model.eventLike.cmn_alternation =
  beam | beatRpt | bend | bTrem | fTrem | gliss | halfmRpt | tuplet
model.eventLike.cmn_sequence =
  beam, beatRpt, bend, bTrem, fTrem, gliss, halfmRpt, tuplet
model.eventLike.cmn_sequenceOptional =
  beam?, beatRpt?, bend?, bTrem?, fTrem?, gliss?, halfmRpt?, tuplet?
model.eventLike.cmn_sequenceOptionalRepeatable =
  beam*, beatRpt*, bend*, bTrem*, fTrem*, gliss*, halfmRpt*, tuplet*
model.eventLike.cmn_sequenceRepeatable =
  beam+, beatRpt+, bend+, bTrem+, fTrem+, gliss+, halfmRpt+, tuplet+
model.eventLike.measureFilling =
  mRest | mRpt | mRpt2 | mSpace | multiRest | multiRpt
model.eventLike.measureFilling_alternation =
  mRest | mRpt | mRpt2 | mSpace | multiRest | multiRpt
model.eventLike.measureFilling_sequence =
  mRest, mRpt, mRpt2, mSpace, multiRest, multiRpt
model.eventLike.measureFilling_sequenceOptional =
  mRest?, mRpt?, mRpt2?, mSpace?, multiRest?, multiRpt?
model.eventLike.measureFilling_sequenceOptionalRepeatable =
  mRest*, mRpt*, mRpt2*, mSpace*, multiRest*, multiRpt*
model.eventLike.measureFilling_sequenceRepeatable =
  mRest+, mRpt+, mRpt2+, mSpace+, multiRest+, multiRpt+
model.measureLike = measure
model.measureLike_alternation = measure
model.measureLike_sequence = measure
model.measureLike_sequenceOptional = measure?
model.measureLike_sequenceOptionalRepeatable = measure*
model.measureLike_sequenceRepeatable = measure+
model.measurePart =
  model.controleventLike
  | model.staffLike
  | model.ossiaLike
  | model.lyricsLike
  | model.midiLike
model.ossiaLike = ossia
model.ossiaLike_alternation = ossia
model.ossiaLike_sequence = ossia
model.ossiaLike_sequenceOptional = ossia?
model.ossiaLike_sequenceOptionalRepeatable = ossia*
model.ossiaLike_sequenceRepeatable = ossia+
model.sectionPart.cmn = model.measureLike
model.sectionPart.cmn_alternation = model.measureLike_alternation
model.sectionPart.cmn_sequence = model.measureLike_sequence
model.sectionPart.cmn_sequenceOptional =
  model.measureLike_sequenceOptional?
model.sectionPart.cmn_sequenceOptionalRepeatable =
  model.measureLike_sequenceOptionalRepeatable*
model.sectionPart.cmn_sequenceRepeatable =
  model.measureLike_sequenceRepeatable+
arpeg =
  
  ## arpeggiation ―
  ##         Indicates that the notes of a chord are to be performed successively rather than
  ##         simultaneously, usually from lowest to highest. Sometimes called a "roll". The modern symbol
  ##         is a vertical wavy line preceding the chord. When the notes of the chord are to be performed
  ##         from highest to lowest, an arrowhead may be added to the lower end of the line. Even though
  ##         it is redundant, an arrowhead is sometimes added to the upper end of the line for the sake
  ##         of consistency or when the direction of successive arpeggios alternates. In music for
  ##         keyboard instruments, sometimes a distinction is made between a single arpeggio in which
  ##         both hands play successively and simultaneous arpeggios in two hands. In the case of the
  ##         former, multiple values may be required in the staff and layer attributes. Arpeggios that do
  ##         not cross staves, but still involve more than one layer require multiple values for the
  ##         layer attribute.
  element arpeg {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.arpeg.log.attributes,
    att.arpeg.vis.attributes,
    att.arpeg.ges.attributes,
    att.arpeg.anl.attributes,
    empty
  }
beam =
  
  ## beam ― A
  ##         container for a series of explicitly beamed events that begins and ends entirely within a
  ##         measure. For beams that cross the bar line, use the beamSpan element. Secondary beams may be
  ##         broken explicitly using the breaksec attribute on the notes or chords under the beam.
  ##         Automated beaming, as opposed to explicitly marked beams, may be indicated for an entire
  ##         score, part or section by using the beam.group and beam.rests attributes on these
  ##         elements.
  element beam {
    (model.eventLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.beam.log.attributes,
    att.beam.vis.attributes,
    att.beam.ges.attributes,
    att.beam.anl.attributes,
    empty
  }
beamSpan =
  
  ## beam span ―
  ##         Alternative element for explicitly encoding beams which extend across bar lines. The
  ##         starting point of the beam may be indicated by either a tstamp, tstamp.ges, tstamp.real or
  ##         startid attribute, while the ending point may be recorded by either a dur, dur.ges or endid
  ##         attribute. It is a semantic error not to specify one starting and one ending type of
  ##         attribute.
  element beamSpan {
    empty
    >> sch:pattern [
         id =
           "beamSpan-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:beamSpan"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.beamSpan.log.attributes,
    att.beamSpan.vis.attributes,
    att.beamSpan.ges.attributes,
    att.beamSpan.anl.attributes,
    empty
  }
beatRpt =
  
  ## beat repeat ―
  ##         An indication that material on a preceding beat should be repeated. It is also used in
  ##         guitar or rhythm parts to indicate where chord changes occur. When these parts require
  ##         durations longer or shorter than a beat, however, note elements with appropriately-shaped
  ##         note heads should be employed.
  element beatRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.beatRpt.log.attributes,
    att.beatRpt.vis.attributes,
    att.beatRpt.ges.attributes,
    att.beatRpt.anl.attributes,
    empty
  }
bend =
  
  ## bend ― A
  ##         variation in pitch (often micro-tonal) upwards or downwards during the course of a note.
  ##         Typically, the performer attacks the note at "true" pitch, bends the intonation, then
  ##         returns to true pitch. The bend element can also be used for scoop, plop, falloff, and doit
  ##         performance effects. It should *not* be used for l.v. (laissez vibrer) indications. Precise
  ##         performance data that differs from the logical events in a measure may be recorded within
  ##         the bend element. The starting point of the bend may be indicated by either a tstamp,
  ##         tstamp.ges, tstamp.real or startid attribute. It is a semantic error not to specify a
  ##         starting attribute.
  element bend {
    ((note | rest | tuplet)*)
    >> sch:pattern [
         id =
           "bend-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:bend"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.bend.log.attributes,
    att.bend.vis.attributes,
    att.bend.ges.attributes,
    att.bend.anl.attributes,
    empty
  }
breath =
  
  ## breath mark ― A
  ##         indication of a point at which the performer on an instrument requiring breath (including
  ##         the voice) may breathe. It also may indicate a short pause or break for instruments *not*
  ##         requiring breath. Therefore, it often functions as a guide to phrasing. The usual sign for
  ##         the breath mark is a comma; however, other visual forms of the breath mark may be indicated
  ##         using the altsym attribute. The starting point of the breath mark may be indicated by either
  ##         a tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic error not to
  ##         specify a starting point attribute.
  element breath {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.breath.log.attributes,
    att.breath.vis.attributes,
    att.breath.ges.attributes,
    att.breath.anl.attributes,
    empty
  }
bTrem =
  
  ## bowed tremolo ―
  ##         A rapid alternation on a single pitch or chord. This element should also be used for wind
  ##         double and triple tonguing and for flutter tonguing when these are expressed as tremolandi.
  ##         For alternation between a pair of notes or chords, use the fTrem element. The num attribute
  ##         can be used to store a number to be rendered along with a tremolo. The slash attribute
  ##         indicates the number of slashes to be drawn. The number of slashes indicates the exact note
  ##         values in an aural rendition of measured tremolandi, i.e., 4ths or 8ths=1, 16ths=2, 32nds=3,
  ##         64ths=4, 128ths=5, 256ths=6. See Read, p. 393-394. The stem modifier (slash or z) must also
  ##         be explicitly set on the child <note> or <chord> element for a complete visual
  ##         representation. See Read, p. 394, ex. 23-21, line 5.
  element bTrem {
    (chord | note),
    att.common.attributes,
    att.facsimile.attributes,
    att.bTrem.log.attributes,
    att.bTrem.vis.attributes,
    att.bTrem.ges.attributes,
    att.bTrem.anl.attributes,
    empty
  }
fermata =
  
  ## fermata ― An
  ##         indication placed over a note or rest to indicate that it should be held longer than its
  ##         written value. May also occur over a bar line to indicate the end of a phrase or section.
  ##         Sometimes called a 'hold' or 'pause'. The <fermata> element is a specialized form of,
  ##         i.e., syntactic sugar for, dir/@type="fermata" with &ferm; or &uferm; as its PCDATA
  ##         content. The shape attribute may be used to record whether the fermata is curved or square.
  ##         Other visual forms of a fermata may be indicated via the altsym attribute. The starting
  ##         point of the fermata may be indicated by either a tstamp, tstamp.ges, tstamp.real or startid
  ##         attribute. It is a semantic error not to specify a starting point
  ##         attribute.
  element fermata {
    empty
    >> sch:pattern [
         id =
           "fermata-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:fermata"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                   @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.fermata.log.attributes,
    att.fermata.vis.attributes,
    att.fermata.ges.attributes,
    att.fermata.anl.attributes,
    empty
  }
fTrem =
  
  ## fingered
  ##         tremolo ― A rapid alternation between a pair of notes (or chords or perhaps between a note
  ##         and a chord) that are (usually) farther apart than a major second. For rapid alternation
  ##         between notes on the same pitch (bowed tremolo, double &amp; triple tonguing, and
  ##         flutter tonguing) use the <bTrem> element. The slash attribute records the number of
  ##         slashes required — 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5,
  ##         256ths=6.
  element fTrem {
    ((chord, (chord | note))
     | (note, (chord | note))),
    att.common.attributes,
    att.facsimile.attributes,
    att.fTrem.log.attributes,
    att.fTrem.vis.attributes,
    att.fTrem.ges.attributes,
    att.fTrem.anl.attributes,
    empty
  }
hairpin =
  
  ## hairpin ―
  ##         Indicates continuous dynamics expressed on the score as wedge-shaped graphics, e.g. < and
  ##         >. The starting point of the hairpin may be indicated by either a tstamp, tstamp.ges,
  ##         tstamp.real or startid attribute, while the ending point may be recorded by either a dur,
  ##         dur.ges or endid attribute. It is a semantic error not to specify one starting and one
  ##         ending type of attribute. Please note that the value of the dur attribute is not a true
  ##         duration, but rather a time stamp for the end point of the hairpin.
  element hairpin {
    empty
    >> sch:pattern [
         id =
           "hairpin-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:hairpin"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.hairpin.log.attributes,
    att.hairpin.vis.attributes,
    att.hairpin.ges.attributes,
    att.hairpin.anl.attributes,
    empty
  }
harpPedal =
  
  ## harp pedal ―
  ##         Harp pedal diagram. The starting point of the harp pedal diagram may be indicated by either
  ##         a tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic error not to
  ##         specify a starting point attribute.
  element harpPedal {
    empty
    >> sch:pattern [
         id =
           "harpPedal-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:harpPedal"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.harpPedal.log.attributes,
    att.harpPedal.vis.attributes,
    att.harpPedal.ges.attributes,
    att.harpPedal.anl.attributes,
    empty
  }
gliss =
  
  ## glissando ― A
  ##         continuous or sliding movement from one pitch to another, usually indicated by a straight or
  ##         wavy line. Commonly also called a 'slide'. The term 'glissando' is frequently used to
  ##         indicate both the case where distinct intermediate pitches are produced (as on the piano)
  ##         and the case where they are not (as on the trombone), though the latter is sometimes
  ##         referred to as 'portamento'. The visual appearance of the indicating line may be recorded in
  ##         the rend attribute. Precise performance data, that is, exact pitches, may be recorded within
  ##         the <gliss> element. The starting point of the glissando may be indicated by either a
  ##         tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic error not to specify
  ##         a starting point attribute.
  element gliss {
    ((note | rest | tuplet)*)
    >> sch:pattern [
         id =
           "gliss-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:gliss"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.gliss.log.attributes,
    att.gliss.vis.attributes,
    att.gliss.ges.attributes,
    att.gliss.anl.attributes,
    empty
  }
halfmRpt =
  
  ## half-measure
  ##         repeat ― A half-measure repeat in any meter.
  element halfmRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.halfmRpt.log.attributes,
    att.halfmRpt.vis.attributes,
    att.halfmRpt.ges.attributes,
    att.halfmRpt.anl.attributes,
    empty
  }
measure =
  
  ## measure ― "Unit
  ##         of musical time consisting of a fixed number of note-values of a given type, as determined
  ##         by the prevailing meter, and delimited in musical notation by two bar lines." (New Harvard
  ##         Dictionary of Music) In MEI, the measure element is a grouping mechanism for events and
  ##         control events. Pointing attributes make it possible to connect this element to other
  ##         internal or external entities, such as media objects or annotations.
  element measure {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.measurePart)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.measure.log.attributes,
    att.measure.vis.attributes,
    att.measure.ges.attributes,
    att.measure.anl.attributes,
    empty
  }
mRest =
  
  ## measure rest ―
  ##         Complete measure rest in any meter (Read, p. 97-98). Automatically-generated numbering of
  ##         consecutive measures of rest may be controlled via the multi.number attribute on the
  ##         scoreDef or staffDef elements.
  element mRest {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRest.log.attributes,
    att.mRest.vis.attributes,
    att.mRest.ges.attributes,
    att.mRest.anl.attributes,
    empty
  }
mRpt =
  
  ## measure repeat
  ##         ― An indication that the previous measure should be repeated. The automated numbering of
  ##         consecutive measures of rest may be controlled via the multi.number attribute on the
  ##         scoreDef or staffDef elements.
  element mRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRpt.log.attributes,
    att.mRpt.vis.attributes,
    att.mRpt.ges.attributes,
    att.mRpt.anl.attributes,
    empty
  }
mRpt2 =
  
  ## 2-measure
  ##         repeat ― An indication that the previous two measures should be repeated.
  element mRpt2 {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mRpt2.log.attributes,
    att.mRpt2.vis.attributes,
    att.mRpt2.ges.attributes,
    att.mRpt2.anl.attributes,
    empty
  }
mSpace =
  
  ## measure space ―
  ##         Complete measure consisting of empty space in any meter. The automated numbering of
  ##         consecutive measures of space may be controlled via the multi.number attribute on the
  ##         scoreDef or staffDef elements.
  element mSpace {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mSpace.log.attributes,
    att.mSpace.vis.attributes,
    att.mSpace.ges.attributes,
    att.mSpace.anl.attributes,
    empty
  }
multiRest =
  
  ## multi-rest ―
  ##         Multiple measures of rest compressed into a single symbol, frequently found in performer
  ##         parts. The num attribute can used to store a number to be rendered along with the note. See
  ##         Read, p. 102-105.
  element multiRest {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.multiRest.log.attributes,
    att.multiRest.vis.attributes,
    att.multiRest.ges.attributes,
    att.multiRest.anl.attributes,
    empty
  }
multiRpt =
  
  ## multi-repeat ―
  ##         Multiple repeated measures. In modern publishing practice, repeats of more than two measures
  ##         should be written out using repeat signs. This element, however, is provided for handling
  ##         non-standard practices often found in manuscript. The num attribute records the number of
  ##         measures to be repeated.
  element multiRpt {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.multiRpt.log.attributes,
    att.multiRpt.vis.attributes,
    att.multiRpt.ges.attributes,
    att.multiRpt.anl.attributes,
    empty
  }
octave =
  
  ## octave ― An
  ##         indication that a passage should be performed one or more octaves above or below its written
  ##         pitch. The dis and dis.place attributes record the amount and direction of displacement,
  ##         respectively. The rend attribute captures the appearance of the continuation line associated
  ##         with the octave displacement. The starting point of the octave displacement may be indicated
  ##         by either a tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending point may
  ##         be recorded by either a dur, dur.ges or endid attribute. It is a semantic error not to
  ##         specify one starting and one ending type of attribute. Please note that the dur attribute
  ##         here is not a true duration, but rather a time stamp for the end point of the octave
  ##         displacement. Also, note that the dur attribute is not required because the octave
  ##         displacement can be visually instantaneous.
  element octave {
    empty
    >> sch:pattern [
         id =
           "octave-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:octave"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.octave.log.attributes,
    att.octave.vis.attributes,
    att.octave.ges.attributes,
    att.octave.anl.attributes,
    empty
  }
ossia =
  
  ## ossia ― An
  ##         alternate notational version *present in the source being transcribed*. The alternative
  ##         material often provides a simpler, easier to perform option, while at other times the
  ##         alternate material provides indications of performance practice, such as ornamentation.
  ##         Often an ossia is rendered above the main staff on a reduced-size staff. Sometimes the
  ##         alternate material occurs on the same staff as the primary text, but in a separate layer. In
  ##         this case, the alternative material is often rendered in small-sized
  ##         notation.
  element ossia {
    ((model.staffLike, model.staffLike+)
     | (model.layerLike, model.layerLike+))
    >> sch:pattern [
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:measure/mei:ossia"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = count(mei:staff)"
             "Ossia may contain only measure elements\x{a}" ~
             "            in this context."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:staff/mei:ossia"
           "\x{a}" ~
           "          "
           sch:assert [
             test = "count(mei:*) = count(mei:layer)"
             "Ossia may contain only layer elements\x{a}" ~
             "            in this context."
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.ossia.log.attributes,
    att.ossia.vis.attributes,
    att.ossia.ges.attributes,
    att.ossia.anl.attributes,
    empty
  }
pedal =
  
  ## pedal ― Piano
  ##         pedal mark (Read, p. 317-318). The starting point of the pedal mark may be indicated by
  ##         either a tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic error not to
  ##         specify a starting point attribute.
  element pedal {
    empty
    >> sch:pattern [
         id =
           "pedal-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:pedal"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.pedal.log.attributes,
    att.pedal.vis.attributes,
    att.pedal.ges.attributes,
    att.pedal.anl.attributes,
    empty
  }
reh =
  
  ## rehearsal mark
  ##         ― In an orchestral score and its corresponding parts, a mark indicating a convenient point
  ##         from which to resume rehearsal after a break. It may also be called a rehearsal figure, or
  ##         when numbers are used instead of letters, a rehearsal number. See Read, p. 443. <reh>
  ##         uses a subset of model.textphraseLike.limited.
  element reh {
    (text | model.lbLike | model.rendLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.reh.log.attributes,
    att.reh.vis.attributes,
    att.reh.ges.attributes,
    att.reh.anl.attributes,
    empty
  }
slur =
  
  ## slur ―
  ##         Historically, the term "slur" indicated two notes performed legato, while the term "phrase"
  ##         was used for a "unified melodic idea". Nowadays, however, "slur" often has the same meaning
  ##         as "phrase" (See Read, p. 265-266), since the visual rendition of the two concepts is the
  ##         same. MEI provides two distinct elements so that those users wishing to maintain a
  ##         distinction for historical reasons may do so. If the user does not want to maintain the
  ##         distinction, then the more generic <slur> element should be employed. The starting
  ##         point of the slur may be indicated by either a tstamp, tstamp.ges, tstamp.real or startid
  ##         attribute, while the ending point may be recorded by either a dur, dur.ges or endid
  ##         attribute. It is a semantic error not to specify one starting and one ending type of
  ##         attribute. Either place, bulge, or bezier attributes may be used to record the curvature of
  ##         the slur. The slur and tie elements may be used instead of the slur.* and tie.* attributes
  ##         provided on chord and note elements when 1) they are required by software, or 2) multiple,
  ##         alternative slurs are needed. Please note that the dur attribute is not a true duration, but
  ##         rather a time stamp for the end point of the slur.
  element slur {
    empty
    >> sch:pattern [
         id =
           "slur-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:slur"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.slur.log.attributes,
    att.slur.vis.attributes,
    att.slur.ges.attributes,
    att.slur.anl.attributes,
    empty
  }
tie =
  
  ## tie ― An
  ##         indication that two notes of the same pitch form a single note with their combined rhythmic
  ##         values. Most often it is rendered as a curved line connecting the two notes. See Read, p.
  ##         110-111, 122.
  element tie {
    empty
    >> sch:pattern [
         id =
           "tie-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tie"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.tie.log.attributes,
    att.tie.vis.attributes,
    att.tie.ges.attributes,
    att.tie.anl.attributes,
    empty
  }
tuplet =
  
  ## tuplet ― A
  ##         group of notes with "irregular" (sometimes called "irrational") rhythmic values, for
  ##         example, three notes in the time normally occupied by two or nine in the time of five. The
  ##         beam sub-element is allowed so that custom beaming may be indicated, e.g., a septuplet may
  ##         be divided into a group of three plus a group of four notes. See Read, p. 187-215. The
  ##         tuplet element may also used for bowed tremolo (Read, p. 394) and double, triple, or flutter
  ##         tonguing (Read, p. 348-349); that is, for repetition of the same pitch. In the case of
  ##         irrational durations, such as such as two quarter notes in the time of five 8th notes in a
  ##         measure of 5/8 time, decimal values may be used in the dur.ges attribute. For example, the
  ##         dur.ges attribute would take the value "2.5" if the midi.div attribute's value was "1". The
  ##         num and numbase attributes may be used for explicit labelling of a tuplet, such as, '3' with
  ##         an 8th-note triplet, '3:2' over a quarter-note triplet, etc. The rendering of the ratio,
  ##         however, is dependent on the num.format attribute found in the att.vis.tuplet attribute
  ##         class.
  element tuplet {
    (model.eventLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.tuplet.log.attributes,
    att.tuplet.vis.attributes,
    att.tuplet.ges.attributes,
    att.tuplet.anl.attributes,
    empty
  }
tupletSpan =
  
  ## tuplet span ―
  ##         Alternative element for encoding tuplets, especially useful for tuplets that extend across
  ##         bar lines. The starting point of the tuplet may be indicated by either a tstamp, tstamp.ges,
  ##         tstamp.real or startid attribute, while the ending point may be recorded using a dur,
  ##         dur.ges or endid attribute. It is a semantic error not to specify one starting and one
  ##         ending type of attribute.
  element tupletSpan {
    empty
    >> sch:pattern [
         id =
           "tupletSpan-constraint-Start-_and_end-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:tupletSpan"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "          "
           sch:assert [
             test = "@endid or @dur"
             "Must have one of the attributes: dur or\x{a}" ~
             "            endid"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.tupletSpan.log.attributes,
    att.tupletSpan.vis.attributes,
    att.tupletSpan.ges.attributes,
    att.tupletSpan.anl.attributes,
    empty
  }
att.ligature.anl.attributes = att.common.anl.attributes
att.ligature.ges.attributes = empty
att.ligature.log.attributes = att.ligature.log.attribute.form
att.ligature.log.attribute.form =
  
  ## provides an
  ##           indication of the function of the ligature.
  attribute form { data.LIGATUREFORM }?
att.ligature.vis.attributes = empty
att.mensur.anl.attributes = att.common.anl.attributes
att.mensur.ges.attributes = empty
att.mensur.log.attributes =
  att.duration.ratio.attributes,
  att.mensur.log.attribute.modusmaior,
  att.mensur.log.attribute.modusminor,
  att.mensur.log.attribute.prolatio,
  att.mensur.log.attribute.tempus
att.mensur.log.attribute.modusmaior =
  
  ## describes the
  ##           maxima-long relationship.
  attribute modusmaior { data.MODUSMAIOR }?
att.mensur.log.attribute.modusminor =
  
  ## describes the
  ##           long-breve relationship.
  attribute modusminor { data.MODUSMINOR }?
att.mensur.log.attribute.prolatio =
  
  ## describes the
  ##           semibreve-minim relationship.
  attribute prolatio { data.PROLATIO }?
att.mensur.log.attribute.tempus =
  
  ## describes the
  ##           breve-semibreve relationship.
  attribute tempus { data.TEMPUS }?
att.mensur.vis.attributes =
  att.color.attributes,
  att.relativesize.attributes,
  att.slashcount.attributes,
  att.staffloc.attributes,
  att.mensur.vis.attribute.dot,
  att.mensur.vis.attribute.form,
  att.mensur.vis.attribute.orient,
  att.mensur.vis.attribute.sign
att.mensur.vis.attribute.dot =
  
  ## specifies
  ##           whether a dot is to be added to the base symbol.
  attribute dot { data.BOOLEAN }?
att.mensur.vis.attribute.form =
  
  ## indicates
  ##           whether the base symbol is written vertically or horizontally.
  attribute form {
    
    ##
    "horizontal"
    | 
      ##
      "vertical"
  }?
att.mensur.vis.attribute.orient =
  
  ## describes the
  ##           rotation or reflection of the base symbol.
  attribute orient { data.ORIENTATION }?
att.mensur.vis.attribute.sign =
  
  ## the base
  ##           symbol in the mensuration sign/time signature of mensural notation.
  attribute sign { data.MENSURATIONSIGN }?
att.mensuration.log.attributes =
  att.mensur.log.attributes,
  att.mensuration.log.attribute.mensur.dot,
  att.mensuration.log.attribute.mensur.orient,
  att.mensuration.log.attribute.mensur.sign,
  att.mensuration.log.attribute.mensur.slash
att.mensuration.log.attribute.mensur.dot =
  
  ## determines if
  ##           a dot is to be added to the base symbol.
  attribute mensur.dot { data.BOOLEAN }?
att.mensuration.log.attribute.mensur.orient =
  
  ## describes the
  ##           rotation or reflection of the base symbol.
  attribute mensur.orient { data.ORIENTATION }?
att.mensuration.log.attribute.mensur.sign =
  
  ## the base
  ##           symbol in the mensuration sign/time signature of mensural notation.
  attribute mensur.sign { data.MENSURATIONSIGN }?
att.mensuration.log.attribute.mensur.slash =
  
  ## indicates the
  ##           number lines added to the mensuration sign. For example, one slash is added for what we
  ##           now call 'alla breve'.
  attribute mensur.slash { xsd:positiveInteger }?
att.mensuration.vis.attributes =
  att.mensuration.vis.attribute.mensur.form,
  att.mensuration.vis.attribute.mensur.loc,
  att.mensuration.vis.attribute.mensur.size
att.mensuration.vis.attribute.mensur.form =
  
  ## indicates
  ##           whether the base symbol is written vertically or horizontally.
  attribute mensur.form {
    
    ##
    "horizontal"
    | 
      ##
      "vertical"
  }?
att.mensuration.vis.attribute.mensur.loc =
  
  ## holds the
  ##           staff location of the mensuration sign.
  attribute mensur.loc { xsd:positiveInteger }?
att.mensuration.vis.attribute.mensur.size =
  
  ## describes the
  ##           relative size of the mensuration sign.
  attribute mensur.size { data.SIZE }?
att.note.ges.mensural.attributes = att.duration.ratio.attributes
att.note.log.mensural.attributes = att.note.log.mensural.attribute.lig
att.note.log.mensural.attribute.lig =
  
  ## indicates
  ##           this element's participation in a ligature.
  attribute lig {
    
    ##
    "recta"
    | 
      ##
      "obliqua"
  }?
att.proport.anl.attributes = att.common.anl.attributes
att.proport.ges.attributes = empty
att.proport.log.attributes = att.duration.ratio.attributes
att.proport.vis.attributes = empty
att.rest.ges.mensural.attributes = att.duration.ratio.attributes
att.rest.vis.mensural.attributes =
  att.lineloc.attributes, att.rest.vis.mensural.attribute.spaces
att.rest.vis.mensural.attribute.spaces =
  
  ## states how
  ##           many spaces are covered by the rest.
  attribute spaces { xsd:positiveInteger }?
att.scoreDef.log.mensural.attributes = att.mensuration.log.attributes
att.scoreDef.vis.mensural.attributes = att.mensuration.vis.attributes
att.staffDef.log.mensural.attributes =
  att.mensuration.log.attributes,
  att.staffDef.log.mensural.attribute.proport.num,
  att.staffDef.log.mensural.attribute.proport.numbase
att.staffDef.log.mensural.attribute.proport.num =
  
  ## Together,
  ##           proport.num and proport.numbase specify a proportional change as a ratio, e.g., 1:3.
  ##           Proport.num is for the first value in the ratio.
  attribute proport.num { xsd:positiveInteger }?
att.staffDef.log.mensural.attribute.proport.numbase =
  
  ## Together,
  ##           proport.num and proport.numbase specify a proportional change as a ratio, e.g., 1:3.
  ##           Proport.numbase is for the second value in the ratio.
  attribute proport.numbase { xsd:positiveInteger }?
att.staffDef.vis.mensural.attributes = att.mensuration.vis.attributes
model.eventLike.mensural = mensur | proport | ligature
model.eventLike.mensural_alternation = mensur | proport | ligature
model.eventLike.mensural_sequence = mensur, proport, ligature
model.eventLike.mensural_sequenceOptional = mensur?, proport?, ligature?
model.eventLike.mensural_sequenceOptionalRepeatable =
  mensur*, proport*, ligature*
model.eventLike.mensural_sequenceRepeatable =
  mensur+, proport+, ligature+
model.layerPart.mensural =
  model.controleventLike | model.noteModifierLike | model.lyricsLike
model.layerPart.mensural_alternation =
  model.controleventLike_alternation
  | model.noteModifierLike_alternation
  | model.lyricsLike_alternation
model.layerPart.mensural_sequence =
  model.controleventLike_sequence,
  model.noteModifierLike_sequence,
  model.lyricsLike_sequence
model.layerPart.mensural_sequenceOptional =
  model.controleventLike_sequenceOptional?,
  model.noteModifierLike_sequenceOptional?,
  model.lyricsLike_sequenceOptional?
model.layerPart.mensural_sequenceOptionalRepeatable =
  model.controleventLike_sequenceOptionalRepeatable*,
  model.noteModifierLike_sequenceOptionalRepeatable*,
  model.lyricsLike_sequenceOptionalRepeatable*
model.layerPart.mensural_sequenceRepeatable =
  model.controleventLike_sequenceRepeatable+,
  model.noteModifierLike_sequenceRepeatable+,
  model.lyricsLike_sequenceRepeatable+
model.staffDefPart.mensural = mensur | proport
model.staffDefPart.mensural_alternation = mensur | proport
model.staffDefPart.mensural_sequence = mensur, proport
model.staffDefPart.mensural_sequenceOptional = mensur?, proport?
model.staffDefPart.mensural_sequenceOptionalRepeatable =
  mensur*, proport*
model.staffDefPart.mensural_sequenceRepeatable = mensur+, proport+
mensur =
  
  ## mensuration ―
  ##         The <mensur> element is provided for the encoding of mensural notation. It collects
  ##         information about the metrical relationship between a note value and the next smaller value;
  ##         that is, either triple or duple. The slash attribute indicates the number lines added to the
  ##         mensuration sign. For example, one slash is added for what we now call 'alla
  ##         breve'.
  element mensur {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.mensur.log.attributes,
    att.mensur.vis.attributes,
    att.mensur.ges.attributes,
    att.mensur.anl.attributes,
    empty
  }
proport =
  
  ## proportion ―
  ##         The <proportion> element is provided for the encoding of mensural notation. It allows
  ##         the description of note durations as arithmetic ratios. While mensuration refers to the
  ##         normal relationships between note durations, proportion affects the relations of the note
  ##         durations to the tactus.
  element proport {
    empty,
    att.common.attributes,
    att.facsimile.attributes,
    att.proport.log.attributes,
    att.proport.vis.attributes,
    att.proport.ges.attributes,
    att.proport.anl.attributes,
    empty
  }
ligature =
  
  ## ligature ― A
  ##         mensural notation symbol that combines two or more notes into a single sign. The rhythmic
  ##         meaning of the components of a ligature is typically contextual, not absolute; therefore, an
  ##         interpretative duration may be encoded on each of the components using either the dur.ges
  ##         attribute or the num and numbase attribute pair. The <ligature> element should *not*
  ##         be used for brackets in modern notation that indicate notes that were part of a ligature in
  ##         the original source.
  element ligature {
    model.layerPart*,
    att.common.attributes,
    att.facsimile.attributes,
    att.ligature.log.attributes,
    att.ligature.vis.attributes,
    att.ligature.ges.attributes,
    att.ligature.anl.attributes,
    empty
  }
att.ineume.anl.attributes = att.common.anl.attributes
att.ineume.ges.attributes = empty
att.ineume.log.attributes =
  att.ineume.log.attribute.form, att.ineume.log.attribute.name
att.ineume.log.attribute.form =
  
  ## provides a
  ##           subclass or functional label for the neume.
  attribute form { data.INEUMEFORM }?
att.ineume.log.attribute.name =
  
  ## records the
  ##           name of the neume.
  attribute name { data.INEUMENAME }?
att.ineume.vis.attributes = att.color.attributes
att.uneume.anl.attributes =
  att.common.anl.attributes,
  att.harmonicfunction.attributes,
  att.melodicfunction.attributes,
  att.intervallicdesc.attributes,
  att.solfa.attributes
att.uneume.ges.attributes = empty
att.uneume.log.attributes =
  att.event.attributes,
  att.syltext.attributes,
  att.uneume.log.attribute.form,
  att.uneume.log.attribute.name
att.uneume.log.attribute.form =
  
  ## provides a
  ##           subclass or functional label for the neume.
  attribute form { data.UNEUMEFORM }?
att.uneume.log.attribute.name =
  
  ## records the
  ##           name of the neume.
  attribute name { data.UNEUMENAME }?
att.uneume.vis.attributes =
  att.altsym.attributes,
  att.color.attributes,
  att.relativesize.attributes,
  att.visualoffset.ho.attributes,
  att.xy.attributes,
  att.visibility.attributes
model.eventLike.neumes = ineume | uneume
model.eventLike.neumes_alternation = ineume | uneume
model.eventLike.neumes_sequence = ineume, uneume
model.eventLike.neumes_sequenceOptional = ineume?, uneume?
model.eventLike.neumes_sequenceOptionalRepeatable = ineume*, uneume*
model.eventLike.neumes_sequenceRepeatable = ineume+, uneume+
model.layerPart.neumes = model.syllableLike
model.layerPart.neumes_alternation = model.syllableLike_alternation
model.layerPart.neumes_sequence = model.syllableLike_sequence
model.layerPart.neumes_sequenceOptional =
  model.syllableLike_sequenceOptional?
model.layerPart.neumes_sequenceOptionalRepeatable =
  model.syllableLike_sequenceOptionalRepeatable*
model.layerPart.neumes_sequenceRepeatable =
  model.syllableLike_sequenceRepeatable+
model.syllableLike = syllable
model.syllableLike_alternation = syllable
model.syllableLike_sequence = syllable
model.syllableLike_sequenceOptional = syllable?
model.syllableLike_sequenceOptionalRepeatable = syllable*
model.syllableLike_sequenceRepeatable = syllable+
model.syllablePart =
  model.controleventLike
  | model.eventLike
  | model.noteModifierLike
  | model.eventLike.neumes
  | model.lyricsLike
  | model.sylLike
  | model.verseLike
  | model.midiLike
ineume =
  
  ## interrupted
  ##         neume ― a graphically interrupted neume; that is, a neume which is logically a single entity
  ##         but is written using multiple signs. The constituent signs may be encoded using ineume and
  ##         uneume sub-elements.
  element ineume {
    (model.eventLike
     | model.eventLike.neumes
     | macro.neumeModifierLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike
     | model.verseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.ineume.log.attributes,
    att.ineume.vis.attributes,
    att.ineume.ges.attributes,
    att.ineume.anl.attributes,
    empty
  }
syllable =
  
  ## syllable ―
  ##         Neume notation can be thought of as "neumed text". Therefore, the syllable element provides
  ##         high-level organization in this repertoire.
  element syllable {
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.syllablePart)*,
    att.common.attributes,
    empty
  }
uneume =
  
  ## uninterrupted
  ##         neume ― A graphically-uninterrupted neume sign. While ineume is allowed as a sub-element of
  ##         uneume here as part of the model.eventLike.neume class, it is unlikely that an uninterrupted
  ##         neume containing an interrupted neume is a meaningful construct.
  element uneume {
    (model.eventLike
     | macro.neumeModifierLike
     | model.appLike
     | model.editLike
     | model.transcriptionLike
     | model.verseLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    att.uneume.log.attributes,
    att.uneume.vis.attributes,
    att.uneume.ges.attributes,
    att.uneume.anl.attributes,
    empty
  }
att.common.anl.attributes =
  att.alignment.attributes,
  att.common.anl.attribute.copyof,
  att.common.anl.attribute.corresp,
  att.common.anl.attribute.next,
  att.common.anl.attribute.prev,
  att.common.anl.attribute.sameas,
  att.common.anl.attribute.synch
att.common.anl.attribute.copyof =
  
  ## points to an
  ##           element of which the current element is a copy.
  attribute copyof { data.URI }?
att.common.anl.attribute.corresp =
  
  ## used to point
  ##           to other elements that correspond to this one in a generic fashion.
  attribute corresp {
    list { data.URI+ }
  }?
att.common.anl.attribute.next =
  
  ## used to point
  ##           to the next event(s) in a user-defined collection.
  attribute next {
    list { data.URI+ }
  }?
att.common.anl.attribute.prev =
  
  ## points to the
  ##           previous event(s) in a user-defined collection.
  attribute prev {
    list { data.URI+ }
  }?
att.common.anl.attribute.sameas =
  
  ## points to an
  ##           element that is the same as the current element but is not a literal copy of the current
  ##           element.
  attribute sameas {
    list { data.URI+ }
  }?
att.common.anl.attribute.synch =
  
  ## points to
  ##           elements that are synchronous with the current element.
  attribute synch {
    list { data.URI+ }
  }?
att.harmonicfunction.attributes = att.harmonicfunction.attribute.hfunc
att.harmonicfunction.attribute.hfunc =
  
  ## describes
  ##           harmonic function in any convenient typology.
  attribute hfunc { xsd:NMTOKEN }?
att.intervalharmonic.attributes = att.intervalharmonic.attribute.inth
att.intervalharmonic.attribute.inth =
  
  ## encodes the
  ##           harmonic interval between this note and other pitches occurring at the same
  ##           time.
  attribute inth { xsd:NMTOKENS }?
att.intervallicdesc.attributes =
  att.intervalharmonic.attributes, att.intervallicdesc.attribute.intm
att.intervallicdesc.attribute.intm =
  
  ## encodes the
  ##           melodic interval from the previous pitch. The value may be a general directional
  ##           indication (u, d, s) or a precise numeric value in half steps.
  attribute intm { data.INTERVAL.AMOUNT }?
att.melodicfunction.attributes = att.melodicfunction.attribute.mfunc
att.melodicfunction.attribute.mfunc =
  
  ## describes
  ##           melodic function in any convenient typology.
  attribute mfunc { xsd:NMTOKEN }?
att.pitchclass.attributes = att.pitchclass.attribute.pclass
att.pitchclass.attribute.pclass =
  
  ## holds pitch
  ##           class information.
  attribute pclass { data.PITCHCLASS }?
att.solfa.attributes = att.solfa.attribute.psolfa
att.solfa.attribute.psolfa =
  
  ## contains
  ##           sol-fa designation, e.g., do, re, mi, etc., in either a fixed or movable Do
  ##           system.
  attribute psolfa { text }?
att.ornamentaccid.attributes =
  att.ornamentaccid.attribute.accidupper,
  att.ornamentaccid.attribute.accidlower
att.ornamentaccid.attribute.accidupper =
  
  ## records the
  ##           written accidental associated with an upper neighboring note.
  attribute accidupper { data.ACCIDENTAL.EXPLICIT }?
att.ornamentaccid.attribute.accidlower =
  
  ## records the
  ##           written accidental associated with a lower neighboring note.
  attribute accidlower { data.ACCIDENTAL.EXPLICIT }?
att.mordent.anl.attributes = att.common.anl.attributes
att.mordent.ges.attributes = empty
att.mordent.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.ornamentaccid.attributes,
  att.mordent.log.attribute.form,
  att.mordent.log.attribute.long
att.mordent.log.attribute.form =
  
  ## Traditionally, the 'normal' mordent is written as a short wavy line with a vertical line
  ##           through it and the inverted mordent is written without the vertical line. However, the
  ##           meaning of these signs is sometimes reversed. See Read, p. 245-246. Another attribute in
  ##           the visual domain would be necessary in order to be completely explicit about which visual
  ##           symbol is actually to be rendered.
  attribute form {
    
    ## inverted
    ##             mordent, e.g., performed as the principal note, followed by its upper neighbor, with a
    ##             return to the principal note
    "inv"
    | 
      ## "normal"
      ##             mordent, e.g., performed as the written note, followed by its lower neighbor, with a
      ##             return to the written note
      "norm"
  }?
att.mordent.log.attribute.long =
  
  ## When the long
  ##           attribute is set to 'yes', a double or long mordent, consisting of 5 notes, is
  ##           indicated.
  attribute long { data.BOOLEAN }?
att.mordent.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes
att.trill.anl.attributes = att.common.anl.attributes
att.trill.ges.attributes = att.duration.performed.attributes
att.trill.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.ornamentaccid.attributes,
  att.duration.timestamp.attributes
att.trill.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes
att.turn.anl.attributes = att.common.anl.attributes
att.turn.ges.attributes = empty
att.turn.log.attributes =
  att.controlevent.attributes,
  att.ornamentaccid.attributes,
  att.startid.attributes,
  att.turn.log.attribute.delayed,
  att.turn.log.attribute.form
att.turn.log.attribute.delayed =
  
  ## When the
  ##           delayed attribute is set to 'true', the turn begins on the second half of the beat. See
  ##           Read, p. 246.
  attribute delayed { data.BOOLEAN }?
att.turn.log.attribute.form =
  
  ## indicates the
  ##           style of the turn.
  attribute form {
    
    ## inverted
    ##             turn, e.g., begins on the note below the written note
    "inv"
    | 
      ## "normal"
      ##             turn, e.g., begins on the note above the written note
      "norm"
  }?
att.turn.vis.attributes =
  att.color.attributes,
  att.placement.attributes,
  att.visualoffset.attributes,
  att.xy.attributes
model.ornamentLike.cmn = mordent | trill | turn
model.ornamentLike.cmn_alternation = mordent | trill | turn
model.ornamentLike.cmn_sequence = mordent, trill, turn
model.ornamentLike.cmn_sequenceOptional = mordent?, trill?, turn?
model.ornamentLike.cmn_sequenceOptionalRepeatable =
  mordent*, trill*, turn*
model.ornamentLike.cmn_sequenceRepeatable = mordent+, trill+, turn+
mordent =
  
  ## mordent ― An
  ##         ornament indicating rapid alternation of the main note with a secondary note, usually a step
  ##         below, but sometimes a step above. See Read, p. 245-246. Events may be contained within
  ##         <mordent> in order to record precise performance data. The starting point of the
  ##         mordent may be indicated by either a tstamp, tstamp.ges, tstamp.real or startid attribute.
  ##         It is a semantic error not to specify a starting point attribute.
  element mordent {
    (model.eventLike*)
    >> sch:pattern [
         id =
           "mordent-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:mordent"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.mordent.log.attributes,
    att.mordent.vis.attributes,
    att.mordent.ges.attributes,
    att.mordent.anl.attributes,
    empty
  }
trill =
  
  ## trill ― Rapid
  ##         alternation of a note with one (usually at the interval of a second) above. Usually, the
  ##         interval is understood to be diatonic unless altered by an accidental. The starting note of
  ##         the trill; i.e., the written one or the ornamenting one, and the speed of alternation
  ##         depends on performance practice. Events may be contained within <trill> in order to
  ##         record precise performance data. The starting point of the trill may be indicated by either
  ##         a tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending point may be
  ##         recorded by either a dur, dur.ges or endid attribute. It is a semantic error not to specify
  ##         a starting point attribute. Please note that the dur attribute is not a true duration, but
  ##         rather a time stamp for the end point of the trill.
  element trill {
    (model.eventLike*)
    >> sch:pattern [
         id =
           "trill-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:trill"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.trill.log.attributes,
    att.trill.vis.attributes,
    att.trill.ges.attributes,
    att.trill.anl.attributes,
    empty
  }
turn =
  
  ## turn ― An
  ##         ornament consisting of four notes — the upper neighbor of the written note, the written
  ##         note, the lower neighbor, and the written note. See Read, p. 246-247. Events may be
  ##         contained within <turn> in order to record precise performance data. Whether the turn
  ##         is accented or unaccented may be inferred from the timestamp — accented turns occur directly
  ##         on the affected beat, unaccented ones do not.
  element turn {
    model.eventLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.turn.log.attributes,
    att.turn.vis.attributes,
    att.turn.ges.attributes,
    att.turn.anl.attributes,
    empty
  }
meiCorpus =
  
  ## meiCorpus ― The
  ##         document element for a group of related MEI documents, each with its own complete header,
  ##         contains a header for the group, and one or more <mei> elements. The group may be
  ##         related in a number of ways, for example, by composer, by similar instrumentation, by
  ##         holding institution, etc. This element's name should not be changed in order to assure an
  ##         absolute minimum level of MEI compliance. This element is modelled on the teiCorpus element
  ##         in the Text Encoding Initiative (TEI).
  element meiCorpus {
    meiHead,
    mei*,
    att.common.attributes,
    att.meiversion.attributes,
    empty
  }
att.crit.attributes =
  att.handident.attributes,
  att.responsibility.attributes,
  att.sequence.attributes,
  att.source.attributes,
  att.crit.attribute.cause
att.crit.attribute.cause =
  
  ## classifies
  ##           the cause for the variant reading, according to any appropriate typology of possible
  ##           origins.
  attribute cause { xsd:NMTOKEN }?
att.source.attributes = att.source.attribute.source
att.source.attribute.source =
  
  ## contains a
  ##           list of one or more pointers indicating the sources which attest to a given reading. Each
  ##           value should correspond to the ID of a <source> element located in the document
  ##           header.
  attribute source {
    list { data.URI+ }
  }?
att.rdg.anl.attributes = att.common.anl.attributes
att.rdg.ges.attributes = empty
att.rdg.log.attributes = empty
att.rdg.vis.attributes = empty
model.appLike = app
model.rdgPart.critapp =
  model.controleventLike
  | model.eventLike
  | model.layerLike
  | model.noteModifierLike
  | model.sectionPart
  | model.eventLike.measureFilling
  | model.eventLike.neumes
  | model.syllableLike
  | model.lyricsLike
  | model.sylLike
  | model.verseLike
  | model.midiLike
app =
  
  ## apparatus ―
  ##         Contains one or more alternative encodings. The alternatives may be thought of as exclusive
  ##         or as parallel. The type attribute may contain any convenient descriptive word, describing
  ##         the extent of the variation (e.g. note, phrase, measure, etc.), its text-critical
  ##         significance (e.g. significant, accidental, unclear), or the nature of the variation or the
  ##         principles required to understand it (e.g. lectio difficilior, usus auctoris, etc.). This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element app {
    lem?, rdg, rdg*, att.common.attributes, att.typed.attributes, empty
  }
lem =
  
  ## lemma ―
  ##         Contains the lemma, or base text, of a textual variation. The lem element may also be used,
  ##         under some circumstances, to record the base text of the source edition, to mark the
  ##         readings of a base witness, to indicate the preference of an editor or encoder for a
  ##         particular reading, or to make clear, in cases of ambiguity, precisely which portion of the
  ##         main text the variation applies to. Those who prefer to work without the notion of a base
  ##         text may prefer not to use it at all. An integer indicating the position of this reading in
  ##         a sequence, when there is reason to presume a sequence of the variant readings, may be
  ##         captured in the seq attribute. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element lem {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.rdgPart.critapp)*,
    att.common.attributes,
    att.crit.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.rdg.anl.attributes,
    att.rdg.ges.attributes,
    att.rdg.log.attributes,
    att.rdg.vis.attributes,
    empty
  }
rdg =
  
  ## reading ― Since
  ##         a reading can be a multi-measure section, the scoreDef element is allowed so that a reading
  ##         may have its own meta-data without incurring the overhead of child <section> elements.
  ##         The app sub-element is permitted in order to allow nested sub-variants. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element rdg {
    expansion*,
    (model.appLike
     | model.divLike
     | model.milestoneLike.music
     | model.scoreDefLike
     | model.staffDefLike
     | model.staffGrpLike
     | model.annotLike
     | model.graphicprimitiveLike
     | model.editLike
     | model.transcriptionLike
     | model.rdgPart.critapp)*,
    att.common.attributes,
    att.crit.attributes,
    att.typed.attributes,
    att.pointing.attributes,
    att.rdg.anl.attributes,
    att.rdg.ges.attributes,
    att.rdg.log.attributes,
    att.rdg.vis.attributes,
    empty
  }
att.edit.attributes =
  att.responsibility.attributes,
  att.source.attributes,
  att.edit.attribute.cert,
  att.edit.attribute.evidence
att.edit.attribute.cert =
  
  ## signifies the
  ##           degree of certainty or precision associated with a feature.
  attribute cert { data.CERTAINTY }?
att.edit.attribute.evidence =
  
  ## indicates the
  ##           nature of the evidence supporting the reliability or accuracy of the intervention or
  ##           interpretation. Suggested values include: 'internal', 'external',
  ##           'conjecture'.
  attribute evidence { xsd:NMTOKEN }?
att.agentident.attributes = att.agentident.attribute.agent
att.agentident.attribute.agent =
  
  ## signifies the
  ##           causative agent of damage, illegibility, or other loss of original text.
  attribute agent { text }?
att.extent.attributes = att.extent.attribute.extent
att.extent.attribute.extent =
  
  ## indicates the
  ##           extent of damage or omission.
  attribute extent { text }?
att.reasonident.attributes = att.reasonident.attribute.reason
att.reasonident.attribute.reason =
  
  ## holds a short
  ##           phrase describing the reason for missing textual material (gap), why material is supplied
  ##           (supplied), or why transcription is difficult (unclear).
  attribute reason { text }?
att.trans.attributes = att.handident.attributes, att.sequence.attributes
model.choicePart =
  model.editorialLike | corr | orig | reg | sic | unclear
model.editLike = choice | gap | handShift | subst
model.editLike_alternation = choice | gap | handShift | subst
model.editLike_sequence = choice, gap, handShift, subst
model.editLike_sequenceOptional = choice?, gap?, handShift?, subst?
model.editLike_sequenceOptionalRepeatable =
  choice*, gap*, handShift*, subst*
model.editLike_sequenceRepeatable = choice+, gap+, handShift+, subst+
model.transcriptionLike =
  add
  | corr
  | damage
  | del
  | orig
  | reg
  | restore
  | sic
  | supplied
  | unclear
model.transcriptionLike_alternation =
  add
  | corr
  | damage
  | del
  | orig
  | reg
  | restore
  | sic
  | supplied
  | unclear
model.transcriptionLike_sequence =
  add, corr, damage, del, orig, reg, restore, sic, supplied, unclear
model.transcriptionLike_sequenceOptional =
  add?,
  corr?,
  damage?,
  del?,
  orig?,
  reg?,
  restore?,
  sic?,
  supplied?,
  unclear?
model.transcriptionLike_sequenceOptionalRepeatable =
  add*,
  corr*,
  damage*,
  del*,
  orig*,
  reg*,
  restore*,
  sic*,
  supplied*,
  unclear*
model.transcriptionLike_sequenceRepeatable =
  add+,
  corr+,
  damage+,
  del+,
  orig+,
  reg+,
  restore+,
  sic+,
  supplied+,
  unclear+
add =
  
  ## addition ―
  ##         Marks an addition to the text. The add element contains material inserted by an author,
  ##         scribe, annotator, or corrector. The agent responsible for the addition may be encoded using
  ##         the hand attribute, while the resp attribute records the editor or transcriber responsible
  ##         for identifying the hand of the addition. The cert attribute signifies the degree of
  ##         certainty ascribed to the identification of the hand of the addition. The editor(s)
  ##         responsible for asserting this particular reading may be recorded in the resp attribute. The
  ##         value of resp must point to one or more identifiers declared in the document header. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element add {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
choice =
  
  ## choice ― Groups
  ##         a number of alternative encodings for the same point in a text. Because the children of a
  ##         choice element all represent alternative ways of encoding the same sequence, it is natural
  ##         to think of them as mutually exclusive. However, there may be cases where a full
  ##         representation of a text requires the alternative encodings to be considered as parallel.
  ##         Note also that choice elements may be recursively nested. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element choice {
    (choice | model.choicePart)*, att.common.attributes, empty
  }
corr =
  
  ## correction ―
  ##         Contains the correct form of an apparent erroneous passage. The cert attribute signifies the
  ##         degree of certainty ascribed to correction. The resp attribute contains an ID reference to
  ##         an element containing the name of the editor or transcriber responsible for suggesting the
  ##         correction held as the content of the <corr> element. If the correction was made in
  ##         the source, resp should be used to identify the hand of the corrector. The value of resp
  ##         must point to one or more identifiers declared in the document header. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element corr {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
damage =
  
  ## damage ―
  ##         Contains an area of damage to the carrier. In the case of damage resulting from an
  ##         identifiable cause, the agent attribute signifies the causative agent. The degree attribute
  ##         signifies the degree of damage according to a convenient scale. A <damage> tag with
  ##         this attribute should only be used where the text may be read with some confidence; data
  ##         supplied from other sources should be tagged as <supplied>. The extent attribute
  ##         indicates approximately how much text is in the damaged area, in notes, measures, inches, or
  ##         any appropriate unit, where this cannot be deduced from the contents of the tag. For
  ##         example, the damage may span structural divisions in the text so that the tag must then be
  ##         empty of content. In the case of damage (deliberate defacement, etc.) assignable to an
  ##         identifiable hand, the hand attribute signifies the hand responsible for the damage. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element damage {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.extent.attributes,
    att.facsimile.attributes,
    att.handident.attributes,
    att.typed.attributes,
    
    ## records the
    ##             degree of damage.
    attribute degree { text }?,
    empty
  }
del =
  
  ## deletion ―
  ##         Contains information deleted, marked as deleted, or otherwise indicated as superfluous or
  ##         spurious in the copy text by an author, scribe, annotator, or corrector. The resp attribute
  ##         contains an ID reference to an element containing the name of the editor or transcriber
  ##         responsible for identifying the hand of the deletion. The cert attribute signifies the
  ##         degree of certainty ascribed to the identification of the hand of the deletion. The hand of
  ##         the agent which made the deletion should be pointed to using the hand attribute. The rend
  ##         attribute may be used to record the method used to make the deletion (overstrike,
  ##         strike[through], etc.) or how the deleted matter should be displayed. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element del {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.trans.attributes,
    
    ## contains an
    ##             indication of how the deletion should be rendered.
    attribute rend { text }?,
    empty
  }
gap =
  
  ## gap ― Indicates
  ##         a point where material has been omitted in a transcription, whether as part of sampling
  ##         practice or for editorial reasons described in the MEI header. When material is omitted
  ##         because it is illegible or inaudible, <unclear> should be used instead. Similarly, use
  ##         <damage> if the omission is due to damage and <del> if the omission is because
  ##         the material is marked as deleted, or otherwise indicated as superfluous or spurious in the
  ##         copy text by an author, scribe, annotator, or corrector. An indication of how much material
  ##         has been omitted from the transcription may be recorded in the extent attribute. The unit
  ##         attribute names the unit used for describing the extent of the gap. The reason attribute
  ##         gives the reason for omission. Sample values include 'sampling', 'irrelevant', 'cancelled'.
  ##         The resp attribute contains an ID reference to an element containing the name of the editor,
  ##         transcriber or encoder responsible for the decision not to provide any transcription of the
  ##         material and hence the application of the <gap> tag. The hand attribute signifies the
  ##         hand which made the deletion in the case of text omitted from the transcription because of
  ##         deliberate deletion by an identifiable hand. The cert attribute signifies the degree of
  ##         certainty ascribed to the identification of the extent of the missing material. This element
  ##         is modelled on an element in the Text Encoding Initiative (TEI).
  element gap {
    empty,
    att.common.attributes,
    att.edit.attributes,
    att.extent.attributes,
    att.handident.attributes,
    att.measurement.attributes,
    att.reasonident.attributes,
    empty
  }
handShift =
  
  ## hand shift ―
  ##         Marks the beginning of a passage written in a new hand, or of a change in the scribe,
  ##         writing style, ink or character of the document hand. The character attribute describes
  ##         characteristics of the hand, particularly those related to the quality of the writing, e.g.,
  ##         'shaky', 'thick', regular'. A description of the tint or type of ink, e.g. 'brown' or the
  ##         writing medium, e.g. 'pencil', may be placed in the medium attribute. The new hand may be
  ##         identified using the new attribute, while the previous hand may be recorded in the old
  ##         attribute. The resp attribute contains an ID reference to an element containing the name of
  ##         the editor or transcriber responsible for identifying the change of hand. The cert attribute
  ##         signifies the degree of certainty ascribed to the identification of the new hand. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element handShift {
    empty,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.medium.attributes,
    
    ## describes
    ##             the character of the new hand.
    attribute character { text }?,
    
    ## identifies
    ##             the new hand. The value must contain the ID of a hand element given elsewhere in the
    ##             document.
    attribute new { data.URI }?,
    
    ## identifies
    ##             the old hand. The value must contain the ID of a hand element given elsewhere in the
    ##             document.
    attribute old { data.URI }?,
    empty
  }
orig =
  
  ## original ―
  ##         Contains a reading which is marked as following the original, rather than being normalized
  ##         or corrected. This element will often be combined with a regularized form within a choice
  ##         element. The editor(s) responsible for asserting that the material is original may be
  ##         recorded in the resp attribute. The value of resp must point to one or more identifiers
  ##         declared in the document header. The cert attribute signifies the degree of certainty
  ##         ascribed to the transcription of the original text. This element is modelled on an element
  ##         in the Text Encoding Initiative (TEI).
  element orig {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.typed.attributes,
    empty
  }
reg =
  
  ## regularization
  ##         ― Contains a reading which has been regularized or normalized in some sense. It is possible
  ##         to identify the individual responsible for the regularization, and, using the choice and
  ##         orig elements, to provide both original and regularized readings. The editor(s) responsible
  ##         for asserting the regularized material may be recorded in the resp attribute. The value of
  ##         resp must point to one or more identifiers declared in the document header. The cert
  ##         attribute signifies the degree of certainty ascribed to the regularized reading. This
  ##         element is modelled on an element in the Text Encoding Initiative (TEI).
  element reg {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.authorized.attributes,
    att.edit.attributes,
    empty
  }
restore =
  
  ## restore ―
  ##         Indicates restoration of musical material to an earlier state by cancellation of an
  ##         editorial or authorial marking or instruction. The desc (description) attribute gives a
  ##         prose description of the means of restoration, 'stet' or 'strike-down', for example. The
  ##         cert attribute signifies the degree of certainty ascribed to the identification of the hand
  ##         of the restoration. The type attribute may be used to indicate the action cancelled by the
  ##         restoration. The resp attribute contains an ID reference to an element containing the name
  ##         of the editor or transcriber responsible for identifying the hand of the restoration. The
  ##         hand attribute signifies the hand of the agent which made the restoration. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element restore {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.trans.attributes,
    att.typed.attributes,
    
    ## provides a
    ##             description of the means of restoration.
    attribute desc { text }?,
    empty
  }
sic =
  
  ## sic ― Contains
  ##         apparently incorrect or inaccurate musical material. A correction for the apparent error may
  ##         be given in an accompanying child or sibling corr element. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element sic {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    empty
  }
subst =
  
  ## substitution ―
  ##         Groups transcriptional elements when the combination is to be regarded as a single
  ##         intervention in the text. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element subst {
    model.transcriptionLike,
    model.transcriptionLike+,
    att.common.attributes,
    att.edit.attributes,
    att.trans.attributes,
    empty
  }
supplied =
  
  ## supplied ―
  ##         Contains musical material supplied by the transcriber or editor in place of text which
  ##         cannot be read, either because of physical damage or loss in the original or because it is
  ##         illegible for any reason. When the presumed loss of text arises from an identifiable cause,
  ##         agent signifies the causative agent. When the presumed loss of text arises from action
  ##         (partial deletion, etc.) assignable to an identifiable hand, the hand attribute signifies
  ##         the hand responsible for the action. The reason attribute indicates why the text has to be
  ##         supplied, e.g. 'overbinding', 'faded ink', 'lost folio', 'omitted in original', etc. The
  ##         source attribute contains the source of the supplied text. The editor(s) responsible for
  ##         supplied material may be recorded in the resp attribute. The value of resp must point to one
  ##         or more identifiers declared in the document header. The cert attribute signifies the degree
  ##         of certainty ascribed to the supplied material. This element is modelled on an element in
  ##         the Text Encoding Initiative (TEI).
  element supplied {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.reasonident.attributes,
    empty
  }
unclear =
  
  ## unclear ―
  ##         Contains musical material that cannot be transcribed with certainty because it is illegible
  ##         or inaudible in the source. Where the difficulty in transcription arises from an
  ##         identifiable cause, the agent attribute signifies the causative agent. The cert attribute
  ##         signifies the degree of certainty ascribed to the transcription of the text contained within
  ##         the <unclear> element. Where the difficulty in transcription arises from action
  ##         (partial deletion, etc.) assignable to an identifiable hand, the hand attribute signifies
  ##         the hand responsible for the action. The reason attribute indicates why the material is
  ##         difficult to transcribe. The resp attribute indicates the individual responsible for the
  ##         transcription of the word, phrase, or passage contained with the <unclear> element.
  ##         The value of resp must point to one or more identifiers declared in the document header.
  ##         This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element unclear {
    (text
     | model.textphraseLike
     | model.eventLike
     | model.eventLike.neumes
     | model.controleventLike
     | model.lyricsLike
     | model.midiLike
     | model.editLike
     | model.transcriptionLike
     | model.eventLike.measureFilling
     | model.noteModifierLike
     | model.sectionLike
     | model.measureLike
     | model.staffLike
     | model.layerLike
     | model.graphicprimitiveLike
     | model.fLike)*,
    att.agentident.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.handident.attributes,
    att.reasonident.attributes,
    empty
  }
att.facsimile.attributes = att.facsimile.attribute.facs
att.facsimile.attribute.facs =
  
  ## permits the
  ##           current element to reference a facsimile image or image zone which corresponds to
  ##           it.
  attribute facs {
    list { data.URI+ }
  }?
model.facsimileLike = facsimile
facsimile =
  
  ## facsimile ―
  ##         Contains a representation of some written source in the form of a set of images rather than
  ##         as transcribed or encoded text. The decls attribute may be used to link the collection of
  ##         images with a particular source described in the header. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element facsimile {
    surface*, att.common.attributes, att.declaring.attributes, empty
  }
surface =
  
  ## surface ―
  ##         Defines a writing surface in terms of a rectangular coordinate space, optionally grouping
  ##         one or more graphic representations of that space, and rectangular zones of interest within
  ##         it. The startid attribute may be used to hold a reference to the first feature occurring on
  ##         this surface. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element surface {
    model.figDescLike*,
    model.graphicLike*,
    zone*,
    att.common.attributes,
    att.coordinated.attributes,
    att.datapointing.attributes,
    att.declaring.attributes,
    att.startid.attributes,
    empty
  }
zone =
  
  ## zone ― Defines
  ##         a rectangular area contained within a surface. This element is modelled on an element in the
  ##         Text Encoding Initiative (TEI).
  element zone {
    model.figDescLike*,
    model.graphicLike*,
    att.common.attributes,
    att.coordinated.attributes,
    att.datapointing.attributes,
    empty
  }
att.tabular.attributes =
  att.tabular.attribute.colspan, att.tabular.attribute.rowspan
att.tabular.attribute.colspan =
  
  ## the number of
  ##           columns spanned by this cell.
  attribute colspan { xsd:positiveInteger }?
att.tabular.attribute.rowspan =
  
  ## the number of
  ##           rows spanned by this cell.
  attribute rowspan { xsd:positiveInteger }?
model.figureLike = fig
model.figureLike_alternation = fig
model.figureLike_sequence = fig
model.figureLike_sequenceOptional = fig?
model.figureLike_sequenceOptionalRepeatable = fig*
model.figureLike_sequenceRepeatable = fig+
model.graphicLike = graphic
model.figDescLike = figDesc
model.tableLike = table
model.tableLike_alternation = table
model.tableLike_sequence = table
model.tableLike_sequenceOptional = table?
model.tableLike_sequenceOptionalRepeatable = table*
model.tableLike_sequenceRepeatable = table+
graphic =
  
  ## graphic ―
  ##         Indicates the location of an inline graphic, illustration, or figure. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element graphic {
    empty,
    att.common.attributes,
    att.declaring.attributes,
    att.internetmedia.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.measurement.attributes,
    att.typed.attributes,
    att.width.attributes,
    
    ## measurement
    ##             of the vertical dimension of an image.
    attribute height { xsd:positiveInteger }?,
    empty
  }
fig =
  
  ## figure ― groups
  ##         elements representing or containing graphic information such as an illustration or figure.
  ##         This element is modelled on the figure element in the Text Encoding Initiative
  ##         (TEI).
  element fig {
    (model.captionLike | figDesc | model.graphicLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.xy.attributes,
    empty
  }
figDesc =
  
  ## figure
  ##         description ― Contains a brief prose description of the appearance or content of a graphic
  ##         figure, for use when documenting an image without displaying it. Best practice suggests the
  ##         use of controlled vocabulary. Don't confuse this element with a figure caption. A caption is
  ##         text primarily intended for display with an illustration. It may or may not function as a
  ##         description of the illustration. This element is modelled on an element in the Text Encoding
  ##         Initiative (TEI).
  element figDesc {
    (text
     | model.graphicprimitiveLike
     | model.textcomponentLike
     | model.annotLike)*,
    att.common.attributes,
    att.lang.attributes,
    empty
  }
table =
  
  ## table ― Visual
  ##         layout in tabular form. This element is modelled on elements in Encoded Archival Description
  ##         (EAD), Text Encoding Initiative (TEI), and HTML.
  element table {
    model.captionLike?,
    tr+,
    model.captionLike?,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
td =
  
  ## table data ―
  ##         Designates a table cell that contains data as opposed to a cell that contains column or row
  ##         heading information. The colspan and rowspan attributes tabular display rendering
  ##         information. This element is modelled on an element in HTML.
  element td {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    att.tabular.attributes,
    empty
  }
th =
  
  ## table header ―
  ##         Designates a table cell containing column or row heading information as opposed to one
  ##         containing data. The colspan and rowspan attributes tabular display rendering information.
  ##         This element is modelled on an element in HTML.
  element th {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    att.tabular.attributes,
    empty
  }
tr =
  
  ## table row ― A
  ##         formatting element that contains one or more <td> or <th> elements (cells) in a
  ##         <table>. A cell is the intersection of a row and a column. The precise rendition of
  ##         the table and its cells should be specified in a style sheet. This element is modelled on an
  ##         element in HTML.
  element tr {
    (th | td)+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
att.fretlocation.attributes = att.fretlocation.attribute.fret
att.fretlocation.attribute.fret =
  
  ## records the
  ##           location at which a string should be stopped against a fret.
  attribute fret { data.FRET }?
att.harm.anl.attributes = att.common.anl.attributes
att.harm.ges.attributes = att.duration.performed.attributes
att.harm.log.attributes =
  att.controlevent.attributes,
  att.startendid.attributes,
  att.duration.timestamp.attributes,
  att.harm.log.attribute.chordref
att.harm.log.attribute.chordref =
  
  ## contains a
  ##           reference to a <chordDef> element elsewhere in the document.
  attribute chordref { data.URI }?
att.harm.vis.attributes =
  att.placement.attributes,
  att.visualoffset.attributes,
  att.visualoffset2.ho.attributes,
  att.visualoffset2.to.attributes,
  att.xy.attributes,
  att.harm.vis.attribute.extender,
  att.harm.vis.attribute.rendgrid
att.harm.vis.attribute.extender =
  
  ## indicates the
  ##           presence of an extension symbol, typically a dash or underscore, drawn from the end of the
  ##           harmonic indication to the point indicated by the dur attribute.
  attribute extender { data.BOOLEAN }?
att.harm.vis.attribute.rendgrid =
  
  ## describes how
  ##           the harmonic indication should be rendered.
  attribute rendgrid {
    
    ## chord
    ##             tablature grid
    "grid"
    | 
      ## chord
      ##             tablature grid and the element's textual content
      "gridtext"
    | 
      ## textual
      ##             content of the element
      "text"
  }?
model.figbassLike = fb
model.fLike = f
model.chordTableLike = chordTable
model.harmLike = harm
model.harmLike_alternation = harm
model.harmLike_sequence = harm
model.harmLike_sequenceOptional = harm?
model.harmLike_sequenceOptionalRepeatable = harm*
model.harmLike_sequenceRepeatable = harm+
model.controleventLike.harmony = model.harmLike
model.controleventLike.harmony_alternation = model.harmLike_alternation
model.controleventLike.harmony_sequence = model.harmLike_sequence
model.controleventLike.harmony_sequenceOptional =
  model.harmLike_sequenceOptional?
model.controleventLike.harmony_sequenceOptionalRepeatable =
  model.harmLike_sequenceOptionalRepeatable*
model.controleventLike.harmony_sequenceRepeatable =
  model.harmLike_sequenceRepeatable+
barre =
  
  ## barre ― An
  ##         indication of fingering in a chord tablature grid. The startid and endid attributes are used
  ##         to indicate the <chordMember> elements on which the barre starts and finishes
  ##         respectively. The fret at which the barre should be created is recorded by the fret
  ##         attribute.
  element barre {
    empty,
    att.common.attributes,
    att.fretlocation.attributes,
    att.startendid.attributes,
    empty
  }
chordDef =
  
  ## chord
  ##         definition ― Chord tablature definition. An id attribute, while not required by the schema,
  ##         is needed so that <harm> elements can reference a particular chord definition. The pos
  ##         (position) attribute is provided in order to create displayable chord tablature grids.
  ##         <chordMember> sub-elements record the individual pitches of the chord.
  ##         <barre>sub-elements may be used when a single finger is used to stop multiple
  ##         strings.
  element chordDef {
    chordMember*,
    barre*,
    att.common.attributes,
    
    ## records the
    ##             fret position at which the chord tablature is to be played.
    attribute pos { xsd:positiveInteger }?,
    empty
  }
chordMember =
  
  ## chord member ―
  ##         An individual pitch in a chord defined by a <chordDef> element. The fing and fret
  ##         attributes are provided in order to create displayable chord tablature grids. The inth
  ##         (harmonic interval) attribute may be used to facilitate automated performance of a chord. It
  ##         gives the number of 1/2 steps above the bass. Of course, for the bass note itself, inth
  ##         should be set to '0'. The fret at which a finger should be placed is recorded in the fret
  ##         attribute.
  element chordMember {
    empty,
    att.common.attributes,
    att.accidental.performed.attributes,
    att.fretlocation.attributes,
    att.intervalharmonic.attributes,
    att.pitched.attributes,
    
    ## indicates
    ##             which finger, if any, should be used to play an individual string. The values 'x' and
    ##             'o' indicated muffled and open strings, respectively.
    attribute fing { data.FINGER.FRET }?,
    empty
  }
chordTable =
  
  ## chord table ―
  ##         Chord/tablature look-up table. A table may be shared between MEI instances through the use
  ##         of an external parsed entity containing the look-up table to be shared.
  element chordTable { chordDef+, att.common.attributes, empty }
f =
  
  ## Figure (figured
  ##         bass) ― Single element of a figured bass indication.
  element f {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.common.anl.attributes,
    att.altsym.attributes,
    att.facsimile.attributes,
    
    ## indicates
    ##             the presence of an extension symbol, typically a dash or underscore, drawn from the end
    ##             of the harmonic indication to the point indicated by the dur
    ##             attribute.
    attribute extender { data.BOOLEAN }?,
    empty
  }
fb =
  
  ## Figured Bass ― 
  element fb {
    (model.fLike | model.editLike | model.transcriptionLike)*,
    att.common.attributes,
    att.common.anl.attributes,
    att.facsimile.attributes,
    empty
  }
harm =
  
  ## harmony ― An
  ##         indication of harmony, e.g., chord names, tablature grids, harmonic analysis, figured bass.
  ##         The starting point of the harmony may be indicated by either a tstamp, tstamp.ges,
  ##         tstamp.real or startid attribute, while the ending point may be recorded by either a dur,
  ##         dur.ges or endid attribute. It is a semantic error not to specify a starting point
  ##         attribute. The dur attribute encodes the logical and visual duration of the harmony. Please
  ##         note that the dur attribute here is not a true duration, but rather a time stamp for the end
  ##         point of the harmony.
  element harm {
    ((text
      | model.textphraseLike.limited
      | model.graphicprimitiveLike
      | model.editLike
      | model.transcriptionLike
      | model.figbassLike)*)
    >> sch:pattern [
         id =
           "harm-constraint-Start-type_attributes_required_on_some_control_events"
         "\x{a}" ~
         "        "
         sch:rule [
           context = "mei:harm"
           "\x{a}" ~
           "          "
           sch:assert [
             test =
               "@startid or @tstamp or @tstamp.ges or                 @tstamp.real"
             "\x{a}" ~
             "            Must have one of the attributes: startid, tstamp, tstamp.ges or tstamp.real"
           ]
           "\x{a}" ~
           "        "
         ]
         "\x{a}" ~
         "      "
       ],
    att.common.attributes,
    att.facsimile.attributes,
    att.harm.log.attributes,
    att.harm.vis.attributes,
    att.harm.ges.attributes,
    att.harm.anl.attributes,
    empty
  }
att.alignment.attributes = att.alignment.attribute.when
att.alignment.attribute.when =
  
  ## indicates the
  ##           point of occurrence of this feature along a time line. Its value must be the ID of a
  ##           <when> element.
  attribute when { data.URI }?
model.alignLike = timeline
timeline =
  
  ## timeline ―
  ##         Provides a set of ordered points in time to which musical elements can be linked in order to
  ##         create a temporal alignment of those elements. The origin attribute designates the origin of
  ##         the timeline, i.e., the time at which it begins. It must point to one of the when elements
  ##         in its content. The avref attribute is provided in order to link the timeline to a
  ##         particular external media file, such as an audio file. This element is modelled on an
  ##         element in the Text Encoding Initiative (TEI).
  element timeline {
    when*,
    att.common.attributes,
    
    ## holds the
    ##             identifier of an <avFile> element that references an external digital media
    ##             file.
    attribute avref { data.URI }?,
    
    ## designates
    ##           the origin of the timeline, i.e. the <when> element associated with the beginning of
    ##           the timeline.
    attribute origin { data.URI },
    empty
  }
when =
  
  ## when ―
  ##         Indicates a point in time either absolutely (using the absolute attribute), or relative to
  ##         other elements in the same timeline element (using the interval and since attributes). The
  ##         data attribute may be used to reference one or more features that occur at this point in
  ##         time. This element is modelled on an element in the Text Encoding Initiative
  ##         (TEI).
  element when {
    empty,
    att.common.attributes,
    att.datapointing.attributes,
    
    ## provides an
    ##             absolute value for the time associated with a point on a timeline. This attribute is
    ##             required for the element designated as the origin by the parent
    ##             timeline.
    attribute absolute { data.ISOTIME }?,
    
    ## specifies
    ##             the time interval between this time point and the one designated by the since attribute.
    ##             This attribute can only be interpreted meaningfully in conjunction with the inttype
    ##             attribute.
    attribute interval { text }?,
    
    ## specifies
    ##             the kind of values used in the interval attribute.
    attribute inttype {
      
      ## byte
      ##               value
      "byte"
      | 
        ## Synchronized Multimedia Integration Language
        "smil"
      | 
        ## MIDI time
        ##               code
        "midi"
      | 
        ## SMPTE 25
        ##               EBU
        "smpte-25"
      | 
        ## SMPTE 24
        ##               Film Sync
        "smpte-24"
      | 
        ## SMPTE 30
        ##               Drop
        "smpte-df30"
      | 
        ## SMPTE 30
        ##               Non-Drop
        "smpte-ndf30"
      | 
        ## SMPTE
        ##               29.97 Drop
        "smpte-df29.97"
      | 
        ## SMPTE
        ##               29.97 Non-Drop
        "smpte-ndf29.97"
      | 
        ## AES
        ##               Time-code character format
        "tcf"
      | 
        ## ISO
        ##               24-hour time format: HH:MM:SS.ss
        "time"
    }?,
    
    ## identifies
    ##             the reference point for determining the time of the current when element, which is
    ##             obtained by adding the interval to the time of the reference point. The value should be
    ##             the ID of another when element in the same timeline. If the since attribute is omitted
    ##             and the absolute attribute is not specified, then the reference point is understood to
    ##             be the immediately preceding when element.
    attribute since { data.URI }?,
    empty
  }
att.lyrics.anl.attributes = att.common.anl.attributes
att.lyrics.ges.attributes = empty
att.lyrics.log.attributes =
  att.staffident.attributes, att.layerident.attributes
att.lyrics.vis.attributes =
  att.placement.attributes, att.typography.attributes
att.verse.anl.attributes = att.common.anl.attributes
att.verse.ges.attributes = empty
att.verse.log.attributes =
  att.verse.log.attribute.refrain, att.verse.log.attribute.rhythm
att.verse.log.attribute.refrain =
  
  ## used to
  ##           indicate a common, usually centered, refrain (Mup User's Guide, p. 44).
  attribute refrain { data.BOOLEAN }?
att.verse.log.attribute.rhythm =
  
  ## used to
  ##           specify a rhythm for the lyric syllables that differs from that of the notes on the staff,
  ##           e.g. '4,4,4,4' when the rhythm of the notes is '4.,8,4.,8'.
  attribute rhythm { text }?
att.verse.vis.attributes =
  att.typography.attributes,
  att.visualoffset.to.attributes,
  att.visualoffset.vo.attributes,
  att.xy.attributes
model.lyricsLike = lyrics
model.lyricsLike_alternation = lyrics
model.lyricsLike_sequence = lyrics
model.lyricsLike_sequenceOptional = lyrics?
model.lyricsLike_sequenceOptionalRepeatable = lyrics*
model.lyricsLike_sequenceRepeatable = lyrics+
model.sylLike = syl
model.sylLike_alternation = syl
model.sylLike_sequence = syl
model.sylLike_sequenceOptional = syl?
model.sylLike_sequenceOptionalRepeatable = syl*
model.sylLike_sequenceRepeatable = syl+
model.verseLike = verse
model.verseLike_alternation = verse
model.verseLike_sequence = verse
model.verseLike_sequenceOptional = verse?
model.verseLike_sequenceOptionalRepeatable = verse*
model.verseLike_sequenceRepeatable = verse+
lyrics =
  
  ## lyrics ―
  ##         Vocally performed 'text' of a musical composition, such as a song or opera. The staff
  ##         attribute gives the staff to which the lyrics are attached. If there is more than one layer
  ##         on that staff, the layer attribute may be used to indicate the layer from which the rhythm
  ##         should be taken. Often, automatic text underlay may rely on the notes of the indicated
  ##         staff. When this is not desirable, however, the rhythm of the lyrics may be recorded in the
  ##         rhythm attribute of the parent verse element. 
  element lyrics {
    model.verseLike+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.lyrics.log.attributes,
    att.lyrics.vis.attributes,
    att.lyrics.ges.attributes,
    att.lyrics.anl.attributes,
    empty
  }
verse =
  
  ## verse ― Lyric
  ##         verse. The lb element is allowed here in order to facilitate karaoke applications. The func
  ##         attribute on lb may be used to distinguish true line ends from line group ends for these
  ##         applications.
  element verse {
    (dir | dynam | tempo | space)*,
    model.sylLike+,
    model.lbLike*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.verse.log.attributes,
    att.verse.vis.attributes,
    att.verse.ges.attributes,
    att.verse.anl.attributes,
    empty
  }
att.channelized.attributes =
  att.channelized.attribute.midi.channel,
  att.channelized.attribute.midi.duty,
  att.channelized.attribute.midi.port,
  att.channelized.attribute.midi.track
att.channelized.attribute.midi.channel =
  
  ## records a
  ##           MIDI channel value.
  attribute midi.channel { data.MIDICHANNEL }?
att.channelized.attribute.midi.duty =
  
  ## specifies the
  ##           'on' part of the duty cycle as a percentage of a note's duration.
  attribute midi.duty { data.PERCENT }?
att.channelized.attribute.midi.port =
  
  ## sets the MIDI
  ##           port value.
  attribute midi.port { data.MIDIVALUE }?
att.channelized.attribute.midi.track =
  
  ## sets the MIDI
  ##           track.
  attribute midi.track { xsd:positiveInteger }?
att.midiinstrument.attributes =
  att.midiinstrument.attribute.midi.instrnum,
  att.midiinstrument.attribute.midi.instrname
att.midiinstrument.attribute.midi.instrnum =
  
  ## sets the MIDI
  ##           instrument number.
  attribute midi.instrnum { data.MIDIVALUE }?
att.midiinstrument.attribute.midi.instrname =
  
  ## provides a
  ##           General MIDI label for the MIDI instrument.
  attribute midi.instrname { data.MIDINAMES }?
att.midinumber.attributes = att.midinumber.attribute.num
att.midinumber.attribute.num =
  
  ## MIDI number in
  ##         the range set by data.MIDIVALUE.
  attribute num { data.MIDIVALUE }
att.miditempo.attributes = att.miditempo.attribute.midi.tempo
att.miditempo.attribute.midi.tempo =
  
  ## contains a
  ##           MIDI value, that is, the number of quarter notes per minute in the range from 10 to
  ##           1000.
  attribute midi.tempo { data.MIDITEMPO }?
att.midivalue.attributes = att.midivalue.attribute.val
att.midivalue.attribute.val =
  
  ## MIDI
  ##           number
  attribute val { data.MIDIVALUE }?
att.midi.event.attributes =
  att.staffident.attributes,
  att.layerident.attributes,
  att.timestamp.musical.attributes
att.midi.anl.attributes = att.common.anl.attributes
att.midi.ges.attributes = empty
att.midi.log.attributes =
  att.staffident.attributes, att.layerident.attributes
att.midi.vis.attributes = empty
att.timebase.attributes = att.timebase.attribute.ppq
att.timebase.attribute.ppq =
  
  ## indicates the
  ##           number of pulses (sometimes referred to as ticks or divisions) per quarter note. Unlike
  ##           MIDI, MEI permits different values for a score and individual staves.
  attribute ppq { xsd:positiveInteger }?
model.midiLike = midi
model.midiLike_alternation = midi
model.midiLike_sequence = midi
model.midiLike_sequenceOptional = midi?
model.midiLike_sequenceOptionalRepeatable = midi*
model.midiLike_sequenceRepeatable = midi+
cc =
  
  ## control change
  ##         ― MIDI parameter/control change. The num attribute specifies parameter number, while val
  ##         contains the parameter value. Each must fall in the range 0-127.
  element cc {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    att.midivalue.attributes,
    empty
  }
chan =
  
  ## channel ― MIDI
  ##         channel assignment.
  element chan {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    
    ## MIDI number
    ##           in the range set by data.MIDICHANNEL.
    attribute num { data.MIDICHANNEL },
    empty
  }
chanPr =
  
  ## channel
  ##         pressure ― MIDI channel pressure/after touch. The value of the num attribute must be in the
  ##         range 0-127.
  element chanPr {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
cue =
  
  ## cue ― MIDI cue
  ##         point.
  element cue {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
hex =
  
  ## hex ― Arbitrary
  ##         MIDI data in hexadecimal form. The element's content must be wrapped in a CDATA section to
  ##         avoid parsing errors.
  element hex {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
marker =
  
  ## marker ― MIDI
  ##         marker meta-event.
  element marker {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
metaText =
  
  ## meta text ―
  ##         MIDI text meta-event.
  element metaText {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
midi =
  
  ## midi ―
  ##         Container for elements that contain information useful when generating MIDI output. The n
  ##         attribute can be used to differentiate between multiple MIDI data streams, e.g.
  ##         quantized/unquantized, straight/swing, ornamented/as notated, etc.
  element midi {
    (cc
     | chan
     | chanPr
     | cue
     | hex
     | marker
     | metaText
     | noteOff
     | noteOn
     | port
     | prog
     | seqNum
     | trkName
     | vel)*,
    att.common.attributes,
    att.midi.log.attributes,
    att.midi.vis.attributes,
    att.midi.ges.attributes,
    att.midi.anl.attributes,
    empty
  }
noteOff =
  
  ## note-off ― MIDI
  ##         note-off event.
  element noteOff {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
noteOn =
  
  ## note-on ― MIDI
  ##         note-on event.
  element noteOn {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
port =
  
  ## port ― MIDI
  ##         port. The num attribute must be in the range 0-127.
  element port {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
prog =
  
  ## program ― MIDI
  ##         program change. The num attribute must be in the range 0-127.
  element prog {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    empty
  }
seqNum =
  
  ## sequence number
  ##         ― MIDI sequence number.
  element seqNum {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    
    ## number in the
    ##           range 0-65535.
    attribute num {
      xsd:nonNegativeInteger { maxInclusive = "65535" }
    },
    empty
  }
trkName =
  
  ## track name ―
  ##         MIDI track/sequence name.
  element trkName {
    text,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    empty
  }
vel =
  
  ## velocity ― MIDI
  ##         Note-on/off velocity. The num attribute must be in the range 0-127.
  element vel {
    empty,
    att.common.anl.attributes,
    att.common.attributes,
    att.midi.event.attributes,
    att.midinumber.attributes,
    
    ## indicates
    ##           whether this is note-on or note-off velocity data.
    attribute form {
      
      ##
      "on"
      | 
        ##
        "off"
    },
    empty
  }
model.nameLike.agent = corpName | persName
model.nameLike.agent_alternation = corpName | persName
model.nameLike.agent_sequence = corpName, persName
model.nameLike.agent_sequenceOptional = corpName?, persName?
model.nameLike.agent_sequenceOptionalRepeatable = corpName*, persName*
model.nameLike.agent_sequenceRepeatable = corpName+, persName+
model.nameLike.geogName = geogName
model.nameLike.geogName_alternation = geogName
model.nameLike.geogName_sequence = geogName
model.nameLike.geogName_sequenceOptional = geogName?
model.nameLike.geogName_sequenceOptionalRepeatable = geogName*
model.nameLike.geogName_sequenceRepeatable = geogName+
model.nameLike.place = model.repositoryLike | model.nameLike.geogName
model.nameLike.place_alternation =
  model.repositoryLike_alternation | model.nameLike.geogName_alternation
model.nameLike.place_sequence =
  model.repositoryLike_sequence, model.nameLike.geogName_sequence
model.nameLike.place_sequenceOptional =
  model.repositoryLike_sequenceOptional?,
  model.nameLike.geogName_sequenceOptional?
model.nameLike.place_sequenceOptionalRepeatable =
  model.repositoryLike_sequenceOptionalRepeatable*,
  model.nameLike.geogName_sequenceOptionalRepeatable*
model.nameLike.place_sequenceRepeatable =
  model.repositoryLike_sequenceRepeatable+,
  model.nameLike.geogName_sequenceRepeatable+
model.nameLike.label = periodName | styleName
model.nameLike.label_alternation = periodName | styleName
model.nameLike.label_sequence = periodName, styleName
model.nameLike.label_sequenceOptional = periodName?, styleName?
model.nameLike.label_sequenceOptionalRepeatable =
  periodName*, styleName*
model.nameLike.label_sequenceRepeatable = periodName+, styleName+
corpName =
  
  ## corporate name
  ##         ― Identifies an organization or group of people that acts as a single entity. Examples
  ##         include names of associations, institutions, business firms, non-profit enterprises,
  ##         governments, government agencies, projects, programs, religious bodies, churches,
  ##         conferences, athletic contests, exhibitions, expeditions, fairs, and ships. Secondary name
  ##         parts may be encoded in <corpName> sub-elements. The name of the list from which a
  ##         controlled value is taken may be recorded using the authority attribute. This element is
  ##         modelled on an element in Encoded Archival Description (EAD).
  element corpName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
geogName =
  
  ## geographic name
  ##         ― The proper noun designation for a place, natural feature, or political jurisdiction.
  ##         Examples include Black Forest; Baltimore, Maryland; and Quartier Latin, Paris. Name
  ##         sub-parts may be encoded in <geogName> sub-elements. The name of the list from which a
  ##         controlled value is taken, such as the Thesaurus of Geographic Names (TGN), may be recorded
  ##         using the authority attribute. This element is modelled on an element in Encoded Archival
  ##         Description (EAD).
  element geogName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
periodName =
  
  ## period name ― A
  ##         label that describes a period of time, such as 'Baroque' or '3rd Style period'. The name of
  ##         the list from which a controlled value is taken may be recorded using the authority
  ##         attribute.
  element periodName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
persName =
  
  ## personal name ―
  ##         Designation for an individual, including any or all of that individual's forenames,
  ##         surnames, honorific titles, and added names. Name sub-parts may be recorded in
  ##         <persName> sub-elements. The name of the list from which a controlled value is taken
  ##         may be recorded using the authority attribute. This element is modelled on an element in
  ##         Encoded Archival Description (EAD).
  element persName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.datable.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
styleName =
  
  ## style name ― A
  ##         label for a characteristic style of writing or performance, such as 'bebop' or
  ##         'rock-n-roll'. Do not confuse this element with the <periodName> element. The name of
  ##         the list from which a controlled value is taken may be recorded using the authority
  ##         attribute.
  element styleName {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.bibl.attributes,
    att.common.attributes,
    att.edit.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.name.attributes,
    att.typed.attributes,
    empty
  }
model.performanceLike = performance
performance =
  
  ## performance ―
  ##         Groups one or more recorded performances. The decls attribute may be used to link the
  ##         collection with a particular source described in the header. This element is analogous to
  ##         the <facsimile> element in the facsimile module.
  element performance {
    recording*, att.common.attributes, att.declaring.attributes, empty
  }
recording =
  
  ## recording ―
  ##         Defines a performance in terms of a group of one or more digital audio or video
  ##         representations. The startid attribute may be used to hold a reference to the first feature
  ##         occurring in this performance. This element is analogous to the <surface> element in
  ##         the facsimile module.
  element recording {
    avFile*,
    clip*,
    att.common.attributes,
    att.declaring.attributes,
    att.startid.attributes,
    
    ## indication
    ##             of the absolute start time.
    attribute begin { text }?,
    
    ## indication
    ##             of the absolute end time.
    attribute end { text }?,
    
    ## type of
    ##             values used in the begin/end attributes. The begin and end attributes can only be
    ##             interpreted meaningfully in conjunction with this attribute.
    attribute betype {
      
      ## ISO
      ##               24-hour time format: HH:MM:SS.ss
      "time"
    }?,
    empty
  }
clip =
  
  ## clip ― Defines
  ##         a time segment of interest within a digital audio or video recording. This element is
  ##         analogous to the <zone> element in the facsimile module.
  element clip {
    avFile*,
    att.common.attributes,
    att.declaring.attributes,
    att.startid.attributes,
    
    ## indication
    ##             of the absolute start time.
    attribute begin { text }?,
    
    ## indication
    ##             of the absolute end time.
    attribute end { text }?,
    
    ## type of
    ##             values used in the begin/end attributes. The begin and end attributes can only be
    ##             interpreted meaningfully in conjunction with this attribute.
    attribute betype {
      
      ## ISO
      ##               24-hour time format: HH:MM:SS.ss
      "time"
    }?,
    empty
  }
avFile =
  
  ## avFile ―
  ##         References an external digital audio or video file. This element is analogous to the
  ##         <graphic> element in the figtable module.
  element avFile {
    empty,
    att.common.attributes,
    att.declaring.attributes,
    att.internetmedia.attributes,
    att.facsimile.attributes,
    att.pointing.attributes,
    att.typed.attributes,
    empty
  }
model.locrefLike = ptr | ref
model.locrefLike_alternation = ptr | ref
model.locrefLike_sequence = ptr, ref
model.locrefLike_sequenceOptional = ptr?, ref?
model.locrefLike_sequenceOptionalRepeatable = ptr*, ref*
model.locrefLike_sequenceRepeatable = ptr+, ref+
ptr =
  
  ## pointer ―
  ##         Defines a pointer to another location. Unlike the <ref> element, <ptr> cannot
  ##         contain text or sub-elements to describe the referenced object. This element is modelled on
  ##         an element in Encoded Archival Description (EAD) and TEI.
  element ptr {
    empty,
    att.common.attributes,
    att.internetmedia.attributes,
    att.pointing.attributes,
    empty
  }
ref =
  
  ## reference ―
  ##         Defines a reference to another location. Unlike the <ptr> element, <ref> may
  ##         contain text and sub-elements to describe the destination. This element is modelled on an
  ##         element in Encoded Archival Description (EAD) and TEI.
  element ref {
    (text | model.textphraseLike)*,
    att.common.attributes,
    att.internetmedia.attributes,
    att.lang.attributes,
    att.pointing.attributes,
    empty
  }
att.staffDef.ges.tablature.attributes =
  att.staffDef.ges.tablature.attribute.tab.strings
att.staffDef.ges.tablature.attribute.tab.strings =
  
  ## provides a
  ##           written pitch and octave for each open string, e.g. "e3 a3 d4 g4 b4 e5" for standard
  ##           guitar tuning. It should contain the number of tokens indicated by the lines attribute.
  ##           Chromatic alteration may be indicated with '-', or 'f', (flat) and '#', or 's' (sharp).
  ##           Multiple sharps and flats are not permitted.
  attribute tab.strings {
    list {
      xsd:token { pattern = "[a-g][\-#fs]?[0-9]" }+
    }
  }?
att.note.ges.tablature.attributes =
  att.note.ges.tablature.attribute.tab.fret,
  att.note.ges.tablature.attribute.tab.string
att.note.ges.tablature.attribute.tab.fret =
  
  ## records the
  ##           fret at which a string should be stopped.
  attribute tab.fret { data.FRETNUMBER }?
att.note.ges.tablature.attribute.tab.string =
  
  ## records which
  ##           string is to be played.
  attribute tab.string { data.STRINGNUMBER }?
model.backLike = back
model.divLike = \div
model.frontLike = front
model.headLike = head
model.lLike = l
model.listLike = \list
model.listLike_alternation = \list
model.listLike_sequence = \list
model.listLike_sequenceOptional = \list?
model.listLike_sequenceOptionalRepeatable = \list*
model.listLike_sequenceRepeatable = \list+
model.quoteLike = quote
model.quoteLike_alternation = quote
model.quoteLike_sequence = quote
model.quoteLike_sequenceOptional = quote?
model.quoteLike_sequenceOptionalRepeatable = quote*
model.quoteLike_sequenceRepeatable = quote+
model.lgLike = lg
model.lgLike_alternation = lg
model.lgLike_sequence = lg
model.lgLike_sequenceOptional = lg?
model.lgLike_sequenceOptionalRepeatable = lg*
model.lgLike_sequenceRepeatable = lg+
back =
  
  ## back ― Back
  ##         matter such as indexes, advertisements, etc. following the main part of a text. This element
  ##         is modelled on an element in the Text Encoding Initiative (TEI).
  element back {
    model.milestoneLike.text*,
    model.divLike+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
quote =
  
  ## quote ― A
  ##         formatting element that designates an extended quotation; that is, a passage attributed to a
  ##         source external to the text. The quotation is normally set off from the text by spacing or
  ##         other typographic distinction. The source for the quote may be included in the optional
  ##         <bibl> sub-element. Use <rend> for words that are enclosed in quotation marks
  ##         for emphasis or for a short quoted phrase that occurs within a line of text. This element is
  ##         modelled on elements found in HTML, TEI, and EAD.
  element quote {
    model.textcomponentLike+,
    model.biblLike?,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
\div =
  
  ## division ―
  ##         Major structural division of text, such as a preface, chapter or section. Often, the
  ##         <head> sub-element identifies the <div>'s purpose. This element is modelled on
  ##         an element in the Text Encoding Initiative (TEI).
  element div {
    model.milestoneLike.text*,
    model.headLike?,
    (model.divLike | model.textcomponentLike)+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.typed.attributes,
    empty
  }
front =
  
  ## front ― Bundles
  ##         prefatory text found before the start of the musical text. <titlePage> may be used to
  ##         transcribe the item's title page. Other front matter structures, such as a preface,
  ##         dedication, or table of contents, may be encoded as textual divisions; that is, as
  ##         <div>s, with an optional <head> sub-element describing the nature of the
  ##         division. The <pb> element is allowed here in order to accommodate page images, e.g.
  ##         cover, endpapers, etc. before and after the actual textual matter. This element is modelled
  ##         on an element in the Text Encoding Initiative (TEI).
  element front {
    model.milestoneLike.text*,
    (model.divLike | model.frontPart)+,
    model.milestoneLike.text*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
head =
  
  ## heading ―
  ##         Contains any heading, for example, the title of a section of text, or the heading of a list.
  ##         When <head> is used, it should be the first sub-element, followed by one or more other
  ##         elements. This element is modelled on elements in Encoded Archival Description (EAD), Text
  ##         Encoding Initiative (TEI), and HTML.
  element head {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
item =
  
  ## item ― Single
  ##         item in a <list>. This element is modelled on elements in Encoded Archival Description
  ##         (EAD), Text Encoding Initiative (TEI), and HTML.
  element item {
    (text
     | model.textcomponentLike
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    empty
  }
l =
  
  ## line of text ―
  ##         Contains a single line of text within a line group. The n attribute should be used to record
  ##         a label for the line, i.e., most likely a line number. Do not confuse this element with the
  ##         <line> element, which is used for graphical lines that occur in music notation. This
  ##         element is modelled on elements in the Text Encoding Initiative (TEI).
  element l {
    (text
     | model.textphraseLike
     | model.editLike
     | model.transcriptionLike)*,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    empty
  }
lg =
  
  ## line group ―
  ##         May be used for any section of text that is organized as a group of lines. This element is
  ##         modelled on an element in the Text Encoding Initiative (TEI).
  element lg {
    model.headLike?,
    (model.lLike | model.lgLike),
    (model.lLike | model.lgLike)*,
    att.common.attributes,
    att.declaring.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    empty
  }
\list =
  
  ## list ― A
  ##         formatting element that contains a series of items separated from one another and arranged
  ##         in a linear, often vertical, sequence. This element is modelled on elements in Encoded
  ##         Archival Description (EAD), Text Encoding Initiative (TEI), and HTML.
  element list {
    model.headLike?,
    item+,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.xy.attributes,
    
    ## used to
    ##             identify and format a list. In a "simple" list, <item>s are not numbered or
    ##             bulleted. In a "marked" list, the sequence of the list items is not critical, and a
    ##             bullet, box, dash, or other character is displayed at the start of each <item>. In
    ##             an "ordered" list, the sequence of the items is important, and each <item> is
    ##             lettered or numbered. Style sheet functions should be used to specify the mark or
    ##             numeration system for each <item>.
    attribute form {
      
      ## items are
      ##               not numbered or bulleted
      "simple"
      | 
        ## bullet,
        ##               box, dash, or other character is displayed before each item
        "marked"
      | 
        ## each item
        ##               is numbered or lettered
        "ordered"
    }?,
    empty
  }
model.graphicprimitiveLike = anchoredText | curve | line | symbol
model.symbolTableLike = symbolTable
anchoredText =
  
  ## anchored text ―
  ##         Container for text that is fixed to a particular location, regardless of changes made to the
  ##         layout of the measures around it. This element may be used where semantic markup of the text
  ##         is neither possible nor desirable, such as in optical music recognition (OMR) applications.
  ##         The content model here is similar to paragraph without model.textcomponent and <pb>
  ##         sub-elements. The starting point of the text may be identified in absolute output coordinate
  ##         terms using the x and y attributes or relative to the location of another element using the
  ##         startid attribute. The attributes in the att.visualoffset class may be used to record
  ##         horizontal, vertical, or time offsets from the absolute coordinates or from the location of
  ##         the referenced element.
  element anchoredText {
    (text
     | model.textphraseLike.limited
     | model.editLike
     | model.transcriptionLike)*,
    att.common.anl.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.lang.attributes,
    att.startid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.xy.attributes,
    empty
  }
curve =
  
  ## curve ― A
  ##         curved line that cannot be represented by a more specific element, such as a <slur>.
  ##         The starting point of the curve may be identified in absolute output coordinate terms using
  ##         the x1 and y1 attributes or relative to the location of another element using the startid
  ##         attribute. The attributes in the att.visualoffset class may be used to record horizontal,
  ##         vertical, or time offsets from the absolute coordinates or from the location of the
  ##         referenced element. Similarly, the terminal point of the curve may be recorded using either
  ##         the x2,y2 coordinates or in relation to the location of another element using the endid
  ##         attribute. Attributes in the att.visualoffset2 class maybe used to record the offsets of the
  ##         ending point. The bulge attribute or, alternatively, the bezier attribute, describes the
  ##         shape of the curve. The bulge attribute describes the curve as a set of distance values
  ##         above or below an imaginary line connecting the endpoints of the curve while the bezier
  ##         attribute records the placement of Bezier control points as a series of space-separated xy
  ##         coordinate pairs, e.g., 19 45 -32 118. The bulge attribute must contain one or more values
  ##         of the NUMBER datatype. The rend attribute captures the appearance of the
  ##         curve.
  element curve {
    empty,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.startendid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.visualoffset2.attributes,
    att.xy.attributes,
    att.xy2.attributes,
    att.curvature.attributes,
    att.curverend.attributes,
    empty
  }
line =
  
  ## line ― A line
  ##         that cannot be represented by a more specific element. The starting point of the line may be
  ##         identified in absolute output coordinate terms using the x1 and y1 attributes or relative to
  ##         the location of another element using the startid attribute. The attributes in the
  ##         att.visualoffset class may be used to record horizontal, vertical, or time offsets from the
  ##         absolute coordinates or from the location of the referenced element. Similarly, the terminal
  ##         point of the line may be recorded using either the x2 and y2 attributes or in relation to
  ##         the location of another element using the endid attribute. Attributes in the
  ##         att.visualoffset2 class maybe used to record the offsets of the ending point. Text content
  ##         of the line element, e.g. 'gliss.', may be rendered with the line. The appearance of the
  ##         line is captured in the rend attribute.
  element line {
    (text | model.textphraseLike.limited)*,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.startendid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.visualoffset2.attributes,
    att.xy.attributes,
    att.xy2.attributes,
    att.linerend.attributes,
    empty
  }
symbol =
  
  ## symbol ― A
  ##         reference to a previously defined symbol. The starting point, e.g. "hotspot", of the symbol
  ##         may be identified in absolute output coordinate terms using the x and y attributes or
  ##         relative to another element using the startid attribute. Attributes in the att.visualoffset
  ##         class may be used to record horizontal, vertical, or time offsets from the absolute
  ##         coordinates or from the location of the referenced element. The ref attribute must contain
  ##         the id of a symbolDef element. The scale attribute indicates that the printed output must be
  ##         scaled by the specified percentage.
  element symbol {
    empty,
    att.common.anl.attributes,
    att.color.attributes,
    att.common.attributes,
    att.facsimile.attributes,
    att.scalable.attributes,
    att.startid.attributes,
    att.typed.attributes,
    att.visualoffset.attributes,
    att.xy.attributes,
    
    ## contains a
    ##           reference to a previously-declared user-defined symbol.
    attribute ref { data.URI },
    empty
  }
symbolDef =
  
  ## symbol
  ##         definition ― Declaration of an individual symbol in a symbolTable.
  element symbolDef {
    model.graphicprimitiveLike+,
    att.common.attributes,
    att.coordinated.attributes,
    empty
  }
symbolTable =
  
  ## symbol table ―
  ##         Contains individual, user-defined symbols. Like a chord table, a symbolTable may be shared
  ##         between mei instances through the use of an external parsed entity containing the
  ##         symbolTable to be shared.
  element symbolTable { symbolDef+, att.common.attributes, empty }
start = mei | meiHead | meiCorpus | music
