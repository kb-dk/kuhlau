# **************************************************************

# NAME:     Music Encoding Initiative (MEI) schema component:
#           header_Module.rng
# 
# NOTICE:   Copyright (c) 2010 by the Music Encoding Initiative (MEI)
#           Council.
# 
#           Licensed under the Educational Community License, Version
#           2.0 (the "License"); you may not use this file except in
#           compliance with the License. You may obtain a copy of the
#           License at http://www.osedu.org/licenses/ECL-2.0.
# 
#           Unless required by applicable law or agreed to in writing,
#           software distributed under the License is distributed on
#           an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#           KIND, either express or implied. See the License for the
#           specific language governing permissions and limitations
#           under the License.
# 
#           This is a derivative work based on earlier versions of the
#           schema copyright (c) 2001-2006 Perry Roland and the Rector
#           and Visitors of the University of Virginia; licensed under
#           the Educational Community License version 1.0.
# 
# CONTACT:  contact@music-encoding.org 

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
default namespace mei = "http://www.music-encoding.org/ns/mei"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
namespace xhtml = "http://www.w3.org/1999/xhtml"
namespace xlink = "http://www.w3.org/1999/xlink"

# Header Module

# Declare additional start elements
model.startLike |= meihead
# Declare module attr classes
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that describe correction and\x{a}" ~
    "      normalization methods"
  ]
]
att.regularmethod &=
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the method employed to mark\x{a}" ~
      "          corrections and normalizations."
    ]
  ]
  attribute method { "silent" | "tags" }?
# Declare module model classes
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of a\x{a}" ~
    "      description of the availability of and access to a bibliographic\x{a}" ~
    "      item."
  ]
]
model.availabilityPart &=
  (acqsource, (accessdesc, price?)*)*,
  userestrict?,
  sysreq?
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of a\x{a}" ~
    "      description of the editorial process applied to the encoding of\x{a}" ~
    "      notation."
  ]
]
model.editorialdeclPart &=
  correction | interpretation | normalization | segmentation | stdvals
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      information regarding the encoding process."
  ]
]
model.encodingPart &=
  appinfo?, projectdesc?, samplingdecl?, editorialdecl?
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      front matter."
  ]
]
model.frontPart &= titlepage
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      the MEI header."
  ]
]
model.headerPart &= encodingdesc?, profiledesc?
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      the physical description of a bibliographic item."
  ]
]
model.physdescPart &=
  condition
  | dimensions
  | exhibithist
  | extent
  | handlist
  | inscription
  | physmedium
  | physloc
  | provenance
  | model.repositoryLike
  | model.frontPart
  | treatmenthist
  | treatmentsched
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      the profile description."
  ]
]
model.profiledescPart &=
  creation?, langusage?, classification?, eventlist*
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      the publication statement for a bibliographic item."
  ]
]
model.pubstmtPart &=
  model.nameLike.geogname
  | model.addressLike
  | respstmt
  | model.dateLike
  | model.identifierLike
  | availability
# Declare module elements
content.meihead = altmeiid*, filedesc, model.headerPart, revisiondesc?
meihead =
  [
    a:documentation [
      xml:lang = "eng"
      "meihead ― A wrapper for general\x{a}" ~
      "        bibliographic and descriptive information about the encoded file. This\x{a}" ~
      "        information is often essential in a machine-readable environment. Five\x{a}" ~
      "        sub-elements must be encoded in the following order:\x{a}" ~
      "        <altmeiid>(optional), <filedesc>(required),\x{a}" ~
      "        <encodingdesc>(optional),\x{a}" ~
      "        <profiledesc;>(optional), and\x{a}" ~
      "        <revisiondesc>(optional). These elements and their\x{a}" ~
      "        sub-elements provide: a unique identifier for the MEI file,\x{a}" ~
      "        bibliographic information about the MEI file and its sources,\x{a}" ~
      "        information about the encoding process, information about the creation\x{a}" ~
      "        of the work being encoded, and statements regarding significant\x{a}" ~
      "        revisions of the file. The xml:lang attribute may be used to indicate\x{a}" ~
      "        the language in which the metadata content of the header is provided. In\x{a}" ~
      "        order to encourage uniformity in the provision of metadata across\x{a}" ~
      "        document types, this element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element meihead { attlist.meihead, content.meihead }
attlist.meihead =
  att.bibl,
  att.common,
  att.lang,
  att.meiversion,
  [
    a:documentation [
      xml:lang = "eng"
      "specifies the kind of document to which\x{a}" ~
      "          the header is attached, that is, whether it is a corpus or an\x{a}" ~
      "          individual text."
    ]
  ]
  attribute type { "music" | "corpus" }?
content.accessdesc = (text | model.textphraseLike.limited)*
accessdesc =
  [
    a:documentation [
      xml:lang = "eng"
      "access description ― Describes the\x{a}" ~
      "        conditions that affect the accessibility of material. May indicate the\x{a}" ~
      "        nature of restrictions or the lack of restrictions. Do not confuse this\x{a}" ~
      "        element with <userestrict> (usage restrictions), which\x{a}" ~
      "        captures information about limitations on the use of material, such as\x{a}" ~
      "        those afforded by copyright. This element is modelled on an element in\x{a}" ~
      "        Encoded Archival Description (EAD)."
    ]
  ]
  element accessdesc { attlist.accessdesc, content.accessdesc }
attlist.accessdesc = att.common, att.bibl, att.lang
content.acqsource = (text | model.textphraseLike.limited)*
acqsource =
  [
    a:documentation [
      xml:lang = "eng"
      "acquisition source ― Post-publication\x{a}" ~
      "        source, such as a vendor or distributor, from which access to a\x{a}" ~
      "        bibliographic item may be obtained, including electronic access. This\x{a}" ~
      "        element is modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element acqsource { attlist.acqsource, content.acqsource }
attlist.acqsource = att.bibl, att.common, att.lang
content.altmeiid = (text | model.textphraseLike.limited)*
altmeiid =
  [
    a:documentation [
      xml:lang = "eng"
      "alternative MEI identifier ― May contain a\x{a}" ~
      "        bibliographic identifier that does not fit within the meihead id\x{a}" ~
      "        attribute, for example because the id does not fit the definition of an\x{a}" ~
      "        XML id or because multiple identifiers are needed. One or the other of\x{a}" ~
      "        <altmeiid> or the id attribute on <mei> is\x{a}" ~
      "        required when applicable."
    ]
  ]
  element altmeiid { attlist.altmeiid, content.altmeiid }
attlist.altmeiid = att.bibl, att.common, att.typed
content.appinfo = application*
appinfo =
  [
    a:documentation [
      xml:lang = "eng"
      "application information ― Groups\x{a}" ~
      "        information about applications which have acted upon the MEI file. This\x{a}" ~
      "        is not to be confused with applications which were used to create the\x{a}" ~
      "        MEI file. The latter may be recorded in the projectdesc element. This\x{a}" ~
      "        element is modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element appinfo { attlist.appinfo, content.appinfo }
attlist.appinfo = att.common
content.application = model.nameLike+, (model.ptrLike* | model.pLike*)
application =
  [
    a:documentation [
      xml:lang = "eng"
      "application ― Provides information about\x{a}" ~
      "        an application which has acted upon the current document. This element\x{a}" ~
      "        is modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element application { attlist.application, content.application }
attlist.application =
  att.common,
  att.datable,
  att.typed,
  [
    a:documentation [
      xml:lang = "eng"
      "supplies a version number for an\x{a}" ~
      "          application, independent of its identifier or display\x{a}" ~
      "          name."
    ]
  ]
  attribute version { text }?
content.availability = model.availabilityPart
availability =
  [
    a:documentation [
      xml:lang = "eng"
      "availability ― Groups elements that\x{a}" ~
      "        describe the availability of and access to a bibliographic item. When\x{a}" ~
      "        used within the filedesc element, availability indicates access to the\x{a}" ~
      "        MEI-encoded document itself. This element is modelled on an element in\x{a}" ~
      "        Encoded Archival Description (EAD)."
    ]
  ]
  element availability { attlist.availability, content.availability }
attlist.availability = att.bibl, att.common
content.change = respstmt, changedesc, model.dateLike
change =
  [
    a:documentation [
      xml:lang = "eng"
      "change ― Individual change within the\x{a}" ~
      "        revision description. Additions, deletions, and significant recoding\x{a}" ~
      "        should be noted, but not correction of minor typographical errors. It is\x{a}" ~
      "        recommended that revisions should be entered in reverse chronological\x{a}" ~
      "        order, with the most recent <change> first. The resp\x{a}" ~
      "        attribute contains a pointer to an element containing info about the\x{a}" ~
      "        person/entity responsible for change. The edition element can be used to\x{a}" ~
      "        designate an MEI encoding that has been so substantively changed that it\x{a}" ~
      "        constitutes a new version that supersedes earlier versions. This element\x{a}" ~
      "        is modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element change { attlist.change, content.change }
attlist.change = att.common, att.bibl
content.changedesc = model.pLike+
changedesc =
  [
    a:documentation [
      xml:lang = "eng"
      "change description ― Description of a\x{a}" ~
      "        revision of the MEI file."
    ]
  ]
  element changedesc { attlist.changedesc, content.changedesc }
attlist.changedesc = att.common, att.bibl, att.lang
content.classcode = text
classcode =
  [
    a:documentation [
      xml:lang = "eng"
      "classification code ― Library of Congress\x{a}" ~
      "        subject or call number, or a thesaurus or ontology citation, for\x{a}" ~
      "        example. The source of controlled-vocabulary terms used in the\x{a}" ~
      "        <keywords> element."
    ]
  ]
  element classcode { attlist.classcode, content.classcode }
attlist.classcode = att.common, att.bibl
content.classification = (classcode | keywords)+
classification =
  [
    a:documentation [
      xml:lang = "eng"
      "classification ― Groups information which\x{a}" ~
      "        describes the nature or topic of a musical work. Although use of names\x{a}" ~
      "        and terms from locally controlled vocabularies is possible, terms used\x{a}" ~
      "        here should come from standard national or international vocabularies\x{a}" ~
      "        whenever they are available in order to enable searches in systems that\x{a}" ~
      "        include multiple MEI documents, or MEI documents and bibliographic\x{a}" ~
      "        records from many institutions."
    ]
  ]
  element classification {
    attlist.classification, content.classification
  }
attlist.classification = att.common, att.bibl
content.condition = (text | model.textphraseLike.limited)*
condition =
  [
    a:documentation [
      xml:lang = "eng"
      "condition ― The physical condition of an\x{a}" ~
      "        item, particularly any variances between the physical makeup of the item\x{a}" ~
      "        and that of other copies of the same item (e.g., missing pages, plates,\x{a}" ~
      "        etc.). Condition may reflect other aspects of the physical condition of\x{a}" ~
      "        the item as well (e.g., brittleness, faded images, etc.). This element\x{a}" ~
      "        is modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element condition { attlist.condition, content.condition }
attlist.condition = att.common, att.bibl, att.lang
content.correction = model.pLike+
correction =
  [
    a:documentation [
      xml:lang = "eng"
      "correction ― States how and under what\x{a}" ~
      "        circumstances corrections have been made in the text. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element correction { attlist.correction, content.correction }
attlist.correction =
  att.common,
  att.bibl,
  att.lang,
  att.regularmethod,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the degree of correction\x{a}" ~
      "          applied to the text."
    ]
  ]
  attribute corrlevel { "high" | "medium" | "low" | "unknown" }?
content.creation = model.textcomponentLike+
creation =
  [
    a:documentation [
      xml:lang = "eng"
      "creation ― Non-bibliographic creation\x{a}" ~
      "        details for the work being encoded, in narrative form. Contains phrases\x{a}" ~
      "        describing the origin of the text, e.g. the date, place, and\x{a}" ~
      "        circumstances of its composition. This element is modelled on an element\x{a}" ~
      "        in the Text Encoding Initiative (TEI)."
    ]
  ]
  element creation { attlist.creation, content.creation }
attlist.creation = att.common, att.bibl, att.lang
content.dimensions = (text | model.textphraseLike.limited)*
dimensions =
  [
    a:documentation [
      xml:lang = "eng"
      "dimensions ― Information about the\x{a}" ~
      "        physical size of a bibliographic source; usually includes numerical\x{a}" ~
      "        data. There are no height and width sub-elements; however, num\x{a}" ~
      "        sub-elements may be used with appropriate n attribute values.\x{a}" ~
      "        Measurements may be expressed in any convenient unit. Do not confuse\x{a}" ~
      "        this element with the <extent> element, which is used to\x{a}" ~
      "        indicate the quantity of described materials. This element is modelled\x{a}" ~
      "        on an element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element dimensions { attlist.dimensions, content.dimensions }
attlist.dimensions = att.common, att.bibl, att.measurement
content.editionstmt = (model.editionLike, respstmt*)+
editionstmt =
  [
    a:documentation [
      xml:lang = "eng"
      "edition statement ― Container for\x{a}" ~
      "        meta-data pertaining to a particular edition of the material being\x{a}" ~
      "        described. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element editionstmt { attlist.editionstmt, content.editionstmt }
attlist.editionstmt = att.common, att.bibl, att.lang
content.editorialdecl =
  model.pLike+ | (model.editorialdeclPart+, model.pLike*)
editorialdecl =
  [
    a:documentation [
      xml:lang = "eng"
      "editorial declaration ― Used to provide\x{a}" ~
      "        details of editorial principles and practices applied during the\x{a}" ~
      "        encoding of musical text. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element editorialdecl { attlist.editorialdecl, content.editorialdecl }
attlist.editorialdecl = att.common, att.bibl, att.lang
content.encodingdesc = model.encodingPart
encodingdesc =
  [
    a:documentation [
      xml:lang = "eng"
      "encoding description ― Documents the\x{a}" ~
      "        relationship between an electronic file and the source or sources from\x{a}" ~
      "        which it was derived as well as applications used in the\x{a}" ~
      "        encoding/editing process. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element encodingdesc { attlist.encodingdesc, content.encodingdesc }
attlist.encodingdesc = att.bibl, att.common
content.exhibithist = (text | model.textphraseLike.limited)*
exhibithist =
  [
    a:documentation [
      xml:lang = "eng"
      "exhibition history ― A record of public\x{a}" ~
      "        exhibitions, including dates, venues, etc. This element is modelled on\x{a}" ~
      "        an element in Encoded Archival Description (EAD)."
    ]
  ]
  element exhibithist { attlist.exhibithist, content.exhibithist }
attlist.exhibithist = att.common, att.bibl, att.lang
content.extent = (text | model.textphraseLike.limited)*
extent =
  [
    a:documentation [
      xml:lang = "eng"
      "extent ― Used to express size in terms\x{a}" ~
      "        other than physical dimensions, such as number of pages, number of\x{a}" ~
      "        records in file, number of bytes, performance duration for music, audio\x{a}" ~
      "        recordings and visual projections, etc. Use the\x{a}" ~
      "        <dimensions> element when it is necessary to specify the\x{a}" ~
      "        physical size of materials being described, for example, height and\x{a}" ~
      "        width. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element extent { attlist.extent, content.extent }
attlist.extent = att.common, att.bibl, att.measurement
content.filedesc =
  titlestmt,
  editionstmt?,
  extent?,
  fingerprint?,
  pubstmt,
  seriesstmt?,
  notesstmt?,
  sourcedesc?
filedesc =
  [
    a:documentation [
      xml:lang = "eng"
      "file description ― Contains a full\x{a}" ~
      "        bibliographic description of the MEI file. Extent in this context is\x{a}" ~
      "        file size. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element filedesc { attlist.filedesc, content.filedesc }
attlist.filedesc = att.bibl, att.common
content.fingerprint = text
fingerprint =
  [
    a:documentation [
      xml:lang = "eng"
      "fingerprint ― Traditionally, an\x{a}" ~
      "        identifier, constructed by combining groups of characters transcribed\x{a}" ~
      "        from specified pages of a printed item, which makes it possible to\x{a}" ~
      "        signal differences between copies of the item. For an electronic item,\x{a}" ~
      "        such as an MEI file, however, the fingerprint should be a\x{a}" ~
      "        checksum."
    ]
  ]
  element fingerprint { attlist.fingerprint, content.fingerprint }
attlist.fingerprint = att.common, att.lang
content.hand = (text | model.textphraseLike.limited)*
hand =
  [
    a:documentation [
      xml:lang = "eng"
      "hand ― Defines a distinct scribe or\x{a}" ~
      "        handwriting style. The initial attribute indicates whether this is the\x{a}" ~
      "        first or main scribe of the document. The medium attribute describes the\x{a}" ~
      "        writing medium, e.g., 'pencil', or the tint or type of ink, e.g.\x{a}" ~
      "        'brown'. The resp attribute contains an ID reference to an element\x{a}" ~
      "        containing the name of the editor or transcriber responsible for\x{a}" ~
      "        identifying the hand. The characteristics of the hand, particularly\x{a}" ~
      "        those related to the quality of the writing, such as 'shaky', 'thick',\x{a}" ~
      "        etc. may be described within the content of the hand element. This\x{a}" ~
      "        element is modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element hand { attlist.hand, content.hand }
attlist.hand =
  att.common,
  att.bibl,
  att.lang,
  att.medium,
  att.responsibility,
  [
    a:documentation [
      xml:lang = "eng"
      "marks this hand as the initial one of\x{a}" ~
      "          the document."
    ]
  ]
  attribute initial { data.BOOLEAN }?
content.handlist = hand+
handlist =
  [
    a:documentation [
      xml:lang = "eng"
      "hand list ― Container for one or more hand\x{a}" ~
      "        elements. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element handlist { attlist.handlist, content.handlist }
attlist.handlist = att.common, att.bibl
content.inscription =
  (text
   | model.textphraseLike.limited
   | model.editLike
   | model.transcriptionLike)*
inscription =
  [
    a:documentation [
      xml:lang = "eng"
      "inscription ― An inscription added to an\x{a}" ~
      "        item, such as a bookplate, a note designating the item as a gift, and/or\x{a}" ~
      "        the author's signature."
    ]
  ]
  element inscription { attlist.inscription, content.inscription }
attlist.inscription = att.common, att.bibl, att.lang
content.interpretation = model.pLike+
interpretation =
  [
    a:documentation [
      xml:lang = "eng"
      "interpretation ― Describes the scope of\x{a}" ~
      "        any analytic or interpretive information added to the transcription of\x{a}" ~
      "        the music. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element interpretation {
    attlist.interpretation, content.interpretation
  }
attlist.interpretation = att.common, att.bibl, att.lang
content.keywords = term+
keywords =
  [
    a:documentation [
      xml:lang = "eng"
      "keywords ― Collection of keywords or text\x{a}" ~
      "        phrases which describe the work. This element is modelled on an element\x{a}" ~
      "        in the Text Encoding Initiative (TEI)."
    ]
  ]
  element keywords { attlist.keywords, content.keywords }
attlist.keywords = att.common, att.bibl
content.language = (text | model.textphraseLike.limited)*
language =
  [
    a:documentation [
      xml:lang = "eng"
      "language ― Description of a language used\x{a}" ~
      "        in the document. A text element may be related to this element via its\x{a}" ~
      "        xml:lang attribute, which normally takes the form of a code, drawn from\x{a}" ~
      "        a coded list, such as ISO639-2b. The name of the authorizing list may be\x{a}" ~
      "        encoded in the authority attribute. This element is modelled on an\x{a}" ~
      "        element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element language { attlist.language, content.language }
attlist.language = att.common, att.bibl, att.authorized
content.langusage = language+
langusage =
  [
    a:documentation [
      xml:lang = "eng"
      "language usage ― Langusage groups elements\x{a}" ~
      "        describing the languages, sublanguages, dialects, etc., represented\x{a}" ~
      "        within the encoded work. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element langusage { attlist.langusage, content.langusage }
attlist.langusage = att.common, att.bibl
content.normalization = model.pLike+
normalization =
  [
    a:documentation [
      xml:lang = "eng"
      "normalization ― Indicates the extent of\x{a}" ~
      "        normalization or regularization of the original source carried out in\x{a}" ~
      "        converting it to electronic form. This element is modelled on an element\x{a}" ~
      "        in the Text Encoding Initiative (TEI)."
    ]
  ]
  element normalization { attlist.normalization, content.normalization }
attlist.normalization =
  att.common, att.bibl, att.lang, att.regularmethod
content.notesstmt = model.annotLike+
notesstmt =
  [
    a:documentation [
      xml:lang = "eng"
      "notes statement ― Groups bibliographic\x{a}" ~
      "        annotations, each of which provides descriptive information in addition\x{a}" ~
      "        to that recorded in other parts of the bibliographic description. These\x{a}" ~
      '        annotations are similar to "general notes" in traditional bibliographic\x{a}' ~
      "        descriptions. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element notesstmt { attlist.notesstmt, content.notesstmt }
attlist.notesstmt = att.common, att.bibl
content.physdesc = model.physdescPart+
physdesc =
  [
    a:documentation [
      xml:lang = "eng"
      "physical description ― Container for\x{a}" ~
      "        information about the location, appearance, construction, or handling of\x{a}" ~
      "        physical materials, such as their dimension, quantity, color, style, and\x{a}" ~
      "        technique of creation. Dedicatory text and title page features may also\x{a}" ~
      "        be encoded here when they are not transcribed as part of the front or\x{a}" ~
      "        back matter; i.e., when they are considered to be meta-data rather than\x{a}" ~
      "        a transcription. This element is modelled on an element in Encoded\x{a}" ~
      "        Archival Description (EAD)."
    ]
  ]
  element physdesc { attlist.physdesc, content.physdesc }
attlist.physdesc = att.common, att.bibl
content.physloc = (text | model.textphraseLike.limited)*
physloc =
  [
    a:documentation [
      xml:lang = "eng"
      "physical location ― Location of the source\x{a}" ~
      "        within a repository, e.g., shelf mark or other locational information.\x{a}" ~
      "        This element is modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element physloc { attlist.physloc, content.physloc }
attlist.physloc = att.common, att.bibl
content.physmedium = (text | model.textphraseLike.limited)*
physmedium =
  [
    a:documentation [
      xml:lang = "eng"
      "physical medium ― Records the physical\x{a}" ~
      "        materials used in the source, such as ink and paper. All materials may\x{a}" ~
      "        be described in a single <physmedium> element or multiple\x{a}" ~
      "        elements may be used, one for each medium. This element is modelled on\x{a}" ~
      "        an element in Encoded Archival Description (EAD)."
    ]
  ]
  element physmedium { attlist.physmedium, content.physmedium }
attlist.physmedium = att.common, att.bibl, att.authorized, att.lang
content.price = (text | model.textphraseLike.limited)*
price =
  [
    a:documentation [
      xml:lang = "eng"
      "price ― The cost of access to a\x{a}" ~
      "        bibliographic item."
    ]
  ]
  element price { attlist.price, content.price }
attlist.price = att.common, att.bibl, att.measurement
content.profiledesc = model.profiledescPart
profiledesc =
  [
    a:documentation [
      xml:lang = "eng"
      "profile description ― A detailed\x{a}" ~
      "        description of the non-bibliographic aspects of the creation of a\x{a}" ~
      "        musical work, specifically the languages and sublanguages used, the\x{a}" ~
      "        situation in which it was produced, e.g. the participants, setting,\x{a}" ~
      "        reception history, etc. Do not confuse this with\x{a}" ~
      "        <filedesc>, which bundles bibliographic information about\x{a}" ~
      "        the creation of the MEI file. This element is modelled on an element in\x{a}" ~
      "        the Text Encoding Initiative (TEI)."
    ]
  ]
  element profiledesc { attlist.profiledesc, content.profiledesc }
attlist.profiledesc = att.bibl, att.common
content.projectdesc = model.pLike+
projectdesc =
  [
    a:documentation [
      xml:lang = "eng"
      "project description ― Project-level\x{a}" ~
      "        meta-data describing the aim or purpose for which the electronic file\x{a}" ~
      "        was encoded, funding agencies, etc. together with any other relevant\x{a}" ~
      "        information concerning the process by which it was assembled or\x{a}" ~
      "        collected. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element projectdesc { attlist.projectdesc, content.projectdesc }
attlist.projectdesc = att.common, att.bibl, att.lang
content.provenance = eventlist? | (text | model.textphraseLike.limited)*
provenance =
  [
    a:documentation [
      xml:lang = "eng"
      "provenance ― The record of ownership or\x{a}" ~
      "        custodianship of an item. This element is modelled on an element in the\x{a}" ~
      "        Encoded Archival Description (EAD) and Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element provenance { attlist.provenance, content.provenance }
attlist.provenance = att.common, att.bibl, att.lang
content.pubstmt = unpub? | model.pubstmtPart*
pubstmt =
  [
    a:documentation [
      xml:lang = "eng"
      "publication statement ― Container for\x{a}" ~
      "        information regarding the publication or distribution of a bibliographic\x{a}" ~
      "        item, including the publisher's name and address, the date of\x{a}" ~
      "        publication, and other relevant details. When an item is unpublished,\x{a}" ~
      "        use only the <unpub> sub-element. This element is modelled\x{a}" ~
      "        on an element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element pubstmt { attlist.pubstmt, content.pubstmt }
attlist.pubstmt = att.common, att.bibl
content.resp = text
resp =
  [
    a:documentation [
      xml:lang = "eng"
      "responsibility ― A phrase describing the\x{a}" ~
      "        nature of a person's intellectual responsibility. The name of the list\x{a}" ~
      "        from which a controlled value is taken may be recorded using the\x{a}" ~
      "        authority attribute. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element resp { attlist.resp, content.resp }
attlist.resp = att.authorized
content.respstmt = (resp | model.nameLike | model.nameLike.agent)*
respstmt =
  [
    a:documentation [
      xml:lang = "eng"
      "responsibility statement ― Names one or\x{a}" ~
      "        more individuals, groups, or in rare cases, mechanical processes,\x{a}" ~
      "        responsible for creation or realization of the intellectual or artistic\x{a}" ~
      "        content. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element respstmt { attlist.respstmt, content.respstmt }
attlist.respstmt = att.bibl, att.common
content.revisiondesc = change+
revisiondesc =
  [
    a:documentation [
      xml:lang = "eng"
      "revision description ― Container for\x{a}" ~
      "        information about alterations that have been made to an MEI file. It is\x{a}" ~
      "        recommended that changes be recorded in reverse chronological order,\x{a}" ~
      "        with the most recent alteration first. This element is modelled on an\x{a}" ~
      "        element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element revisiondesc { attlist.revisiondesc, content.revisiondesc }
attlist.revisiondesc = att.common, att.bibl
content.samplingdecl = model.pLike+
samplingdecl =
  [
    a:documentation [
      xml:lang = "eng"
      "sampling declaration ― Contains a prose\x{a}" ~
      "        description of the rationale and methods used in sampling texts in the\x{a}" ~
      "        creation of a corpus or collection. This element is modelled on an\x{a}" ~
      "        element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element samplingdecl { attlist.samplingdecl, content.samplingdecl }
attlist.samplingdecl = att.common, att.bibl, att.lang
content.segmentation = model.pLike+
segmentation =
  [
    a:documentation [
      xml:lang = "eng"
      "segmentation ― Describes the principles\x{a}" ~
      "        according to which the musical text has been segmented, for example into\x{a}" ~
      "        movements, sections, etc. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element segmentation { attlist.segmentation, content.segmentation }
attlist.segmentation = att.common, att.bibl, att.lang
content.seriesstmt =
  model.titleLike+,
  respstmt*,
  model.identifierLike*,
  (model.listLike | seriesstmt*)
seriesstmt =
  [
    a:documentation [
      xml:lang = "eng"
      "series statement ― Groups information\x{a}" ~
      "        about the series, if any, to which a publication belongs. In this\x{a}" ~
      "        context, the title element records the series title, the respStmt\x{a}" ~
      "        element records the person or group responsible for the series, and the\x{a}" ~
      "        identifier element contains a series identifier. The list element should\x{a}" ~
      "        be used when it is necessary to enumerate the contents of the series.\x{a}" ~
      "        The seriesstmt is provided within seriesstmt for the description of a\x{a}" ~
      "        sub-series. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element seriesstmt { attlist.seriesstmt, content.seriesstmt }
attlist.seriesstmt = att.common, att.bibl
content.source =
  model.identifierLike*,
  titlestmt?,
  editionstmt?,
  pubstmt,
  physdesc?,
  seriesstmt?,
  notesstmt?,
  langusage?,
  classification?
source =
  [
    a:documentation [
      xml:lang = "eng"
      "source ― A bibliographic description of a\x{a}" ~
      "        source for the electronic file. Multiple physdesc sub-elements may be\x{a}" ~
      "        used to describe the physically separate parts of a single source. The\x{a}" ~
      "        data attribute may be used to reference one or more features that occur\x{a}" ~
      "        in this particular source. This element is modelled on the sourcedesc\x{a}" ~
      "        element in the Text Encoding Initiative (TEI)."
    ]
  ]
  element source { attlist.source, content.source }
attlist.source = att.datapointing, att.common, att.bibl
content.sourcedesc = source+
sourcedesc =
  [
    a:documentation [
      xml:lang = "eng"
      "source description ― A container for the\x{a}" ~
      "        descriptions of the source(s) used in the creation of the electronic\x{a}" ~
      "        file. This element is recommended where the MEI file is a transcription\x{a}" ~
      "        of existing music, but is not required when the data is originally\x{a}" ~
      "        created in MEI form."
    ]
  ]
  element sourcedesc { attlist.sourcedesc, content.sourcedesc }
attlist.sourcedesc = att.common
content.stdvals = model.pLike+
stdvals =
  [
    a:documentation [
      xml:lang = "eng"
      "standard values ― Specifies the format\x{a}" ~
      "        used when standardized date or number values are supplied. This element\x{a}" ~
      "        is modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element stdvals { attlist.stdvals, content.stdvals }
attlist.stdvals = att.common, att.bibl, att.lang
content.sysreq = (text | model.textphraseLike.limited)*
sysreq =
  [
    a:documentation [
      xml:lang = "eng"
      "system requirements ― System requirements\x{a}" ~
      "        for using the electronic item."
    ]
  ]
  element sysreq { attlist.sysreq, content.sysreq }
attlist.sysreq = att.common, att.bibl, att.lang
content.term = (text | term | model.textphraseLike.limited)*
term =
  [
    a:documentation [
      xml:lang = "eng"
      "term ― Single keyword or phrase which\x{a}" ~
      "        describes the work. The classcode attribute may be used to link the term\x{a}" ~
      "        to a terminological source given in a classcode element. The term\x{a}" ~
      "        element may include other term elements in order to allow the creation\x{a}" ~
      "        of coordinated terms; i.e., terms created from a combination of other,\x{a}" ~
      "        independent terms. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element term { attlist.term, content.term }
attlist.term =
  att.common,
  att.bibl,
  [
    a:documentation [
      xml:lang = "eng"
      "contains a reference to the controlled\x{a}" ~
      "          vocabulary from which the term is drawn. The value must match the\x{a}" ~
      "          value of an ID attribute on a classcode element given elsewhere in the\x{a}" ~
      "          document."
    ]
  ]
  attribute classcode { xsd:IDREF }?
content.titlestmt = model.titleLike+, respstmt*
titlestmt =
  [
    a:documentation [
      xml:lang = "eng"
      "title statement ― Container for title and\x{a}" ~
      "        responsibility meta-data. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element titlestmt { attlist.titlestmt, content.titlestmt }
attlist.titlestmt = att.bibl, att.common
content.treatmenthist = (text | model.textphraseLike.limited)*
treatmenthist =
  [
    a:documentation [
      xml:lang = "eng"
      "treatment history ― A record of the\x{a}" ~
      "        treatment the item has undergone (e.g., deacidification, restoration,\x{a}" ~
      "        etc.) Treatment history may also comprise details of the treatment\x{a}" ~
      "        process (e.g., chemical solutions used, techniques applied, etc.), the\x{a}" ~
      "        date the treatment was applied, etc. This element is modelled on an\x{a}" ~
      "        element in Encoded Archival Description (EAD)."
    ]
  ]
  element treatmenthist { attlist.treatmenthist, content.treatmenthist }
attlist.treatmenthist = att.common, att.bibl
content.treatmentsched = (text | model.textphraseLike.limited)*
treatmentsched =
  [
    a:documentation [
      xml:lang = "eng"
      "treatment scheduled ― Scheduled treatment,\x{a}" ~
      "        e.g. deacidification, restoration, etc., for an item. This element is\x{a}" ~
      "        modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element treatmentsched {
    attlist.treatmentsched, content.treatmentsched
  }
attlist.treatmentsched = att.common, att.bibl
content.unpub = text
unpub =
  [
    a:documentation [
      xml:lang = "eng"
      "unpublished ― Used to explicitly indicate\x{a}" ~
      "        that a bibliographic source is unpublished. A short phrase indicating\x{a}" ~
      "        the nature of or the reason for the unpublished status may be given as\x{a}" ~
      "        the element's content."
    ]
  ]
  element unpub { attlist.unpub, content.unpub }
attlist.unpub = att.common, att.bibl
content.userestrict = (text | model.textphraseLike.limited)*
userestrict =
  [
    a:documentation [
      xml:lang = "eng"
      "usage restrictions ― Container for\x{a}" ~
      "        information about the conditions that affect use of a bibliographic item\x{a}" ~
      "        after access has been granted. It may indicate limitations imposed by an\x{a}" ~
      "        owner, repository, or legal statute (for example, copyright law)\x{a}" ~
      "        regarding the reproduction, publication, or quotation of the item. It\x{a}" ~
      "        may also indicate the absence of restrictions, such as when rights have\x{a}" ~
      "        been ceded to the public domain. Do not confuse this element with the\x{a}" ~
      "        <accessdesc> element, which holds information about\x{a}" ~
      "        conditions affecting the availability of the material. This element is\x{a}" ~
      "        modelled on an element in Encoded Archival Description\x{a}" ~
      "        (EAD)."
    ]
  ]
  element userestrict { attlist.userestrict, content.userestrict }
attlist.userestrict = att.common, att.bibl
eventlist =
  [
    a:documentation [
      xml:lang = "eng"
      "event list ― Contains historical\x{a}" ~
      "        information given as a sequence of significant past events.\x{a}" ~
      "        <eventlist> contains <event> elements that\x{a}" ~
      "        contain a brief description of the associated event, including dates and\x{a}" ~
      "        locations where the event took place. An <eventlist>\x{a}" ~
      "        describes events associated with a work when it appears in the\x{a}" ~
      "        <profiledesc> element or events associated with the\x{a}" ~
      "        custodial history of a given copy of a source for the encoding when it\x{a}" ~
      "        appears within the <source> element. The type attribute\x{a}" ~
      "        may be used to distinguish between event lists with different functions,\x{a}" ~
      "        such as a list of events in the compositional process and a list of\x{a}" ~
      "        performance dates."
    ]
  ]
  element eventlist { attlist.eventlist, content.eventlist }
attlist.eventlist = att.bibl, att.common, att.typed
content.eventlist = event+
event =
  [
    a:documentation [
      xml:lang = "eng"
      "event ― contains a description of an\x{a}" ~
      "        event, including the dates and locations of its occurrence and prominent\x{a}" ~
      "        participants. When a single date can be associated with the event, the\x{a}" ~
      "        attributes in the att.datable class may provide a more\x{a}" ~
      "        machine-processable alternative than date elements within the content of\x{a}" ~
      "        <event>. <table> and <list>\x{a}" ~
      "        elements are allowed within <event> in order to\x{a}" ~
      "        accommodate structured content."
    ]
  ]
  element event { attlist.event, content.event }
attlist.event =
  att.bibl, att.calendared, att.common, att.datable, att.edit, att.lang
content.event =
  (text
   | model.textphraseLike.limited
   | model.tableLike
   | model.listLike)*
