# **************************************************************

# NAME:     Music Encoding Initiative (MEI) schema component:
#           cmn_Module.rng
# 
# NOTICE:   Copyright (c) 2010 by the Music Encoding Initiative (MEI)
#           Council.
# 
#           Licensed under the Educational Community License, Version
#           2.0 (the "License"); you may not use this file except in
#           compliance with the License. You may obtain a copy of the
#           License at http://www.osedu.org/licenses/ECL-2.0.
# 
#           Unless required by applicable law or agreed to in writing,
#           software distributed under the License is distributed on
#           an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#           KIND, either express or implied. See the License for the
#           specific language governing permissions and limitations
#           under the License.
# 
#           This is a derivative work based on earlier versions of the
#           schema copyright (c) 2001-2006 Perry Roland and the Rector
#           and Visitors of the University of Virginia; licensed under
#           the Educational Community License version 1.0.
# 
# CONTACT:  contact@music-encoding.org 

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
default namespace mei = "http://www.music-encoding.org/ns/mei"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
namespace xhtml = "http://www.w3.org/1999/xhtml"
namespace xlink = "http://www.w3.org/1999/xlink"

# CMN module

# Declare module attr classes
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that indicate whether an event\x{a}" ~
    "      lies under a beam"
  ]
]
att.beamed &=
  [
    a:documentation [
      xml:lang = "eng"
      'indicates that this event is "under a\x{a}' ~
      '          beam".'
    ]
  ]
  attribute beam { data.BEAMS }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes indicating cross-staff\x{a}" ~
    "      beaming"
  ]
]
att.beamedwith &=
  [
    a:documentation [
      xml:lang = "eng"
      "In the case of cross-staff beams, the\x{a}" ~
      "          with attribute is used to indicate which staff the beam is connected\x{a}" ~
      "          to; that is, the staff above or the staff below."
    ]
  ]
  attribute beam.with { data.OTHERSTAFF }?

## Used by layerdef, staffdef, and scoredef to provide default
##       values for attributes in the logical domain related to
##       beaming
att.beaming.log &=
  [
    a:documentation [
      xml:lang = "eng"
      "provides an example of how automated\x{a}" ~
      "          beaming (including secondary beams) is to be performed. It can be used\x{a}" ~
      "          to set a default beaming pattern to be used when no beaming is\x{a}" ~
      "          indicated at the event level. beam.group must contain a\x{a}" ~
      "          comma-separated list of time values that add up to a measure, e.g., in\x{a}" ~
      "          4/4 time '4,4,4,4' indicates each quarter note worth of shorter notes\x{a}" ~
      "          would be beamed together. Parentheses can be used to indicate\x{a}" ~
      "          sub-groupings of secondary beams. For example, '(4.,4.,4.)' in 9/8\x{a}" ~
      "          meter indicates one outer beam per measure with secondary beams broken\x{a}" ~
      "          at each dotted quarter duration, while a measure of 16th notes in 4/4\x{a}" ~
      "          with beam.group equal to '(4,4),(4,4)' will result in a primary beam\x{a}" ~
      "          covering all the notes and secondary beams each group of 4 notes. This\x{a}" ~
      '          beaming "directive" can be overridden by using <beam>\x{a}' ~
      "          elements. If neither <beam> elements or the beam.group\x{a}" ~
      "          attribute is used, then no beaming is rendered. Beaming can be 'turned\x{a}" ~
      "          off' by setting beam.group to an empty string."
    ]
  ]
  attribute beam.group { text }?,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates whether automatically-drawn\x{a}" ~
      "          beams should include rests shorter than a quarter note\x{a}" ~
      "          duration."
    ]
  ]
  attribute beam.rests { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that record the visual rendition\x{a}" ~
    "      of beams"
  ]
]
att.beamrend &=
  [
    a:documentation [
      xml:lang = "eng"
      "captures whether a beam is feathered and\x{a}" ~
      "          in which direction: 'acc' indicates that the secondary beams get\x{a}" ~
      "          progressively closer together, coming together at the end of the beam,\x{a}" ~
      "          while 'rit' means that the secondary beams start at the same point and\x{a}" ~
      "          get progressively more distant."
    ]
  ]
  attribute rend { "acc" | "rit" | "norm" }?,
  [
    a:documentation [
      xml:lang = "eng"
      "records the slope of the\x{a}" ~
      "          beam."
    ]
  ]
  attribute slope { xsd:decimal }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that capture informtion about\x{a}" ~
    "      secondary beaming"
  ]
]
att.beamsecondary &=
  [
    a:documentation [
      xml:lang = "eng"
      "presence of this attribute indicates\x{a}" ~
      "          that the secondary beam should be broken following this note/chord.\x{a}" ~
      "          The value of the attribute records the number of beams which should\x{a}" ~
      "          remain unbroken."
    ]
  ]
  attribute breaksec { xsd:positiveInteger }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that indicate how to render\x{a}" ~
    "      stafflines behind a measure"
  ]
]
att.cutout &=
  [
    a:documentation [
      xml:lang = "eng"
      "Presence of the cutout attribute\x{a}" ~
      "          indicates that the staff lines should not be drawn for the measure\x{a}" ~
      "          containing this element."
    ]
  ]
  attribute cutout { "cutout" }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that indicate whether to render a\x{a}" ~
    "      repeat symbol or the source material to which it refers"
  ]
]
att.expandable &=
  [
    a:documentation [
      xml:lang = "eng"
      "indicates whether to render a repeat\x{a}" ~
      "          symbol or the source material to which it refers."
    ]
  ]
  attribute expand { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that mark a note or chord as a\x{a}" ~
    '      "grace", how it should "steal" time, and how much time should be allotted\x{a}' ~
    "      to the grace note/chord."
  ]
]
att.graced &=
  [
    a:documentation [
      xml:lang = "eng"
      'marks a note or chord as a "grace"\x{a}' ~
      "          (without a definitive written duration) and records from which other\x{a}" ~
      '          note/chord it should "steal" time.'
    ]
  ]
  attribute grace { data.GRACE }?,
  [
    a:documentation [
      xml:lang = "eng"
      "records the amount of time to be\x{a}" ~
      '          "stolen" from a non-grace note/chord.'
    ]
  ]
  attribute grace.time { data.PERCENT }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that indicate the presence of an\x{a}" ~
    "      l.v. (laissez vibrer) marking attached to a feature"
  ]
]
att.lvpresent &=
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the attachment of an l.v.\x{a}" ~
      "          (laissez vibrer) sign to this element."
    ]
  ]
  attribute lv { data.BOOLEAN }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.measure.vis &= att.barplacement, att.measurement, att.width
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that record numbers to be\x{a}" ~
    "      displayed with a feature"
  ]
]
att.numbered &=
  [
    a:documentation [
      xml:lang = "eng"
      "used to store a number to be rendered\x{a}" ~
      "          along with a feature."
    ]
  ]
  attribute num { xsd:positiveInteger }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that record the placement and\x{a}" ~
    "      visibility of numbers that accompany a bowed tremolo or\x{a}" ~
    "      tuplet"
  ]
]
att.numberplacement &=
  [
    a:documentation [
      xml:lang = "eng"
      "states where the tuplet number will be\x{a}" ~
      "          placed in relation to the noteheads."
    ]
  ]
  attribute num.place { data.PLACE }?,
  [
    a:documentation [
      xml:lang = "eng"
      "determines if the tuplet number is\x{a}" ~
      "          visible."
    ]
  ]
  attribute num.visible { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that describe the rendition of\x{a}" ~
    "      slurs"
  ]
]
att.slurrend &=
  [
    a:documentation [
      xml:lang = "eng"
      "describes the appearance of\x{a}" ~
      "          slurs."
    ]
  ]
  attribute slur.rend { data.CURVERENDITION }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that describe the properties of\x{a}" ~
    "      stemmed features; that is, chords and notes"
  ]
]
att.stemmed &=
  [
    a:documentation [
      xml:lang = "eng"
      'encodes any stem "modifiers"; that is,\x{a}' ~
      "          symbols rendered on the stem, such as tremolo or Sprechstimme\x{a}" ~
      "          indicators."
    ]
  ]
  attribute stem.mod { data.STEMMODIFIER }?,
  [
    a:documentation [
      xml:lang = "eng"
      "contains an indication of which staff a\x{a}" ~
      "          note or chord that logically belongs to the current staff should be\x{a}" ~
      "          visually placed on; that is, the one above or the one\x{a}" ~
      "          below."
    ]
  ]
  attribute stem.with { data.OTHERSTAFF }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes that describe the rendition of\x{a}" ~
    "      ties"
  ]
]
att.tierend &=
  [
    a:documentation [
      xml:lang = "eng"
      "describes the appearance of\x{a}" ~
      "          ties."
    ]
  ]
  attribute tie.rend { data.CURVERENDITION }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.arpeg.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.arpeg.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.arpeg.log &=
  att.controlevent,
  [
    a:documentation [
      xml:lang = "eng"
      "describes the direction in which the\x{a}" ~
      "          arpeggio is to be performed (up = lowest to highest, down = highest to\x{a}" ~
      "          lowest) or a return to a non-arpeggiated style (nonarp, usually\x{a}" ~
      "          rendered with a preceding bracket instead of a wavy\x{a}" ~
      "          line)."
    ]
  ]
  attribute order { "up" | "down" | "nonarp" }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.arpeg.vis &=
  att.color,
  att.visualoffset,
  att.xy,
  [
    a:documentation [
      xml:lang = "eng"
      "may be used when an arrowhead is to be\x{a}" ~
      "          drawn as part of the arpeggiation symbol."
    ]
  ]
  attribute arrow { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.beam.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.beam.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.beam.log &= att.event, att.beamedwith
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.beam.vis &= att.beamrend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.beamspan.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.beamspan.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.beamspan.log &=
  att.controlevent, att.startendid, att.beamedwith, att.duration.musical
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.beamspan.vis &= att.beamrend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.beatrpt.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.beatrpt.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.beatrpt.log &= att.event
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.beatrpt.vis &=
  att.altsym,
  att.color,
  att.expandable,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the number of slashes required\x{a}" ~
      "        to render the appropriate beat repeat symbol. When a single beat is\x{a}" ~
      "        repeated, consisting of a single note or chord, it is indicated by a\x{a}" ~
      "        single thick, slanting slash; therefore, the value '1' should be used.\x{a}" ~
      "        The following values should be used when the beat is divided into even\x{a}" ~
      "        notes: 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5. When the\x{a}" ~
      "        beat is comprised of mixed duration values, the symbol is always\x{a}" ~
      "        rendered as 2 slashes and 2 dots."
    ]
  ]
  attribute rend { data.BEATRPT.REND }
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.bend.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.bend.ges &=
  [
    a:documentation [
      xml:lang = "eng"
      "records the amount of detuning. The\x{a}" ~
      "          decimal values should be rendered as a fraction (or an integer plus a\x{a}" ~
      "          fraction) along with the bend symbol."
    ]
  ]
  attribute amount { data.BEND.AMOUNT }?
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.bend.log &= att.controlevent, att.startendid
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes. If the bulge or\x{a}" ~
    "      bezier attributes are present, the bend should be rendered as a curve.\x{a}" ~
    "      Otherwise, it should be rendered using lines. The ho and vo attributes\x{a}" ~
    "      describe the visual offset of the entire rendered bend. The endho, endvo\x{a}" ~
    "      and startho, startvo attribute pairs may be used to encode start and end\x{a}" ~
    "      points relative to their programmatic placement. For exact placement of\x{a}" ~
    "      the endpoints of the bend, use the x and y attributes."
  ]
]
att.bend.vis &=
  att.color,
  att.visualoffset,
  att.visualoffset2,
  att.xy,
  att.xy2,
  att.curvature,
  att.curverend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.breath.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.breath.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.breath.log &= att.controlevent, att.startendid
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.breath.vis &=
  att.altsym, att.color, att.placement, att.visualoffset, att.xy
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.btrem.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.btrem.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.btrem.log &=
  att.event,
  att.numbered,
  att.slashcount,
  [
    a:documentation [
      xml:lang = "eng"
      "describes the bowed tremolo as measured\x{a}" ~
      "          or unmeasured."
    ]
  ]
  attribute form { "meas" | "unmeas" }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.btrem.vis &= att.numberplacement
att.chord.ges &= att.graced
att.chord.log &= att.beamed, att.lvpresent
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes for chord. The\x{a}" ~
    "      slur, slur.dir, slur.rend, tie, tie.dir, and tie.rend attributes here are\x{a}" ~
    """      "syntactic sugar" for these attributes on each of the chord's individual\x{a}""" ~
    "      notes. The values here apply to all the notes in the chord. If some notes\x{a}" ~
    "      are slurred or tied while others aren't, then the individual note\x{a}" ~
    "      attributes must be used."
  ]
]
att.chord.vis &= att.beamsecondary
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.fermata.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.fermata.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.fermata.log &= att.controlevent, att.startendid
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.fermata.vis &=
  att.altsym,
  att.color,
  att.placement,
  att.visualoffset,
  att.xy,
  [
    a:documentation [
      xml:lang = "eng"
      "describes the visual appearance of the\x{a}" ~
      "          fermata."
    ]
  ]
  attribute form { "inv" | "norm" }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.ftrem.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.ftrem.ges &=
  [
    a:documentation [
      xml:lang = "eng"
      "describes whether the tremolo is\x{a}" ~
      "          measured or unmeasured."
    ]
  ]
  attribute form { "meas" | "unmeas" }?
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.ftrem.log &= att.event
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.ftrem.vis &= att.slashcount
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.gliss.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.gliss.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.gliss.log &= att.controlevent, att.startendid
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.gliss.vis &=
  att.color,
  att.visualoffset,
  att.visualoffset2,
  att.xy,
  att.xy2,
  att.linerend,
  [
    a:documentation [
      xml:lang = "eng"
      "records any text, such as 'gliss', that\x{a}" ~
      "          accompanies the glissando mark."
    ]
  ]
  attribute text { text }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.hairpin.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.hairpin.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.hairpin.log &=
  att.controlevent,
  att.startendid,
  att.duration.timestamp,
  [
    a:documentation [
      xml:lang = "eng"
      "captures the form and function of the\x{a}" ~
      "        hairpin."
    ]
  ]
  attribute form { "cres" | "dim" }
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes. The startho and\x{a}" ~
    "      startvo attributes record the horizontal and vertical offsets of the left\x{a}" ~
    "      end, endho and endvo record the horizontal and vertical offsets of the\x{a}" ~
    "      right end, and the width attribute records the width of the opening on the\x{a}" ~
    "      open end in one-half staff inter-line units. The x1 and y1 attributes give\x{a}" ~
    "      the absolute coordinates of the left side of the top line of the hairpin\x{a}" ~
    "      while x2 and y2 record the coordinates of the right side of the top line.\x{a}" ~
    "      The position of the end points of the bottom line can be calculated using\x{a}" ~
    "      the top line coordinates and the value of the width\x{a}" ~
    "      attribute."
  ]
]
att.hairpin.vis &=
  att.color,
  att.placement,
  att.visualoffset,
  att.visualoffset2,
  att.xy,
  att.xy2,
  [
    a:documentation [
      xml:lang = "eng"
      "specifies the distance between the\x{a}" ~
      "          points of the open end of a hairpin dynamic mark."
    ]
  ]
  attribute opening { data.INTERLINE }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.halfmrpt.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.halfmrpt.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.halfmrpt.log &= att.event, att.duration.musical
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.halfmrpt.vis &=
  att.altsym, att.color, att.expandable, att.visualoffset
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.harppedal.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.harppedal.ges &= att.duration.performed
[
  a:documentation [
    xml:lang = "eng"
    "Logical domain attributes. The pedal\x{a}" ~
    "      setting, i.e., flat, natural, or sharp, for each diatonic pitch name is\x{a}" ~
    "      indicated by the seven letter-named attributes."
  ]
]
att.harppedal.log &=
  att.controlevent,
  att.startendid,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's C strings."
    ]
  ]
  attribute c { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's D strings."
    ]
  ]
  attribute d { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's E strings."
    ]
  ]
  attribute e { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's F strings."
    ]
  ]
  attribute f { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's G strings."
    ]
  ]
  attribute g { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's A strings."
    ]
  ]
  attribute a { "f" | "n" | "s" }?,
  [
    a:defaultValue = "n"
    a:documentation [
      xml:lang = "eng"
      "indicates the pedal setting, i.e., flat,\x{a}" ~
      "          natural, or sharp, for the harp's B strings."
    ]
  ]
  attribute b { "f" | "n" | "s" }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.harppedal.vis &= att.color, att.placement, att.visualoffset, att.xy
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.layerdef.log &= att.beaming.log
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.mrest.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.mrest.ges &= att.duration.performed, att.instrumentident
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.mrest.log &= att.event, att.fermatapresent, att.duration.musical
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.mrest.vis &=
  att.altsym,
  att.cutout,
  att.visualoffset,
  att.visibility,
  att.xy,
  att.relativesize
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.mrpt.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.mrpt.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.mrpt.log &= att.event
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.mrpt.vis &= att.altsym, att.color, att.expandable
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.mrpt2.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.mrpt2.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.mrpt2.log &= att.event
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.mrpt2.vis &= att.altsym, att.color, att.expandable
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain attributes. Use the n\x{a}" ~
    "      attribute to explicitly encode this measure's position in a string of\x{a}" ~
    "      measures containing only <mrest> elements."
  ]
]
att.mspace.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.mspace.ges &= att.duration.performed, att.instrumentident
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.mspace.log &= att.event, att.fermatapresent, att.duration.musical
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.mspace.vis &= att.altsym, att.cutout, att.visibility, att.xy
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.multirest.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.multirest.ges &= att.duration.performed, att.instrumentident
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.multirest.log &= att.event, att.numbered
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.multirest.vis &=
  att.altsym,
  [
    a:documentation [
      xml:lang = "eng"
      "When the block attribute is used,\x{a}" ~
      "          combinations of the 1, 2, and 4 measure rest forms (Read, p. 104)\x{a}" ~
      "          should be rendered instead of the modern form or the alternative\x{a}" ~
      "          symbol."
    ]
  ]
  attribute block { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.multirpt.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.multirpt.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.multirpt.log &= att.event, att.numbered
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.multirpt.vis &= att.altsym, att.expandable
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.note.ges &=
  att.graced,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates that this element participates\x{a}" ~
      "          in a glissando."
    ]
  ]
  attribute gliss { data.GLISSANDO }?
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.note.log &= att.beamed, att.lvpresent
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.note.vis &= att.beamsecondary
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.octave.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.octave.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.octave.log &=
  att.controlevent,
  att.octavedisplacement,
  att.startendid,
  att.duration.timestamp,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates whether the octave\x{a}" ~
      "          displacement should be performed simultaneously with the written\x{a}" ~
      "          notes, i.e., 'coll' ottava'. Unlike other octave signs which are\x{a}" ~
      "          indicated by broken lines, coll' ottava uses an unbroken line or a\x{a}" ~
      "          series of longer broken lines, ending with a short vertical stroke.\x{a}" ~
      "          See Read, p. 47-48."
    ]
  ]
  attribute coll { "coll" }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.octave.vis &=
  att.xy,
  att.visualoffset,
  att.visualoffset2.ho,
  att.visualoffset2.to,
  att.linerend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.ossia.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.ossia.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.ossia.log &= empty
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.ossia.vis &= empty
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.pedal.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.pedal.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.pedal.log &=
  att.controlevent,
  att.startendid,
  [
    a:documentation [
      xml:lang = "eng"
      "records the position of the piano damper\x{a}" ~
      "        pedal."
    ]
  ]
  attribute dir { "down" | "up" | "half" | "bounce" }
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes. The place\x{a}" ~
    "      attribute captures the placement of the pedal marking with respect to the\x{a}" ~
    "      staff with which it is associated. Modern publishing standards require the\x{a}" ~
    "      place to be 'below'; however, for transcriptions of manuscript works, this\x{a}" ~
    "      attribute class allows the full range of values."
  ]
]
att.pedal.vis &=
  att.color,
  att.placement,
  att.xy,
  att.visualoffset,
  [
    a:documentation [
      xml:lang = "eng"
      "When style is set to 'line', the pedal\x{a}" ~
      "          mark is rendered with a continuous line. When it's set to pedstar, a\x{a}" ~
      '          pedal down and a half pedal are rendered with "Ped.", a pedal up is\x{a}' ~
      '          rendered as "*", and a pedal "bounce" (up then immediately down) is\x{a}' ~
      '          rendered with "* Ped.". When set to altpedstar, pedal up and down\x{a}' ~
      "          indications are the same as with pedstar but a bounce is rendered with\x{a}" ~
      '          "Ped." only.'
    ]
  ]
  attribute style { "line" | "pedstar" | "altpedstar" }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.phrase.vis &= att.curvature, att.curverend
[
  a:documentation [
    xml:lang = "eng"
    "Used by scoredef and staffdef to provide\x{a}" ~
    "      default description of piano pedal rendition"
  ]
]
att.pianopedals &=
  [
    a:documentation [
      xml:lang = "eng"
      "determines whether piano pedal marks\x{a}" ~
      "          should be drawn as lines or as terms (e.g. 'Ped.' for pedal down and\x{a}" ~
      "          '*' for pedal up)."
    ]
  ]
  attribute pedal.style { "line" | "pedstar" | "altpedstar" }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes used by scoredef and staffdef to\x{a}" ~
    "      provide default information about rehearsal\x{a}" ~
    "      numbers/letters"
  ]
]
att.rehearsal &=
  [
    a:documentation [
      xml:lang = "eng"
      "describes the enclosing shape for\x{a}" ~
      "          rehearsal marks."
    ]
  ]
  attribute reh.enclose { "box" | "circle" | "none" }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.reh.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.reh.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.reh.log &=
  att.staffident,
  att.startid,
  att.timestamp.musical,
  att.timestamp.performed
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.reh.vis &=
  att.color, att.placement, att.typography, att.visualoffset, att.xy
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.rest.log &= att.beamed
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.rest.vis &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.scoredef.log &= att.beaming.log
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.scoredef.vis &=
  att.beaming.vis,
  att.pianopedals,
  att.rehearsal,
  att.slurrend,
  att.tierend,
  [
    a:documentation [
      xml:lang = "eng"
      "determines whether to display guitar\x{a}" ~
      "          chord grids."
    ]
  ]
  attribute grid.show { data.BOOLEAN }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.slur.anl &= att.common.anl, att.joined
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.slur.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.slur.log &= att.controlevent, att.startendid, att.duration.timestamp
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes for slur. The vo\x{a}" ~
    "      attribute is the vertical offset (from its normal position) of the entire\x{a}" ~
    "      rendered slur/phrase mark."
  ]
]
att.slur.vis &=
  att.color,
  att.visualoffset,
  att.visualoffset2,
  att.xy,
  att.xy2,
  att.curvature,
  att.curverend
att.space.log &= att.beamed
[
  a:documentation [
    xml:lang = "eng"
    "Logical domain attributes for staffdef in\x{a}" ~
    "      the CMN repertoire"
  ]
]
att.staffdef.log &= att.beaming.log
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes for staffdef in the\x{a}" ~
    "      CMN repertoire"
  ]
]
att.staffdef.vis &=
  att.beaming.vis,
  att.pianopedals,
  att.rehearsal,
  att.slurrend,
  att.tierend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.tie.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.tie.ges &= empty
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.tie.log &= att.controlevent, att.startendid
[
  a:documentation [
    xml:lang = "eng"
    "Visual domain attributes. The vo attribute\x{a}" ~
    "      is the vertical offset (from its normal position) of the entire rendered\x{a}" ~
    "      tie. The startho, startvo, endho, and endvo attributes describe the\x{a}" ~
    "      horizontal and vertical offsets of the start and end points of the tie in\x{a}" ~
    "      terms of staff interline distance. Startto and endto describe the start\x{a}" ~
    "      and end points in terms of time; that is, beats."
  ]
]
att.tie.vis &=
  att.color,
  att.visualoffset,
  att.visualoffset2,
  att.xy,
  att.xy2,
  att.curvature,
  att.curverend
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.tuplet.anl &= att.common.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.tuplet.ges &= att.duration.performed
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.tuplet.log &=
  att.event,
  att.beamedwith,
  att.augmentdots,
  att.duration.ratio,
  att.startendid,
  [
    a:documentation [
      xml:lang = "eng"
      "captures the time taken up by the\x{a}" ~
      "          tuplet. Unlike other control events where the dur attribute is\x{a}" ~
      "          expressed as a time stamp, dur here is a true duration. If dur is\x{a}" ~
      "          omitted, the default is to calculate the total duration of the\x{a}" ~
      "          included notes and use the next shorter un-dotted value. Irrational\x{a}" ~
      "          durations, such as two quarter notes in the time of five 8th notes in\x{a}" ~
      "          5/8 time, may be expressed as a list of durations which are to be\x{a}" ~
      "          added together to form the total duration of the tuplet. In this case,\x{a}" ~
      '          possbile values for the dur attribute include "2 8" and "8 8 8 8\x{a}' ~
      '          8".'
    ]
  ]
  attribute dur {
    list { data.DURATION+ }
  }?
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.tuplet.vis &=
  att.numberplacement,
  [
    a:documentation [
      xml:lang = "eng"
      "used to state where a tuplet bracket\x{a}" ~
      "          will be placed in relation to the noteheads."
    ]
  ]
  attribute bracket.place { data.PLACE }?,
  [
    a:documentation [
      xml:lang = "eng"
      "states whether a bracket should be\x{a}" ~
      "          rendered with a tuplet."
    ]
  ]
  attribute bracket.visible { data.BOOLEAN }?,
  [
    a:documentation [
      xml:lang = "eng"
      "determines if the tuplet duration is\x{a}" ~
      "          visible."
    ]
  ]
  attribute dur.visible { data.BOOLEAN }?,
  [
    a:documentation [
      xml:lang = "eng"
      "controls how the num:numbase ratio is to\x{a}" ~
      "          be displayed. When set to 'count' only the num attribute is displayed,\x{a}" ~
      "          e.g., '7'; however, when set to 'ratio', both the num and numbase\x{a}" ~
      "          attributes are displayed, e.g., '7:4'."
    ]
  ]
  attribute num.format { "count" | "ratio" }?
[
  a:documentation [
    xml:lang = "eng"
    "Analytical domain\x{a}" ~
    "      attributes"
  ]
]
att.tupletspan.anl &= att.tuplet.anl
[ a:documentation [ xml:lang = "eng" "Gestural domain attributes" ] ]
att.tupletspan.ges &= att.tuplet.ges
[ a:documentation [ xml:lang = "eng" "Logical domain attributes" ] ]
att.tupletspan.log &= att.tuplet.log
[ a:documentation [ xml:lang = "eng" "Visual domain attributes" ] ]
att.tupletspan.vis &= att.tuplet.vis
# Declare module model classes
[
  a:documentation [
    xml:lang = "eng"
    "groups control events that appear in CMN\x{a}" ~
    "      notation."
  ]
]
model.controleventLike &=
  (arpeg
   | beamspan
   | breath
   | fermata
   | hairpin
   | harppedal
   | octave
   | model.ornamentLike.cmn
   | pedal
   | reh
   | slur
   | tie
   | tupletspan)*
[
  a:documentation [
    xml:lang = "eng"
    "groups notated events at the layer\x{a}" ~
    "      level."
  ]
]
model.layerPart &= (model.eventLike.measureFilling)*
[
  a:documentation [
    xml:lang = "eng"
    "groups events that appear in CMN\x{a}" ~
    "      notation."
  ]
]
model.eventLike &=
  (beam | bend | beatrpt | btrem | ftrem | gliss | halfmrpt | tuplet)*
[
  a:documentation [
    xml:lang = "eng"
    "groups events that appear in CMN notation\x{a}" ~
    "      and that completely fill a measure."
  ]
]
model.eventLike.measureFilling &=
  mrest | mrpt | mrpt2 | mspace | multirest | multirpt
[
  a:documentation [
    xml:lang = "eng"
    "groups measure-like\x{a}" ~
    "      elements."
  ]
]
model.measureLike &= measure
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of a\x{a}" ~
    "      measure."
  ]
]
model.measurePart &=
  (model.staffLike | model.ossiaLike)*,
  (model.controleventLike | model.lyricsLike | model.midiLike)*
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that function like\x{a}" ~
    "      ossia."
  ]
]
model.ossiaLike &= ossia
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of a\x{a}" ~
    "      section."
  ]
]
model.sectionPart &= model.measureLike*
# Declare module elements
content.arpeg = empty
arpeg =
  [
    a:documentation [
      xml:lang = "eng"
      "arpeggiation ― Indicates that the notes of\x{a}" ~
      "        a chord are to be performed successively rather than simultaneously,\x{a}" ~
      '        usually from lowest to highest. Sometimes called a "roll". The modern\x{a}' ~
      "        symbol is a vertical wavy line preceding the chord. When the notes of\x{a}" ~
      "        the chord are to be performed from highest to lowest, an arrowhead may\x{a}" ~
      "        be added to the lower end of the line. Even though it is redundant, an\x{a}" ~
      "        arrowhead is sometimes added to the upper end of the line for the sake\x{a}" ~
      "        of consistency or when the direction of successive arpeggios alternates.\x{a}" ~
      "        In music for keyboard instruments, sometimes a distinction is made\x{a}" ~
      "        between a single arpeggio in which both hands play successively and\x{a}" ~
      "        simultaneous arpeggios in two hands. In the case of the former, multiple\x{a}" ~
      "        values may be required in the staff and layer attributes. Arpeggios that\x{a}" ~
      "        do not cross staves, but still involve more than one layer require\x{a}" ~
      "        multiple values for the layer attribute."
    ]
  ]
  element arpeg { attlist.arpeg, content.arpeg }
attlist.arpeg &=
  att.common,
  att.facsimile,
  att.arpeg.log,
  att.arpeg.vis,
  att.arpeg.ges,
  att.arpeg.anl
content.beam =
  (model.eventLike
   | model.appLike
   | model.editLike
   | model.transcriptionLike)+
beam =
  [
    a:documentation [
      xml:lang = "eng"
      "beam ― A container for a series of\x{a}" ~
      "        explicitly beamed events that begins and ends entirely within a measure.\x{a}" ~
      "        For beams that cross the barline, use the beamspan element. Secondary\x{a}" ~
      "        beams may be broken explicitly using the breaksec attribute on the notes\x{a}" ~
      "        or chords under the beam. Automated beaming, as opposed to explicitly\x{a}" ~
      "        marked beams, may be indicated for an entire score, part or section by\x{a}" ~
      "        using the beam.group and beam.rests attributes on these\x{a}" ~
      "        elements."
    ]
  ]
  element beam { attlist.beam, content.beam }
attlist.beam &=
  att.common,
  att.facsimile,
  att.beam.log,
  att.beam.vis,
  att.beam.ges,
  att.beam.anl
content.beamspan = empty
beamspan =
  [
    a:documentation [
      xml:lang = "eng"
      "beam span ― Alternative element for\x{a}" ~
      "        explicitly encoding beams which extend across barlines. The starting\x{a}" ~
      "        point of the beam may be indicated by either a tstamp, tstamp.ges,\x{a}" ~
      "        tstamp.real or startid attribute, while the ending point may be recorded\x{a}" ~
      "        by either a dur, dur.ges or endid attribute. It is a semantic error not\x{a}" ~
      "        to specify one starting and one ending type of\x{a}" ~
      "        attribute."
    ]
  ]
  element beamspan { attlist.beamspan, content.beamspan }
attlist.beamspan &=
  att.common,
  att.facsimile,
  att.beamspan.log,
  att.beamspan.vis,
  att.beamspan.ges,
  att.beamspan.anl
content.beatrpt = empty
beatrpt =
  [
    a:documentation [
      xml:lang = "eng"
      "beat repeat ― An indication that material\x{a}" ~
      "        on a preceding beat should be repeated. It is also used in guitar or\x{a}" ~
      "        rhythm parts to indicate where chord changes occur. When these parts\x{a}" ~
      "        require durations longer or shorter than a beat, however, note elements\x{a}" ~
      "        with appropriately-shaped note heads should be\x{a}" ~
      "        employed."
    ]
  ]
  element beatrpt { attlist.beatrpt, content.beatrpt }
attlist.beatrpt &=
  att.common,
  att.facsimile,
  att.beatrpt.log,
  att.beatrpt.vis,
  att.beatrpt.ges,
  att.beatrpt.anl
content.bend = (note | rest | tuplet)*
bend =
  [
    a:documentation [
      xml:lang = "eng"
      "bend ― A variation in pitch (often\x{a}" ~
      "        microtonal) upwards or downwards during the course of a note. Typically,\x{a}" ~
      '        the performer attacks the note at "true" pitch, bends the intonation,\x{a}' ~
      "        then returns to true pitch. The bend element can also be used for scoop,\x{a}" ~
      "        plop, falloff, and doit performance effects. It should *not* be used for\x{a}" ~
      "        l.v. (laissez vibrer) indications. Precise performance data that differs\x{a}" ~
      "        from the logical events in a measure may be recorded within the bend\x{a}" ~
      "        element. The starting point of the bend may be indicated by either a\x{a}" ~
      "        tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic\x{a}" ~
      "        error not to specify a starting attribute."
    ]
  ]
  element bend { attlist.bend, content.bend }
attlist.bend &=
  att.common,
  att.facsimile,
  att.bend.log,
  att.bend.vis,
  att.bend.ges,
  att.bend.anl
content.breath = empty
breath =
  [
    a:documentation [
      xml:lang = "eng"
      "breath mark ― A indication of a point at\x{a}" ~
      "        which the performer on an instrument requiring breath (including the\x{a}" ~
      "        voice) may breathe. It also may indicate a short pause or break for\x{a}" ~
      "        instruments *not* requiring breath. Therefore, it oftens functions as a\x{a}" ~
      "        guide to phrasing. The usual sign for the breath mark is a comma;\x{a}" ~
      "        however, other visual forms of the breath mark may be indicated using\x{a}" ~
      "        the altsym attribute. The starting point of the breath mark may be\x{a}" ~
      "        indicated by either a tstamp, tstamp.ges, tstamp.real or startid\x{a}" ~
      "        attribute. It is a semantic error not to specify a starting point\x{a}" ~
      "        attribute."
    ]
  ]
  element breath { attlist.breath, content.breath }
attlist.breath &=
  att.common,
  att.facsimile,
  att.breath.log,
  att.breath.vis,
  att.breath.ges,
  att.breath.anl
content.btrem = chord | note
btrem =
  [
    a:documentation [
      xml:lang = "eng"
      "bowed tremolo ― A rapid alternation on a\x{a}" ~
      "        single pitch or chord. This element should also be used for wind double\x{a}" ~
      "        and triple tonguing and for flutter tonguing when these are expressed as\x{a}" ~
      "        tremolandi. For alternation between a pair of notes or chords, use the\x{a}" ~
      "        ftrem element. The num attribute can be used to store a number to be\x{a}" ~
      "        rendered along with a tremolo. The slash attribute indicates the number\x{a}" ~
      "        of slashes to be drawn. The number of slashes indicates the exact note\x{a}" ~
      "        values in an aural rendition of measured tremolandi, i.e., 4ths or\x{a}" ~
      "        8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5, 256ths=6. See Read, p.\x{a}" ~
      "        393-394. The stem modifier (slash or z) must also be explicity set on\x{a}" ~
      "        the child <note> or <chord> element for a\x{a}" ~
      "        complete visual representation. See Read, p. 394, ex. 23-21, line\x{a}" ~
      "        5."
    ]
  ]
  element btrem { attlist.btrem, content.btrem }
attlist.btrem &=
  att.common,
  att.facsimile,
  att.btrem.log,
  att.btrem.vis,
  att.btrem.ges,
  att.btrem.anl
content.fermata = empty
fermata =
  [
    a:documentation [
      xml:lang = "eng"
      "fermata ― An indication placed over a note\x{a}" ~
      "        or rest to indicated that it should be held longer than its written\x{a}" ~
      "        value. May also occur over a barline to indicate the end of a phrase or\x{a}" ~
      "        section. Sometimes called a 'hold' or 'pause'. The\x{a}" ~
      "        <fermata> element is a specialized form of, i.e.,\x{a}" ~
      '        syntactic sugar for, dir/@type="fermata" with &ferm; or\x{a}' ~
      "        &uferm; as its PCDATA content. Other visual forms of a fermata\x{a}" ~
      "        may be indicated via the altsym attribute. The starting point of the\x{a}" ~
      "        fermata may be indicated by either a tstamp, tstamp.ges, tstamp.real or\x{a}" ~
      "        startid attribute. It is a semantic error not to specify a starting\x{a}" ~
      "        point attribute."
    ]
  ]
  element fermata { attlist.fermata, content.fermata }
attlist.fermata &=
  att.common,
  att.facsimile,
  att.fermata.log,
  att.fermata.vis,
  att.fermata.ges,
  att.fermata.anl
content.ftrem =
  (chord, (chord | note))
  | (note, (chord | note))
ftrem =
  [
    a:documentation [
      xml:lang = "eng"
      "fingered tremolo ― A rapid alternation\x{a}" ~
      "        between a pair of notes (or chords or perhaps between a note and a\x{a}" ~
      "        chord) that are (usually) farther apart than a major second. For rapid\x{a}" ~
      "        alternation between notes on the same pitch (bowed tremolo, double\x{a}" ~
      "        &amp; triple tonguing, and flutter tonguing) use the\x{a}" ~
      "        <btrem> element. The slash attribute records the number of\x{a}" ~
      "        slashes required — 4ths or 8ths=1, 16ths=2, 32nds=3, 64ths=4, 128ths=5,\x{a}" ~
      "        256ths=6."
    ]
  ]
  element ftrem { attlist.ftrem, content.ftrem }
attlist.ftrem &=
  att.common,
  att.facsimile,
  att.ftrem.log,
  att.ftrem.vis,
  att.ftrem.ges,
  att.ftrem.anl
content.hairpin = empty
hairpin =
  [
    a:documentation [
      xml:lang = "eng"
      "hairpin ― Indicates continuous dynamics\x{a}" ~
      "        expressed on the score as wedge-shaped graphics, e.g. < and\x{a}" ~
      "        >. The starting point of the hairpin may be indicated by either a\x{a}" ~
      "        tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending\x{a}" ~
      "        point may be recorded by either a dur, dur.ges or endid attribute. It is\x{a}" ~
      "        a semantic error not to specify one starting and one ending type of\x{a}" ~
      "        attribute. Please note that the value of the dur attribute is not a true\x{a}" ~
      "        duration, but rather a time stamp for the end point of the\x{a}" ~
      "        hairpin."
    ]
  ]
  element hairpin { attlist.hairpin, content.hairpin }
attlist.hairpin &=
  att.common,
  att.facsimile,
  att.hairpin.log,
  att.hairpin.vis,
  att.hairpin.ges,
  att.hairpin.anl
content.harppedal = empty
harppedal =
  [
    a:documentation [
      xml:lang = "eng"
      "harp pedal ― Harp pedal diagram. The\x{a}" ~
      "        starting point of the harp pedal diagram may be indicated by either a\x{a}" ~
      "        tstamp, tstamp.ges, tstamp.real or startid attribute. It is a semantic\x{a}" ~
      "        error not to specify a starting point attribute."
    ]
  ]
  element harppedal { attlist.harppedal, content.harppedal }
attlist.harppedal &=
  att.common,
  att.facsimile,
  att.harppedal.log,
  att.harppedal.vis,
  att.harppedal.ges,
  att.harppedal.anl
content.gliss = (note | rest | tuplet)*
gliss =
  [
    a:documentation [
      xml:lang = "eng"
      "glissando ― A continuous or sliding\x{a}" ~
      "        movement from one pitch to another, usually indicated by a straight or\x{a}" ~
      "        wavy line. Commonly also called a 'slide'. The term 'glissando' is\x{a}" ~
      "        frequently used to indicate both the case where distinct intermediate\x{a}" ~
      "        pitches are produced (as on the piano) and the case where they are not\x{a}" ~
      "        (as on the trombone), though the latter is sometimes referred to as\x{a}" ~
      "        'portamento'. The visual appearance of the indicating line may be\x{a}" ~
      "        recorded in the rend attribute. Precise performance data, that is, exact\x{a}" ~
      "        pitches, may be recorded within the <gliss> element. The\x{a}" ~
      "        starting point of the glissando may be indicated by either a tstamp,\x{a}" ~
      "        tstamp.ges, tstamp.real or startid attribute. It is a semantic error not\x{a}" ~
      "        to specify a starting point attribute."
    ]
  ]
  element gliss { attlist.gliss, content.gliss }
attlist.gliss &=
  att.common,
  att.facsimile,
  att.gliss.log,
  att.gliss.vis,
  att.gliss.ges,
  att.gliss.anl
content.halfmrpt = model.eventLike*
halfmrpt =
  [
    a:documentation [
      xml:lang = "eng"
      "half-measure repeat ― A half-measure\x{a}" ~
      "        repeat in any meter."
    ]
  ]
  element halfmrpt { attlist.halfmrpt, content.halfmrpt }
attlist.halfmrpt &=
  att.common,
  att.facsimile,
  att.halfmrpt.log,
  att.halfmrpt.vis,
  att.halfmrpt.ges,
  att.halfmrpt.anl
content.measure =
  (model.appLike
   | model.divLike
   | model.milestoneLike.music
   | model.scoredefLike
   | model.staffdefLike
   | model.staffgrpLike
   | model.annotLike
   | model.graphicprimitiveLike
   | model.editLike
   | model.transcriptionLike
   | model.measurePart)*
measure =
  [
    a:documentation [
      xml:lang = "eng"
      'measure ― "Unit of musical time consisting\x{a}' ~
      "        of a fixed number of note-values of a given type, as determined by the\x{a}" ~
      '        prevailing meter, and delimited in musical notation by two bar lines."\x{a}' ~
      "        (New Harvard Dictionary of Music) In MEI, the measure element is a\x{a}" ~
      "        grouping mechanism for events and control events. It is also a linking\x{a}" ~
      "        element that uses attributes to connect the MEI document to an external\x{a}" ~
      "        electronic object or to another location within the MEI\x{a}" ~
      "        instance."
    ]
  ]
  element measure { attlist.measure, content.measure }
attlist.measure &=
  att.common,
  att.facsimile,
  att.typed,
  att.link.common,
  att.link.internal,
  att.link.external,
  att.measure.log,
  att.measure.vis,
  att.measure.ges,
  att.measure.anl
content.mrest = empty
mrest =
  [
    a:documentation [
      xml:lang = "eng"
      "measure rest ― Complete measure rest in\x{a}" ~
      "        any meter (Read, p. 97-98). Automatically-generated numbering of\x{a}" ~
      "        consecutive measures of rest may be controlled via the multi.number\x{a}" ~
      "        attribute on the scoredef or staffdef elements."
    ]
  ]
  element mrest { attlist.mrest, content.mrest }
attlist.mrest &=
  att.common,
  att.facsimile,
  att.mrest.log,
  att.mrest.vis,
  att.mrest.ges,
  att.mrest.anl
content.mrpt = empty
mrpt =
  [
    a:documentation [
      xml:lang = "eng"
      "measure repeat ― An indication that the\x{a}" ~
      "        previous measure should be repeated. The automated numbering of\x{a}" ~
      "        consecutive measures of rest may be controlled via the multi.number\x{a}" ~
      "        attribute on the scoredef or staffdef elements."
    ]
  ]
  element mrpt { attlist.mrpt, content.mrpt }
attlist.mrpt &=
  att.common,
  att.facsimile,
  att.mrpt.log,
  att.mrpt.vis,
  att.mrpt.ges,
  att.mrpt.anl
content.mrpt2 = empty
mrpt2 =
  [
    a:documentation [
      xml:lang = "eng"
      "2-measure repeat ― An indication that the\x{a}" ~
      "        previous two measures should be repeated."
    ]
  ]
  element mrpt2 { attlist.mrpt2, content.mrpt2 }
attlist.mrpt2 &=
  att.common,
  att.facsimile,
  att.mrpt2.log,
  att.mrpt2.vis,
  att.mrpt2.ges,
  att.mrpt2.anl
content.mspace = empty
mspace =
  [
    a:documentation [
      xml:lang = "eng"
      "measure space ― Complete measure\x{a}" ~
      "        consisting of empty space in any meter. The automated numbering of\x{a}" ~
      "        consecutive measures of space may be controlled via the multi.number\x{a}" ~
      "        attribute on the scoredef or staffdef elements."
    ]
  ]
  element mspace { attlist.mspace, content.mspace }
attlist.mspace &=
  att.common,
  att.facsimile,
  att.mspace.log,
  att.mspace.vis,
  att.mspace.ges,
  att.mspace.anl
content.multirest = empty
multirest =
  [
    a:documentation [
      xml:lang = "eng"
      "multi-rest ― Multiple measures of rest\x{a}" ~
      "        compressed into a single symbol, frequently found in performer parts.\x{a}" ~
      "        The num attribute can used to store a number to be rendered along with\x{a}" ~
      "        the note. See Read, p. 102-105."
    ]
  ]
  element multirest { attlist.multirest, content.multirest }
attlist.multirest &=
  att.common,
  att.facsimile,
  att.multirest.log,
  att.multirest.vis,
  att.multirest.ges,
  att.multirest.anl
content.multirpt = empty
multirpt =
  [
    a:documentation [
      xml:lang = "eng"
      "multi-repeat ― Multiple repeated measures.\x{a}" ~
      "        In modern publishing practice, repeats of more than two measures should\x{a}" ~
      "        be written out using repeat signs. This element, however, is provided\x{a}" ~
      "        for handling non-standard practices often found in manuscript. The num\x{a}" ~
      "        attribute records the number of measures to be\x{a}" ~
      "        repeated."
    ]
  ]
  element multirpt { attlist.multirpt, content.multirpt }
attlist.multirpt &=
  att.common,
  att.facsimile,
  att.multirpt.log,
  att.multirpt.vis,
  att.multirpt.ges,
  att.multirpt.anl
content.octave = empty
octave =
  [
    a:documentation [
      xml:lang = "eng"
      "octave ― An indication that a passage\x{a}" ~
      "        should be performed one or more octaves above or below its written\x{a}" ~
      "        pitch. The dis and dis.place attributes record the amount and direction\x{a}" ~
      "        of displacement, respectively. The rend attribute captures the\x{a}" ~
      "        appearance of the continuation line associated with the octave\x{a}" ~
      "        displacement. The starting point of the octave displacement may be\x{a}" ~
      "        indicated by either a tstamp, tstamp.ges, tstamp.real or startid\x{a}" ~
      "        attribute, while the ending point may be recorded by either a dur,\x{a}" ~
      "        dur.ges or endid attribute. It is a semantic error not to specify one\x{a}" ~
      "        starting and one ending type of attribute. Please note that the dur\x{a}" ~
      "        attribute here is not a true duration, but rather a time stamp for the\x{a}" ~
      "        end point of the octave displacement. Also, note that the dur attribute\x{a}" ~
      "        is not required because the octave displacement can be visually\x{a}" ~
      "        instantaneous."
    ]
  ]
  element octave { attlist.octave, content.octave }
attlist.octave &=
  att.common,
  att.facsimile,
  att.octave.log,
  att.octave.vis,
  att.octave.ges,
  att.octave.anl
content.ossia =
  (model.appLike
   | model.divLike
   | model.milestoneLike.music
   | model.scoredefLike
   | model.staffdefLike
   | model.staffgrpLike
   | model.annotLike
   | model.graphicprimitiveLike
   | model.editLike
   | model.transcriptionLike
   | model.measurePart)*
ossia =
  [
    a:documentation [
      xml:lang = "eng"
      "ossia ― An alternative, usually simpler,\x{a}" ~
      "        version of a measure *present in the source being transcribed*.\x{a}" ~
      "        Typically, it is rendered above the staff on a reduced-size\x{a}" ~
      "        staff."
    ]
  ]
  element ossia { attlist.ossia, content.ossia }
attlist.ossia &=
  att.common,
  att.facsimile,
  att.ossia.log,
  att.ossia.vis,
  att.ossia.ges,
  att.ossia.anl
content.pedal = empty
pedal =
  [
    a:documentation [
      xml:lang = "eng"
      "pedal ― Piano pedal mark (Read, p.\x{a}" ~
      "        317-318). The starting point of the pedal mark may be indicated by\x{a}" ~
      "        either a tstamp, tstamp.ges, tstamp.real or startid attribute. It is a\x{a}" ~
      "        semantic error not to specify a starting point\x{a}" ~
      "        attribute."
    ]
  ]
  element pedal { attlist.pedal, content.pedal }
attlist.pedal &=
  att.common,
  att.facsimile,
  att.pedal.log,
  att.pedal.vis,
  att.pedal.ges,
  att.pedal.anl
content.reh = (text | model.lbLike | model.rendLike)*
reh =
  [
    a:documentation [
      xml:lang = "eng"
      "rehearsal mark ― In an orchestral score\x{a}" ~
      "        and its corresponding parts, a mark indicating a convenient point from\x{a}" ~
      "        which to resume rehearsal after a break. It may also be called a\x{a}" ~
      "        rehearsal figure, or when numbers are used instead of letters, a\x{a}" ~
      "        rehearsal number. See Read, p. 443. <reh> uses a subset of\x{a}" ~
      "        model.textphraseLike.limited."
    ]
  ]
  element reh { attlist.reh, content.reh }
attlist.reh &=
  att.common,
  att.facsimile,
  att.reh.log,
  att.reh.vis,
  att.reh.ges,
  att.reh.anl
content.slur = empty
slur =
  [
    a:documentation [
      xml:lang = "eng"
      'slur ― Historically, the term "slur"\x{a}' ~
      '        indicated two notes performed legato, while the term "phrase" was used\x{a}' ~
      '        for a "unified melodic idea". Nowadays, however, "slur" often has the\x{a}' ~
      '        same meaning as "phrase" (See Read, p. 265-266), since the visual\x{a}' ~
      "        rendition of the two concepts is the same. MEI provides two distinct\x{a}" ~
      "        elements so that those users wishing to maintain a distinction for\x{a}" ~
      "        historical reasons may do so. If the user does not want to maintain the\x{a}" ~
      "        distinction, then the more generic <slur> element should\x{a}" ~
      "        be employed. The starting point of the slur may be indicated by either a\x{a}" ~
      "        tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending\x{a}" ~
      "        point may be recorded by either a dur, dur.ges or endid attribute. It is\x{a}" ~
      "        a semantic error not to specify one starting and one ending type of\x{a}" ~
      "        attribute. Either place, bulge, or bezier attributes may be used to\x{a}" ~
      "        record the curvature of the slur. The slur and tie elements may be used\x{a}" ~
      "        instead of the slur.* and tie.* attributes provided on chord and note\x{a}" ~
      "        elements when 1) they are required by software, or 2) multiple,\x{a}" ~
      "        alternative slurs are needed. Please note that the dur attribute is not\x{a}" ~
      "        a true duration, but rather a time stamp for the end point of the\x{a}" ~
      "        slur."
    ]
  ]
  element slur { attlist.slur, content.slur }
attlist.slur &=
  att.common,
  att.facsimile,
  att.typed,
  att.slur.log,
  att.slur.vis,
  att.slur.ges,
  att.slur.anl
content.tie = empty
tie =
  [
    a:documentation [
      xml:lang = "eng"
      "tie ― An indication that two notes of the\x{a}" ~
      "        same pitch form a single note with their combined rhythmic values. Most\x{a}" ~
      "        often it is rendered as a curved line connecting the two notes. See\x{a}" ~
      "        Read, p. 110-111, 122."
    ]
  ]
  element tie { attlist.tie, content.tie }
attlist.tie &=
  att.common,
  att.facsimile,
  att.typed,
  att.tie.log,
  att.tie.vis,
  att.tie.ges,
  att.tie.anl
content.tuplet =
  (model.eventLike
   | model.appLike
   | model.editLike
   | model.transcriptionLike)+
tuplet =
  [
    a:documentation [
      xml:lang = "eng"
      'tuplet ― A group of notes with "irregular"\x{a}' ~
      '        (sometimes called "irrational") rhythmic values, for example, three\x{a}' ~
      "        notes in the time normally occupied by two or nine in the time of five.\x{a}" ~
      "        The beam sub-element is allowed so that custom beaming may be indicated,\x{a}" ~
      "        e.g., a septuplet may be divided into a group of three plus a group of\x{a}" ~
      "        four notes. See Read, p. 187-215. The tuplet element may also used for\x{a}" ~
      "        bowed tremolo (Read, p. 394) and double, triple, or flutter tonguing\x{a}" ~
      "        (Read, p. 348-349); that is, for repetition of the same pitch. In the\x{a}" ~
      "        case of irrational durations, such as such as two quarter notes in the\x{a}" ~
      "        time of five 8th notes in a measure of 5/8 time, decimal values may be\x{a}" ~
      "        used in the dur.ges attribute. For example, the dur.ges attribute would\x{a}" ~
      """        take the value "2.5" if the midi.div attribute's value was "1". The num\x{a}""" ~
      "        and numbase attributes may be used for explicit labelling of a tuplet,\x{a}" ~
      "        such as, '3' with an 8th-note triplet, '3:2' over a quarter-note\x{a}" ~
      "        triplet, etc. The rendering of the ratio, however, is dependent on the\x{a}" ~
      "        num.format attribute found in the att.vis.tuplet attribute\x{a}" ~
      "        class."
    ]
  ]
  element tuplet { attlist.tuplet, content.tuplet }
attlist.tuplet &=
  att.common,
  att.facsimile,
  att.tuplet.log,
  att.tuplet.vis,
  att.tuplet.ges,
  att.tuplet.anl
content.tupletspan = empty
tupletspan =
  [
    a:documentation [
      xml:lang = "eng"
      "tuplet span ― Alternative element for\x{a}" ~
      "        encoding tuplets, especially useful for tuplets that extend across\x{a}" ~
      "        barlines. The starting point of the tuplet may be indicated by either a\x{a}" ~
      "        tstamp, tstamp.ges, tstamp.real or startid attribute, while the ending\x{a}" ~
      "        point may be recorded using a dur, dur.ges or endid attribute. It is a\x{a}" ~
      "        semantic error not to specify one starting and one ending type of\x{a}" ~
      "        attribute."
    ]
  ]
  element tupletspan { attlist.tupletspan, content.tupletspan }
attlist.tupletspan &=
  att.common,
  att.facsimile,
  att.tupletspan.log,
  att.tupletspan.vis,
  att.tupletspan.ges,
  att.tupletspan.anl
