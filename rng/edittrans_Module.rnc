# **************************************************************

# NAME:     Music Encoding Initiative (MEI) schema component:
#           edittrans_Module.rng
# 
# NOTICE:   Copyright (c) 2010 by the Music Encoding Initiative (MEI)
#           Council.
# 
#           Licensed under the Educational Community License, Version
#           2.0 (the "License"); you may not use this file except in
#           compliance with the License. You may obtain a copy of the
#           License at http://www.osedu.org/licenses/ECL-2.0.
# 
#           Unless required by applicable law or agreed to in writing,
#           software distributed under the License is distributed on
#           an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
#           KIND, either express or implied. See the License for the
#           specific language governing permissions and limitations
#           under the License.
# 
#           This is a derivative work based on earlier versions of the
#           schema copyright (c) 2001-2006 Perry Roland and the Rector
#           and Visitors of the University of Virginia; licensed under
#           the Educational Community License version 1.0.
# 
# CONTACT:  contact@music-encoding.org 

namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
default namespace mei = "http://www.music-encoding.org/ns/mei"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
namespace tei = "http://www.tei-c.org/ns/1.0"
namespace xhtml = "http://www.w3.org/1999/xhtml"
namespace xlink = "http://www.w3.org/1999/xlink"

# EditTrans module

# Declare module attr classes
[
  a:documentation [
    xml:lang = "eng"
    "Attributes describing the nature of an\x{a}" ~
    "      encoded scholarly intervention or interpretation"
  ]
]
att.edit &=
  att.responsibility,
  att.source,
  [
    a:documentation [
      xml:lang = "eng"
      "signifies the degree of certainty or\x{a}" ~
      "          precision associated with a feature."
    ]
  ]
  attribute cert { data.CERTAINTY }?,
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the nature of the evidence\x{a}" ~
      "          supporting the reliability or accuracy of the intervention or\x{a}" ~
      "          interpretation. Suggested values include: 'internal', 'external',\x{a}" ~
      "          'conjecture'."
    ]
  ]
  attribute evidence { xsd:NMTOKEN }?

## Attributes for the identification of a causative
##       agent
att.agentident &=
  [
    a:documentation [
      xml:lang = "eng"
      "signifies the causative agent of damage,\x{a}" ~
      "          illegibility, or other loss of original text."
    ]
  ]
  attribute agent { text }?

## Attributes for identification of the extent of editorial
##       assertions
att.extent &=
  [
    a:documentation [
      xml:lang = "eng"
      "indicates the extent of damage or\x{a}" ~
      "          omission."
    ]
  ]
  attribute extent { text }?
att.reasonident &=
  [
    a:documentation [
      xml:lang = "eng"
      "holds a short phrase describing the\x{a}" ~
      "          reason for missing textual material (gap), why material is supplied\x{a}" ~
      "          (supplied), or why transcription is difficult\x{a}" ~
      "          (unclear)."
    ]
  ]
  attribute reason { text }?
[
  a:documentation [
    xml:lang = "eng"
    "Attributes for elements encoding authorial\x{a}" ~
    "      or scribal intervention when transcribing manuscript or similar\x{a}" ~
    "      sources"
  ]
]
att.trans &= att.handident, att.sequence
# Declare module model classes
[
  a:documentation [
    xml:lang = "eng"
    "groups elements that may appear as part of\x{a}" ~
    "      the content of a choice element."
  ]
]
model.choicePart &=
  corr | orig | reg | sic | unclear | model.editorialLike
[
  a:documentation [
    xml:lang = "eng"
    "groups elements for editorial interventions\x{a}" ~
    "      that may be useful both in transcribing and in\x{a}" ~
    "      authoring."
  ]
]
model.editLike &= choice | handshift | gap | subst
[
  a:documentation [
    xml:lang = "eng"
    "groups elements used for editorial\x{a}" ~
    "      transcription of pre-existing source materials."
  ]
]
model.transcriptionLike &=
  add
  | corr
  | damage
  | del
  | orig
  | reg
  | restore
  | sic
  | supplied
  | unclear
# Declare module elements
content.add =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
add =
  [
    a:documentation [
      xml:lang = "eng"
      "addition ― Marks an addition to the text.\x{a}" ~
      "        The add element contains material inserted by an author, scribe,\x{a}" ~
      "        annotator, or corrector. The agent responsible for the addition may be\x{a}" ~
      "        encoded using the hand attribute, while the resp attribute records the\x{a}" ~
      "        editor or transcriber responsible for identifying the hand of the\x{a}" ~
      "        addition. The cert attribute signifies the degree of certainty ascribed\x{a}" ~
      "        to the identification of the hand of the addition. The editor(s)\x{a}" ~
      "        responsible for asserting this particular reading may be recorded in the\x{a}" ~
      "        resp attribute. The value of resp must point to one or more identifiers\x{a}" ~
      "        declared in the document header. This element is modelled on an element\x{a}" ~
      "        in the Text Encoding Initiative (TEI)."
    ]
  ]
  element add { attlist.add, content.add }
attlist.add = att.common, att.facsimile, att.edit, att.trans
content.choice = (choice | model.choicePart)*
choice =
  [
    a:documentation [
      xml:lang = "eng"
      "choice ― Groups a number of alternative\x{a}" ~
      "        encodings for the same point in a text. Because the children of a choice\x{a}" ~
      "        element all represent alternative ways of encoding the same sequence, it\x{a}" ~
      "        is natural to think of them as mutually exclusive. However, there may be\x{a}" ~
      "        cases where a full representation of a text requires the alternative\x{a}" ~
      "        encodings to be considered as parallel. Note also that choice elements\x{a}" ~
      "        may be recursively nested. This element is modelled on an element in the\x{a}" ~
      "        Text Encoding Initiative (TEI)."
    ]
  ]
  element choice { attlist.choice, content.choice }
attlist.choice = att.common
content.corr =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
corr =
  [
    a:documentation [
      xml:lang = "eng"
      "correction ― Contains the correct form of\x{a}" ~
      "        an apparent erroneous passage. The cert attribute signifies the degree\x{a}" ~
      "        of certainty ascribed to correction. The resp attribute contains an ID\x{a}" ~
      "        reference to an element containing the name of the editor or transcriber\x{a}" ~
      "        responsible for suggesting the correction held as the content of the\x{a}" ~
      "        <corr> element. If the correction was made in the source,\x{a}" ~
      "        resp should be used to identify the hand of the corrector. The value of\x{a}" ~
      "        resp must point to one or more identifiers declared in the document\x{a}" ~
      "        header. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element corr { attlist.corr, content.corr }
attlist.corr = att.common, att.edit, att.trans
content.damage =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
damage =
  [
    a:documentation [
      xml:lang = "eng"
      "damage ― Contains an area of damage to the\x{a}" ~
      "        carrier. In the case of damage resulting from an identifiable cause, the\x{a}" ~
      "        agent attribute signifies the causative agent. The degree attribute\x{a}" ~
      "        signifies the degree of damage according to a convenient scale. A\x{a}" ~
      "        <damage> tag with this attribute should only be used where\x{a}" ~
      "        the text may be read with some confidence; data supplied from other\x{a}" ~
      "        sources should be tagged as <supplied>. The extent\x{a}" ~
      "        attribute indicates approximately how much text is in the damaged area,\x{a}" ~
      "        in notes, measures, inches, or any appropriate unit, where this cannot\x{a}" ~
      "        be deduced from the contents of the tag. For example, the damage may\x{a}" ~
      "        span structural divisions in the text so that the tag must then be empty\x{a}" ~
      "        of content. In the case of damage (deliberate defacement, etc.)\x{a}" ~
      "        assignable to an identifiable hand, the hand attribute signifies the\x{a}" ~
      "        hand responsible for the damage. This element is modelled on an element\x{a}" ~
      "        in the Text Encoding Initiative (TEI)."
    ]
  ]
  element damage { attlist.damage, content.damage }
attlist.damage =
  att.agentident,
  att.common,
  att.extent,
  att.facsimile,
  att.handident,
  att.typed,
  [
    a:documentation [
      xml:lang = "eng"
      "records the degree of\x{a}" ~
      "          damage."
    ]
  ]
  attribute degree { text }?
content.del =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
del =
  [
    a:documentation [
      xml:lang = "eng"
      "deletion ― Contains information deleted,\x{a}" ~
      "        marked as deleted, or otherwise indicated as superfluous or spurious in\x{a}" ~
      "        the copy text by an author, scribe, annotator, or corrector. The resp\x{a}" ~
      "        attribute contains an ID reference to an element containing the name of\x{a}" ~
      "        the editor or transcriber responsible for identifying the hand of the\x{a}" ~
      "        deletion. The cert attribute signifies the degree of certainty ascribed\x{a}" ~
      "        to the identification of the hand of the deletion. The hand of the agent\x{a}" ~
      "        which made the deletion should be pointed to using the hand attribute.\x{a}" ~
      "        The rend attribute may be used to record the method used to make the\x{a}" ~
      "        deletion (overstrike, strike[through], etc.) or how the deleted matter\x{a}" ~
      "        should be displayed. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element del { attlist.del, content.del }
attlist.del =
  att.common,
  att.facsimile,
  att.trans,
  [
    a:documentation [
      xml:lang = "eng"
      "contains an indication of how the\x{a}" ~
      "          deletion should be rendered."
    ]
  ]
  attribute rend { text }?
content.gap = empty
gap =
  [
    a:documentation [
      xml:lang = "eng"
      "gap ― Indicates a point where material has\x{a}" ~
      "        been omitted in a transcription, whether as part of sampling practice or\x{a}" ~
      "        for editorial reasons described in the MEI header. When material is\x{a}" ~
      "        omitted because it is illegible or inaudible, <unclear>\x{a}" ~
      "        should be used instead. Similarly, use <damage> if the\x{a}" ~
      "        omission is due to damage and <del> if the omission is\x{a}" ~
      "        because the material is marked as deleted, or otherwise indicated as\x{a}" ~
      "        superfluous or spurious in the copy text by an author, scribe,\x{a}" ~
      "        annotator, or corrector. An indication of how much material has been\x{a}" ~
      "        omitted from the transcription may be recorded in the extent attribute.\x{a}" ~
      "        The unit attribute names the unit used for describing the extent of the\x{a}" ~
      "        gap. The reason attribute gives the reason for omission. Sample values\x{a}" ~
      "        include 'sampling', 'irrelevant', 'cancelled'. The resp attribute\x{a}" ~
      "        contains an ID reference to an element containing the name of the\x{a}" ~
      "        editor, transcriber or encoder responsible for the decision not to\x{a}" ~
      "        provide any transcription of the material and hence the application of\x{a}" ~
      "        the <gap> tag. The hand attribute signifies the hand which\x{a}" ~
      "        made the deletion in the case of text omitted from the transcription\x{a}" ~
      "        because of deliberate deletion by an identifiable hand. The cert\x{a}" ~
      "        attribute signifies the degree of certainty ascribed to the\x{a}" ~
      "        identification of the extent of the missing material. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element gap { attlist.gap, content.gap }
attlist.gap =
  att.common,
  att.edit,
  att.extent,
  att.handident,
  att.measurement,
  att.reasonident
content.handshift = empty
handshift =
  [
    a:documentation [
      xml:lang = "eng"
      "hand shift ― Marks the beginning of a\x{a}" ~
      "        passage written in a new hand, or of a change in the scribe, writing\x{a}" ~
      "        style, ink or character of the document hand. The character attribute\x{a}" ~
      "        describes characteristics of the hand, particularly those related to the\x{a}" ~
      "        quality of the writing, e.g., 'shaky', 'thick', regular'. A description\x{a}" ~
      "        of the tint or type of ink, e.g. 'brown' or the writing medium, e.g.\x{a}" ~
      "        'pencil', may be placed in the medium attribute. The new hand may be\x{a}" ~
      "        identified using the new attribute, while the previous hand may be\x{a}" ~
      "        recorded in the old attribute. The resp attribute contains an ID\x{a}" ~
      "        reference to an element containing the name of the editor or transcriber\x{a}" ~
      "        responsible for identifying the change of hand. The cert attribute\x{a}" ~
      "        signifies the degree of certainty ascribed to the identification of the\x{a}" ~
      "        new hand. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element handshift { attlist.handshift, content.handshift }
attlist.handshift =
  att.common,
  att.edit,
  att.facsimile,
  att.medium,
  [
    a:documentation [
      xml:lang = "eng"
      "describes the character of the new\x{a}" ~
      "          hand."
    ]
  ]
  attribute character { text }?,
  [
    a:documentation [
      xml:lang = "eng"
      "identifies the new hand. The value must\x{a}" ~
      "          contain the ID of a hand element given elsewhere in the\x{a}" ~
      "          document."
    ]
  ]
  attribute new { xsd:IDREF }?,
  [
    a:documentation [
      xml:lang = "eng"
      "identifies the old hand. The value must\x{a}" ~
      "          contain the ID of a hand element given elsewhere in the\x{a}" ~
      "          document."
    ]
  ]
  attribute old { xsd:IDREF }?
content.orig =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
orig =
  [
    a:documentation [
      xml:lang = "eng"
      "original ― Contains a reading which is\x{a}" ~
      "        marked as following the original, rather than being normalized or\x{a}" ~
      "        corrected. This element will often be combined with a regularized form\x{a}" ~
      "        within a choice element. The editor(s) responsible for asserting that\x{a}" ~
      "        the material is original may be recorded in the resp attribute. The\x{a}" ~
      "        value of resp must point to one or more identifiers declared in the\x{a}" ~
      "        document header. The cert attribute signifies the degree of certainty\x{a}" ~
      "        ascribed to the transcription of the original text. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element orig { attlist.orig, content.orig }
attlist.orig = att.common, att.edit, att.facsimile, att.typed
content.reg =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
reg =
  [
    a:documentation [
      xml:lang = "eng"
      "regularization ― Contains a reading which\x{a}" ~
      "        has been regularized or normalized in some sense. It is possible to\x{a}" ~
      "        identify the individual responsible for the regularization, and, using\x{a}" ~
      "        the choice and orig elements, to provide both original and regularized\x{a}" ~
      "        readings. The editor(s) responsible for asserting the regularized\x{a}" ~
      "        material may be recorded in the resp attribute. The value of resp must\x{a}" ~
      "        point to one or more identifiers declared in the document header. The\x{a}" ~
      "        cert attribute signifies the degree of certainty ascribed to the\x{a}" ~
      "        regularized reading. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element reg { attlist.reg, content.reg }
attlist.reg = att.common, att.edit
content.restore =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
restore =
  [
    a:documentation [
      xml:lang = "eng"
      "restore ― Indicates restoration of musical\x{a}" ~
      "        material to an earlier state by cancellation of an editorial or\x{a}" ~
      "        authorial marking or instruction. The desc (description) attribute gives\x{a}" ~
      "        a prose description of the means of restoration, 'stet' or\x{a}" ~
      "        'strike-down', for example. The cert attribute signifies the degree of\x{a}" ~
      "        certainty ascribed to the identification of the hand of the restoration.\x{a}" ~
      "        The type attribute may be used to indicate the action cancelled by the\x{a}" ~
      "        restoration. The resp attribute contains an ID reference to an element\x{a}" ~
      "        containing the name of the editor or transcriber responsible for\x{a}" ~
      "        identifying the hand of the restoration. The hand attribute signifies\x{a}" ~
      "        the hand of the agent which made the restoration. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element restore { attlist.restore, content.restore }
attlist.restore =
  att.common,
  att.facsimile,
  att.trans,
  att.typed,
  [
    a:documentation [
      xml:lang = "eng"
      "provides a description of the means of\x{a}" ~
      "          restoration."
    ]
  ]
  attribute desc { text }?
content.sic =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
sic =
  [
    a:documentation [
      xml:lang = "eng"
      "sic ― Contains apparently incorrect or\x{a}" ~
      "        inaccurate musical material. A correction for the apparent error may be\x{a}" ~
      "        given in an accompanying child or sibling corr element. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element sic { attlist.sic, content.sic }
attlist.sic = att.common, att.facsimile
content.subst = model.transcriptionLike, model.transcriptionLike+
subst =
  [
    a:documentation [
      xml:lang = "eng"
      "substitution ― Groups transcriptional\x{a}" ~
      "        elements when the combination is to be regarded as a single intervention\x{a}" ~
      "        in the text. This element is modelled on an element in the Text Encoding\x{a}" ~
      "        Initiative (TEI)."
    ]
  ]
  element subst { attlist.subst, content.subst }
attlist.subst = att.common
content.supplied =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
supplied =
  [
    a:documentation [
      xml:lang = "eng"
      "supplied ― Contains musical material\x{a}" ~
      "        supplied by the transcriber or editor in place of text which cannot be\x{a}" ~
      "        read, either because of physical damage or loss in the original or\x{a}" ~
      "        because it is illegible for any reason. When the presumed loss of text\x{a}" ~
      "        arises from an identifiable cause, agent signifies the causative agent.\x{a}" ~
      "        When the presumed loss of text arises from action (partial deletion,\x{a}" ~
      "        etc.) assignable to an identifiable hand, the hand attribute signifies\x{a}" ~
      "        the hand responsible for the action. The reason attribute indicates why\x{a}" ~
      "        the text has to be supplied, e.g. 'overbinding', 'faded ink', 'lost\x{a}" ~
      "        folio', 'omitted in original', etc. The source attribute contains the\x{a}" ~
      "        source of the supplied text. The editor(s) responsible for supplied\x{a}" ~
      "        material may be recorded in the resp attribute. The value of resp must\x{a}" ~
      "        point to one or more identifiers declared in the document header. The\x{a}" ~
      "        cert attribute signifies the degree of certainty ascribed to the\x{a}" ~
      "        supplied material. This element is modelled on an element in the Text\x{a}" ~
      "        Encoding Initiative (TEI)."
    ]
  ]
  element supplied { attlist.supplied, content.supplied }
attlist.supplied =
  att.agentident, att.common, att.edit, att.facsimile, att.reasonident
content.unclear =
  (text
   | model.textphraseLike
   | model.eventLike
   | model.eventLike.neumes
   | model.controleventLike
   | model.lyricsLike
   | model.midiLike
   | model.editLike
   | model.transcriptionLike
   | model.eventLike.measureFilling
   | model.noteModifierLike
   | model.sectionLike
   | model.measureLike
   | model.staffLike
   | model.layerLike)*
unclear =
  [
    a:documentation [
      xml:lang = "eng"
      "unclear ― Contains musical material that\x{a}" ~
      "        cannot be transcribed with certainty because it is illegible or\x{a}" ~
      "        inaudible in the source. Where the difficulty in transcription arises\x{a}" ~
      "        from an identifiable cause, the agent attribute signifies the causative\x{a}" ~
      "        agent. The cert attribute signifies the degree of certainty ascribed to\x{a}" ~
      "        the transcription of the text contained within the\x{a}" ~
      "        <unclear> element. Where the difficulty in transcription\x{a}" ~
      "        arises from action (partial deletion, etc.) assignable to an\x{a}" ~
      "        identifiable hand, the hand attribute signifies the hand responsible for\x{a}" ~
      "        the action. The reason attribute indicates why the material is difficult\x{a}" ~
      "        to transcribe. The resp attribute indicates the individual responsible\x{a}" ~
      "        for the transcription of the word, phrase, or passage contained with the\x{a}" ~
      "        <unclear> element. The value of resp must point to one or\x{a}" ~
      "        more identifiers declared in the document header. This element is\x{a}" ~
      "        modelled on an element in the Text Encoding Initiative\x{a}" ~
      "        (TEI)."
    ]
  ]
  element unclear { attlist.unclear, content.unclear }
attlist.unclear =
  att.agentident,
  att.common,
  att.edit,
  att.facsimile,
  att.handident,
  att.reasonident
